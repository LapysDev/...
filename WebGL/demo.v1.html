<!DOCTYPE html>
<!--[if lt IE 7]> <html class="internet-explorer-5 internet-explorer-6"> <![endif]-->
<!--[if IE 7]> <html class=internet-explorer-7> <![endif]-->
<!--[if IE 8]> <html class=internet-explorer-8> <![endif]-->
<!--[if IE 9]> <html class=internet-explorer-9> <![endif]-->
<html>
<head>
    <!-- Document Metadata -->
        <!-- Character Encoding Set -->
        <meta charset=utf-8>

    <!-- Document Stylesheet -->
    <style media=all type=text/css>
        /* DOM Elements */
            /* [All] */
            * { border-spacing: 0; box-sizing: inherit }

            /* <body> */
            body { display: table-row; margin: 0 }

            /* <body>, <html>, <main> */
            body, html, main { box-sizing: content-box; height: 100%; width: 100% }

            /* <html> */
            html { display: table }

            /* <main> */
            main {
                background-color: #000000;
                display: table-cell;
                overflow: hidden;
                vertical-align: middle
            }

        /* Components */
            /* Canvas */
            #canvas {
                background-color: #000000;
                display: block;
                margin: auto;
                outline: 1px solid #999999
            }
    </style>

    <!-- Document Title -->
    <title> WebGL </title>
</head>

<body>
    <!-- Main -->
    <main>
        <!-- Canvas -->
        <canvas id=canvas> </canvas>
    </main>

    <!-- Scripts -->
        <!-- GL Matrix -->
        <script language=javascript src=gl-matrix.min.js type=text/javascript> </script>

        <!-- Polyfill -->
        <script language=javascript src=polyfill.js type=text/javascript> </script>

        <!-- Document Script -->
        <script defer language=javascript type=application/javascript>
            /* Main */
            +(function Main() {
                /* Constant */
                    // Canvas
                    const CANVAS = document.getElementById("canvas") || document.createElement("canvas");
                        // ...
                        ResizeCanvas();

                    // Global
                    const GLOBAL = (function() { try { return Function("return this")() || eval("this") } catch (error) {} return typeof self == "undefined" ? (typeof window == "undefined" ? (typeof global == "undefined" ? undefined : global) : window) : self })();

                    // Web GL Renderer
                    const WEBGL_RENDERER = CANVAS.getContext("webgl");

                    // ...
                    let STRICT;

                /* Function > Resize Canvas */
                function ResizeCanvas() {
                    // Constant > Canvas (Size, Style)
                    const CANVAS_SIZE = Math.perc(Math.min(innerHeight, innerWidth), 75);
                    const CANVAS_STYLE = CANVAS.style;

                    // Modification > Canvas (Style) > (Height, Width)
                    CANVAS.height = CANVAS_SIZE;
                    CANVAS.width = CANVAS_SIZE;

                    CANVAS_STYLE.height = CANVAS_SIZE + "px";
                    CANVAS_STYLE.width = CANVAS_SIZE + "px"
                }

                /* Modification */
                    // Renderer
                        // Attach Shaders
                        WEBGL_RENDERER.attachShaders = function attachShaders(Program, ShaderCollection) { ShaderCollection.foreach(function(Shader) { WEBGL_RENDERER.attachShader(Program, Shader) }) };

                        // Create Buffer
                        WEBGL_RENDERER.createBuffer = (function() {
                            // Constant > Method
                            const METHOD = WEBGL_RENDERER.createBuffer;

                            // Return
                            return function createBuffer(BufferType) {
                                // Constant > (Renderer, Buffer)
                                const WEBGL_RENDERER = this;
                                const BUFFER = METHOD.call(WEBGL_RENDERER);

                                // Renderer > Bind Buffer
                                arguments.length && WEBGL_RENDERER.bindBuffer(BufferType, BUFFER);

                                // Return
                                return BUFFER
                            }
                        })();

                        // Create Shader
                        WEBGL_RENDERER.createShader = (function() {
                            // Constant > Method
                            const METHOD = WEBGL_RENDERER.createShader;

                            // Return
                            return function createShader(ShaderType, ShaderSourceScriptURL = null) {
                                // Constant > (Renderer, Shader)
                                const WEBGL_RENDERER = this;
                                const SHADER = METHOD.call(WEBGL_RENDERER, ShaderType);

                                // Renderer > Read Source
                                (ShaderSourceScriptURL === null) || WEBGL_RENDERER.readSource(ShaderSourceScriptURL).then(function(ShaderSourceScript) {
                                    // Renderer > (Shader Source, Compile Shader)
                                    WEBGL_RENDERER.shaderSource(SHADER, ShaderSourceScript);
                                    WEBGL_RENDERER.compileShader(SHADER)
                                });

                                // Return
                                return SHADER
                            }
                        })();

                        // Create Vertex Data
                        WEBGL_RENDERER.createVertexData = function createVertexData(CoordinatesA, CoordinatesB, CoordinatesC) { return new Float32Array([CoordinatesA, CoordinatesB, CoordinatesC].flat()) };

                        // Is Ready
                        WEBGL_RENDERER.def("isReady", {get: function isReady() { return !WEBGL_RENDERER.numberOfSourcesBeingRead }});

                        // Number Of Sources Being Read
                        WEBGL_RENDERER.numberOfSourcesBeingRead = +0;

                        // Read Source
                        WEBGL_RENDERER.readSource = function readSource(URL) {
                            // Constant > (Promises, XML HTTP Request)
                            const PROMISES = [];
                            const XML_HTTP_REQUEST = new XMLHttpRequest;

                            // Modification > Renderer > Number Of Sources Being Read
                            WEBGL_RENDERER.numberOfSourcesBeingRead += 1;

                            // Event > XML HTTP Request
                            XML_HTTP_REQUEST.addEventListener("loadend", function acquireSource() {
                                // Deletion
                                XML_HTTP_REQUEST.removeEventListener("loadend", acquireSource);

                                // Loop > Promise
                                PROMISES.foreach(function(Promise) { Promise.call(XML_HTTP_REQUEST, XML_HTTP_REQUEST.responseText) });

                                // Modification > Renderer > Number Of Sources Being Read
                                WEBGL_RENDERER.numberOfSourcesBeingRead -= 1
                            });

                            // XML HTTP Request > (Open, Send)
                            XML_HTTP_REQUEST.open("GET", URL);
                            XML_HTTP_REQUEST.send();

                            // Return
                            return {then: function then(Handler) { PROMISES.push(Handler); return this }}
                        };

                /* Global > ... */
                GLOBAL.CANVAS = CANVAS;
                GLOBAL.GLOBAL = GLOBAL;
                GLOBAL.WEBGL_RENDERER = WEBGL_RENDERER;

                /* Events > Global > Resize */
                GLOBAL.addEventListener("resize", ResizeCanvas);

                /* Phases */
                    // Initiate
                    function Initiate() {
                        /* Function */
                            /* Setup WebGL  --- NOTE (Lapys) -> Setup the OpenGL API in JavaScript`s WebGL form. */
                            function SetupWebGL() {}

                        // ...
                        SetupWebGL();

                        const PROGRAM = WEBGL_RENDERER.createProgram();

                        const FRAGMENT_SHADER = WEBGL_RENDERER.createShader(WEBGL_RENDERER["FRAGMENT_SHADER"], "fragment-shader.fs");
                        const VERTEX_SHADER = WEBGL_RENDERER.createShader(WEBGL_RENDERER["VERTEX_SHADER"], "vertex-shader.vs");

                        const COLOR_BUFFER = WEBGL_RENDERER.createBuffer(WEBGL_RENDERER["ARRAY_BUFFER"]);
                        const COLOR_VERTEX_DATA = WEBGL_RENDERER.createVertexData([1, +0, +0], [+0, 1, +0], [+0, +0, 1]);
                            WEBGL_RENDERER.bufferData(WEBGL_RENDERER["ARRAY_BUFFER"], COLOR_VERTEX_DATA, WEBGL_RENDERER["STATIC_DRAW"]);

                        const POSITION_BUFFER = WEBGL_RENDERER.createBuffer(WEBGL_RENDERER["ARRAY_BUFFER"]);
                        const POSITION_VERTEX_DATA = WEBGL_RENDERER.createVertexData([+0, .707, +0], [1, -1, +0], [-1, -1, +0]);
                            WEBGL_RENDERER.bufferData(WEBGL_RENDERER["ARRAY_BUFFER"], POSITION_VERTEX_DATA, WEBGL_RENDERER["STATIC_DRAW"]);

                        const TRANSFORMATION_MATRIX = glMatrix.mat4.create();
                            glMatrix.mat4.scale(TRANSFORMATION_MATRIX, TRANSFORMATION_MATRIX, [.33333, .33333, .33333]);

                        check(function() { return WEBGL_RENDERER.isReady }, null, function() {
                            const LOCATIONS = {attributes: {}, uniforms: {}};

                            WEBGL_RENDERER.attachShaders(PROGRAM, [FRAGMENT_SHADER, VERTEX_SHADER]);
                            WEBGL_RENDERER.linkProgram(PROGRAM);

                            LOCATIONS.attributes["COLOR"] = WEBGL_RENDERER.getAttribLocation(PROGRAM, "COLOR");
                                WEBGL_RENDERER.enableVertexAttribArray(LOCATIONS.attributes["COLOR"]);
                                WEBGL_RENDERER.bindBuffer(WEBGL_RENDERER["ARRAY_BUFFER"], COLOR_BUFFER);
                                WEBGL_RENDERER.vertexAttribPointer(LOCATIONS.attributes["COLOR"], 3, WEBGL_RENDERER["FLOAT"], STRICT = false, STRICT = +0, STRICT = +0);

                            LOCATIONS.attributes["POSITION"] = WEBGL_RENDERER.getAttribLocation(PROGRAM, "POSITION");
                                WEBGL_RENDERER.enableVertexAttribArray(LOCATIONS.attributes["POSITION"]);
                                WEBGL_RENDERER.bindBuffer(WEBGL_RENDERER["ARRAY_BUFFER"], POSITION_BUFFER);
                                WEBGL_RENDERER.vertexAttribPointer(LOCATIONS.attributes["POSITION"], 3, WEBGL_RENDERER["FLOAT"], STRICT = false, STRICT = +0, STRICT = +0);

                            WEBGL_RENDERER.useProgram(PROGRAM);

                            LOCATIONS.uniforms["TRANSFORMATION_MATRIX"]  =WEBGL_RENDERER.getUniformLocation(PROGRAM, "TRANSFORMATION_MATRIX");

                            (function RotateRender() {
                                glMatrix.mat4.rotateY(TRANSFORMATION_MATRIX, TRANSFORMATION_MATRIX, Math.degreesToRadians(1));
                                WEBGL_RENDERER.uniformMatrix4fv(LOCATIONS.uniforms["TRANSFORMATION_MATRIX"], STRICT = false, TRANSFORMATION_MATRIX);
                                WEBGL_RENDERER.drawArrays(WEBGL_RENDERER["TRIANGLES"], STRICT = +0, STRICT = 3);

                                requestAnimationFrame(RotateRender)
                            })()

                        });

                        // Return
                        return +0
                    }

                // ...
                Initiate();

                // Return
                return +0
            })()
        </script>
</body>
</html>
