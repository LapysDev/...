<html>
    <head>
        <style media=all type=text/css>
            body { display: table-cell; margin: 0; vertical-align: middle }
            body, html { height: 100%; width: 100% }
            html { display: table }
            main {
                border: 1px solid #CCCCCC;
                border-radius: 5px;
                height: 90%;
                margin: auto;
                width: 90%
            }

            #background { background-color: #090909 }

            #background, #render {
                height: inherit;
                position: absolute;
                width: inherit
            }

            #cursor {
                background-color: #0F0F0F;
                border: 1px solid #666666;
                border-radius: 3px;
                cursor: default;
                display: inline-block;
                font-family: Minecraft, monospace;
                font-size: 90%;
                padding: 0 4%;
                padding-top: 3px;
            }
                #cursor-x,
                #cursor-y {
                    background-color: transparent;
                    border: none;
                    color: inherit;
                    display: inline-block;
                    font: inherit;
                    margin: 0;
                    padding: 0;
                    text-align: right;
                    width: 25px
                }
                    #cursor-x, #cursor-y { outline: none }

            #hud {
                font-family: Roboto, "Cambria Math", sans-serif;
                font-size: 14px;
                left: 0;
                top: 0;
                z-index: 1
            }
            #hud, #hud *, .node, #tooltip {
                touch-action: none;
                user-drag: none;
                user-select: none
            }
                #hud::selection, #hud ::selection {
                    background-color: transparent;
                    text-shadow: 0 0 0 transparent
                }

            #hud [role=aside] {
                bottom: 0;
                display: table
            }
                #hud [role=aside] a {
                    background-color: transparent;
                    border-bottom: 3px solid #FCFCFC;
                    box-shadow: inset 0 0 0 0 #0F0F0F;
                    cursor: pointer;
                    display: inline-block;
                    margin: auto 2.5%;
                    padding: 0 5%;
                    padding-bottom: 2.5%;
                    padding-top: 2%;
                    transition: background-color 100ms ease-in 100ms, box-shadow 100ms linear 0s;
                }
                    #hud [role=aside] a:focus,
                    #hud [role=aside] a:hover {
                        background-color: #0F0F0F;
                        box-shadow: inset 0 -40px 0 0 #0F0F0F
                    }

                #hud [role=aside] [role=anchors],
                #hud [role=aside] [role=information] {
                    display: inline-block;
                    float: right;
                    height: 100%;
                    text-align: right;
                    width: 200px
                }

                #hud [role=aside] [role=anchors] {
                    display: table-cell;
                    vertical-align: middle
                }

                #hud [role=aside] [role=information] {
                    min-width: 300px
                }

            #hud [role=aside],
            #hud [role=input] {
                background-color: #303030;
                box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.25), 0 0 5px 5px rgba(0, 0, 0, 0.125);
                color: #FCFCFC;
                font-weight: 500;
                padding: 0.75% 2.5%;
                position: absolute;
                width: 95%
            }

            #hud [role=input] {
                font-size: 14px;
                overflow-y: hidden;
                top: 0
            }

            #hud [role=input] h1 { display: inline-block; margin: 0 1% }
            #hud [role=input] input { font-size: 90% }
            #hud [role=input] label { font-size: 100% }

            #hud [role=input] input {
                background-color: #0F0F0F;
                border: 1px solid #666666;
                border-bottom-width: 3px;
                color: #CFCFCF;
                cursor: pointer;
                font-family: Minecraft, monospace;
                margin: 5px auto;
                padding: 5px 1%;
                padding-bottom: 1.75px;
                text-indent: 10%;
                width: 75px
            }
                #hud [role=input] input:focus {
                    cursor: text;
                    border-color: #CCCCCC;
                    outline: none
                }

            #hud [role=input] label {
                display: inline-block;
                width: 150px
            }

            .node {
                background: rgba(0, 0, 255, 0.85);
                background: linear-gradient(135deg, rgba(0, 127, 255, 0.85), rgba(0, 0, 127, 0.85));
                border: 1px solid #CCCCCC;
                border-radius: 50%;
                box-shadow: 0 3px 3px 0 rgba(0, 0, 0, 0.5);
                box-sizing: border-box;
                color: #FCFCFC;
                cursor: pointer;
                display: table;
                font-family: Minecraft, monospace;
                font-size: 14px;
                font-weight: 100;
                height: 50px;
                left: 100px;
                position: absolute;
                text-align: center;
                top: 100px;
                transition: background 100ms ease-in 0s;
                width: 50px
            }
                .node:active, .node:focus, .node:hover {
                    background: rgba(0, 0, 225, 0.675);
                    background: linear-gradient(135deg, rgba(0, 0, 127, 0.85), rgba(0, 127, 255, 0.85))
                }

                .node [role=name] {
                    background-color: rgba(0, 0, 0, 0.85);
                    border: inherit;
                    border-radius: 3px;
                    box-shadow: inherit;
                    color: inherit;
                    font: inherit;
                    margin-left: -25px;
                    margin-top: 57.5px;
                    padding: 1px 10px;
                    position: absolute;
                    text-shadow: 0 0 3px rgba(0, 0, 0, 0.15)
                }

            #scene {
                height: 75%;
                overflow: hidden;
                width: 75%;
                z-index: 2
            }

            #tooltip {
                background-color: #000000;
                border: 1px solid #FCFCFC;
                border-radius: 3px;
                box-shadow: 0 0 3px 0 rgba(0, 0, 0, 0.5);
                color: #FCFCFC;
                font-family: Roboto, "Calibri Light", sans-serif;
                font-size: 13px;
                font-weight: 400;
                left: -100%;
                opacity: 0;
                padding: 10px 1%;
                pointer-events: none;
                position: fixed;
                top: -100%;
                transform: translateY(10px);
                transition: left, height, opacity, top, transform, width 150ms ease-in 0s;
                z-index: 3
            }
                #tooltip[state=visible] {
                    opacity: 0.75;
                    transform: translateY(0);
                    transition: opacity, transform 150ms ease-in 0s;
                }
        </style>

        <title> Minimum Spanning Tree </title>
    </head>

    <body>
        <section id=hud>
            <nav role=input>
                <h1> <label for=edgeCountInput> Number of Edges: </label> <input id=edgeCountInput max=20 min=0 type=number value='0'/> </h1>
                <h1> <label for=nodeCountInput> Number of Nodes: </label> <input id=nodeCountInput max=10 min=0 type=number value='0'/> </h1>
            </nav>

            <aside role=aside>
                <div role=anchors>
                    <a tooltip="Dynamic sandbox to determine the Minimum Spanning Tree, <em>blah blah blah</em> &hellip;"> About </a>
                    <a tooltip="<ul style='list-style: none; margin: 0; padding-left: 0'>
                        <li> 16CG021462 | Oluwafunmito Oshodi </li>
                    </ul>"> Contributions </a>
                </div>

                <div role=information>
                    <div> Pointer Coordinates: <span id=cursor><input id=cursor-x readonly type=number value='0'/>, <input id=cursor-y readonly type=number value='0'/></span> </div>
                </div>
            </aside>
        </section>

        <main id=scene>
            <canvas id=background> </canvas>
            <div id=render> </div>
        </main>

        <script language=javascript type=text/javascript>
            void function() {
                // Constant > (Background, Count Inputs, Render, Scene, Tooltip)
                var background = (document.getElementById("background") || document.getElementsByTagName("canvas").item(0)).getContext("2d");
                var countInputs = {
                    "edges": document.getElementById("edgeCountInput"),
                    "nodes": document.getElementById("nodeCountInput")
                };
                var render = document.getElementById("render");
                var scene = document.getElementById("scene") || document.getElementsByTagName("main").item(0);
                var tooltip = document.createElement("tooltip");

                /* Class */
                // : Node
                function Node(name, paint) {
                    // Constant > (Anchor, Drag, Element)
                    var anchor = {x: 0, y: 0};
                    var drag = {active: false, x: 0, y: 0};
                    var element = document.createElement("div");
                    var node = this;

                    // ...
                    Node.all.push(node);

                    // Function > ... Drag
                    function beginDrag(x, y) { anchor.x = x; anchor.y = y; drag.active = true }
                    function endDrag() { drag.active = false }
                    function updateDrag(x, y) {
                        // Constant > (Node, Render) ...
                        var nodeBounds = element.getBoundingClientRect(), nodeHeight = nodeBounds.bottom - nodeBounds.top, nodeWidth = nodeBounds.right - nodeBounds.left;
                        var renderBounds = render.getBoundingClientRect();

                        // ... Terminate
                        if (false == drag.active) return;

                        // ... Update > (X, Y)
                        if (nodeBounds.right > renderBounds.right) x = (renderBounds.right - renderBounds.left) - nodeWidth - 1;
                        else if (nodeBounds.left < renderBounds.left) x = 1;
                        else x = (x - anchor.x) + (anchor.x - (nodeWidth / 2));

                        if (nodeBounds.bottom > renderBounds.bottom) y = (renderBounds.bottom - renderBounds.top) - nodeHeight - 1;
                        else if (nodeBounds.top < renderBounds.top) y = 1;
                        else y = (y - anchor.y) + (anchor.y - (nodeHeight / 2));

                        // Modification > Node > (X, Y)
                        element.setAttribute('x', x);
                        element.setAttribute('y', y);

                        // ...
                        Node.paint(node)
                    }

                    // Modification > Node > (Element, Name, Neighbors)
                    node.element = element;
                    node.name = typeof name != "string" ? String(name) || null : name;
                    node.neighbors = [];

                    // Event > Element > Mouse ...
                    element.onmousedown = function(event) { beginDrag(event.pageX - render.getBoundingClientRect().left, event.pageY - render.getBoundingClientRect().top) };
                    element.onpointerdown = function(event) { beginDrag(event.pageX - render.getBoundingClientRect().left, event.pageY - render.getBoundingClientRect().top) };

                    element.onmouseleave = endDrag;
                    element.onpointerleave = endDrag;

                    element.onmousemove = function(event) { updateDrag(event.pageX - render.getBoundingClientRect().left, event.pageY - render.getBoundingClientRect().top) };
                    element.onpointermove = function(event) { updateDrag(event.pageX - render.getBoundingClientRect().left, event.pageY - render.getBoundingClientRect().top) };

                    element.onmouseup = endDrag;
                    element.onpointerup = endDrag;

                    // Modification > Element > ... --- NOTE (Lapys) -> Randomize where the `Node` spawns within the Render.
                    element.setAttribute("class", "node");
                    element.setAttribute('x', Math.max(0, Math.trunc(Math.random() * (render.getBoundingClientRect().right - render.getBoundingClientRect().left)) - 50));
                    element.setAttribute('y', Math.max(0, Math.trunc(Math.random() * (render.getBoundingClientRect().bottom - render.getBoundingClientRect().top)) - 50));

                    // Logic
                    if (name) {
                        // Constant > Element Label
                        var elementLabel = document.createElement("div");

                        // Insertion
                        element.appendChild(elementLabel);

                        // Modification > (Element Label, Name) > ...
                        elementLabel.innerText = name;
                        elementLabel.setAttribute("role", "name");

                        node.name = name
                    }

                    if (paint) Node.paint(node);

                    // Return
                    return node
                }
                    // ...
                    Node.all = [];

                    Node.connect = function connect(nodeA, nodeB) {
                        var connectedNodeA = ~nodeA.neighbors.indexOf(nodeB);
                        var connectedNodeB = ~nodeB.neighbors.indexOf(nodeA);

                        connectedNodeA || nodeA.neighbors.push(nodeB);
                        connectedNodeB || nodeB.neighbors.push(nodeA);

                        return false == connectedNodeA && false == connectedNodeB
                    };

                    Node.count = function count() { return Node.all.length };

                    Node.destroy = function destroy(node) {
                        for (var iterator = Node.count() - 1; ~iterator; --iterator)
                        if (node === Node.all[iterator]) {
                            (null === node.element.parentNode) || node.element.parentNode.removeChild(node.element);

                            Node.all[iterator] = Node.all[Node.count() - 1];
                            Node.all.pop();

                            return true
                        }

                        return false
                    };

                    Node.destroyAll = function destroyAll() { Node.all.length = 0 };

                    Node.disconnect = function disconnect(nodeA, nodeB) {
                        if (~nodeA.neighbors.indexOf(nodeB)) { nodeA.neighbors[nodeA.neighbors.indexOf(nodeB)] = nodeA.neighbors[nodeA.neighbors.length - 1]; nodeA.neighbors.pop() }
                        if (~nodeB.neighbors.indexOf(nodeA)) { nodeB.neighbors[nodeB.neighbors.indexOf(nodeA)] = nodeB.neighbors[nodeB.neighbors.length - 1]; nodeB.neighbors.pop() }
                    };

                    Node.paint = function paint(node) {
                        // Constant > Element
                        // : ...
                        var element = node.element;

                        (render === element.parentNode) || render.appendChild(element);
                        element.setAttribute("style", "left: " + Number.parseInt(element.getAttribute('x')) + "px; top: " + Number.parseInt(element.getAttribute('y')) + "px")
                    };

                // : Particle
                function Particle(x, y, size) {
                    // Constant > Particle
                    var particle = this;

                    // ...
                    Particle.all.push(particle);

                    // Modification > Particle > (Size, X, Y)
                    particle.size = Number.parseInt(size) || Math.trunc(Math.random() * 10) + 5;
                    particle.x = Number.parseFloat(x) || Math.trunc(Math.random() * background.canvas.width);
                    particle.y = Number.parseFloat(y) || background.canvas.height;

                    // Return
                    return particle
                }
                    // ...
                    Particle.all = [];

                    Particle.count = function count() { return Particle.all.length };

                    Particle.destroy = function destroy(particle) {
                        for (var iterator = Particle.count() - 1; ~iterator; --iterator)
                        if (particle === Particle.all[iterator]) {
                            Particle.all[iterator] = Particle.all[Particle.count() - 1];
                            Particle.all.pop();

                            return true
                        }

                        return false
                    };

                /* Function */
                    // Rebuild
                    function rebuild() {
                        // Constant > (Edge, Node) Count
                        var edgeCount = Number.parseInt(countInputs["edges"].value);
                        var nodeCount = Number.parseInt(countInputs["nodes"].value);

                        var edges = [];
                        var nodes = Node.all;

                        // Loop --- NOTE (Lapys) -> Remove excess Edges and Nodes.
                            // ...
                            while (nodes.length > nodeCount)
                            Node.destroy(nodes[Node.count() - 1]);

                            // ...
                            for (var iterator = nodes.length - 1; ~iterator; --iterator) {
                                var node = nodes[iterator];

                                for (var subiterator = node.neighbors.length - 1; ~subiterator; --subiterator)
                                edges.push(/* Edge */ [node, node.neighbors[subiterator]])
                            }

                            for (var iterator = edges.length - 1; ~iterator; --iterator)
                            for (var subiterator = edges.length - 1; ~subiterator; --subiterator) {
                                if (iterator != subiterator && (
                                    (edges[iterator][0] === edges[subiterator][0] && edges[iterator][1] === edges[subiterator][1]) ||
                                    (edges[iterator][0] === edges[subiterator][1] && edges[iterator][1] === edges[subiterator][0])
                                )) { edges[subiterator] = edges.pop(); break }
                            }

                            while (edges.length > edgeCount) {
                                var edge = edges.pop();
                                Node.disconnect(edge[0], edge[1])
                            }

                        // Loop --- NOTE (Lapys)
                        while (nodes.length < nodeCount) // -> Add sufficient Nodes.
                        new Node("Destination #" + (Node.count() + 1), true);

                        for (var iterator = nodes.length - 1; ~iterator; --iterator) // -> Ensure every Edge uniquely connects a Node.
                        if (0 == nodes[iterator].neighbors.length) {
                            if (edges.length < edgeCount) {
                                var index = iterator;

                                do index = Math.trunc(Math.random() * Node.count());
                                while (index === iterator);

                                Node.connect(nodes[index], nodes[iterator])
                                ++edges.length;
                            }
                        }

                        // Loop --- NOTE (Lapys) -> Connect random Nodes with sufficient Edges.
                        for (var iterator = edges.length; iterator < edgeCount; ++iterator) {
                            var indexA, indexB = Math.trunc(Math.random() * Node.count());

                            do indexA = Math.trunc(Math.random() * Node.count());
                            while (indexA === indexB && Node.count() > 1);

                            if (Node.connect(Node.all[indexA], Node.all[indexB]))
                            ++edges.length;
                        }

                        countInputs["edges"].value = edges.length
                    }

                    // Resize
                    function resize() {
                        // Constant > Canvas
                        var canvas = background.canvas;

                        // Style > Canvas > (Height, Width)
                        canvas.style.height = (canvas.height = render.getBoundingClientRect().bottom - render.getBoundingClientRect().top) + "px";
                        canvas.style.width = (canvas.width = render.getBoundingClientRect().right - render.getBoundingClientRect().left) + "px";

                        // Loop > ...
                        for (var iterator = Node.count() - 1; ~iterator; --iterator)
                        Node.paint(Node.all[iterator])
                    }

                /* Phases */
                // : Initiate
                void function Initiate() {
                    // Event > ... > Resize
                    onresize = resize;

                    // Insertion
                    document.body.appendChild(tooltip);

                    // Modification > ... > ...
                    countInputs["edges"].value = Math.trunc(Math.random() * (Number.parseInt(countInputs["edges"].max) - 1)) + 2;
                    countInputs["nodes"].value = Math.min(Number.parseInt(countInputs["edges"].value), Math.trunc(Math.random() * (Number.parseInt(countInputs["nodes"].max) - 1)) + 2);

                    tooltip.setAttribute("id", "tooltip");

                    window.Node = Node; // WARN (Lapys) -> For debugging...

                    // Loop --- NOTE (Lapys) -> Iterate through  the HTML DOM elements.
                    for (var currentParents = [], recentParents = [document.documentElement]; recentParents.length; (recentParents = currentParents), (currentParents = []))
                    for (var iterator = recentParents.length - 1; ~iterator; --iterator) {
                        // Constant > Children
                        var children = recentParents[iterator].children;

                        // Loop > ...
                        for (var subiterator = children.length - 1; ~subiterator; --subiterator)
                        void function(child) {
                            // Error Handling; Insertion
                            if ("string" != typeof child.tagName) return;
                            currentParents.push(child);

                            // ... --- NOTE (Lapys) -> Tooltip functionality.
                            if (null !== child.getAttribute("tooltip")) {
                                // Function > (Hide, Show) Tooltip --- REDACT (Lapys)
                                function hideTooltip() {
                                    tooltip.innerHTML = "";

                                    tooltip.setAttribute("state", "hidden");
                                    tooltip.removeAttribute("style")
                                }

                                function showTooltip() {
                                    var height = 0, width = 0;
                                    var x = child.getBoundingClientRect().left;
                                    var y = child.getBoundingClientRect().top;

                                    tooltip.innerHTML = child.getAttribute("tooltip"); {
                                        height = tooltip.getBoundingClientRect().bottom - tooltip.getBoundingClientRect().top;
                                        width = tooltip.getBoundingClientRect().right - tooltip.getBoundingClientRect().left;
                                        x += x - width < 0 ? 1 : -(width * 0.75);
                                        y += y - height < 0 ? 5 : -(height * 1.5)
                                    }

                                    tooltip.setAttribute("state", "visible");
                                    tooltip.setAttribute("style", "left: " + x + "px; top: " + y + "px")
                                }

                                // Event
                                // : ... > (Blur, Key Down)
                                onblur = hideTooltip;
                                onkeydown = hideTooltip;

                                // : Child > (Blur, Mouse ...)
                                child.onblur = hideTooltip;
                                child.onmouseleave = hideTooltip;
                                child.onmouseover = showTooltip
                            }
                        }(children.item(subiterator))
                    }

                    for (var input in countInputs)
                    void function(countInput) {
                        // Function > Validate --- NOTE (Lapys) -> Correct the value within the Count Inputs.
                        function validate() {
                            // Modification > [Count Input] > Value
                            if (Number.parseInt(countInput.max) < Number.parseInt(countInput.value)) countInput.value = countInput.max;
                            if (Number.parseInt(countInput.min) > Number.parseInt(countInput.value)) countInput.value = countInput.min;

                            // ...
                            rebuild()
                        }

                        // Event > Count Input > (Blur, Change, Focus, Input, Key ...)
                        countInput.onblur = validate;
                        countInput.onchange = validate;
                        countInput.onfocus = validate;
                        countInput.oninput = validate;
                        countInput.onkeydown = validate
                    }(countInputs[input]);

                    // ...
                    rebuild();
                    resize();

                    /* Update */
                    Update()
                }();

                // : Update
                background.clearRect(0, 0, background.canvas.width, background.canvas.height);
                function Update() {
                    /* [Particles] */ if (Math.random() > 0.975) {
                        // Constant > Particle
                        var particle = new Particle();

                        // ...
                        void function animateParticle() {
                            // Modification > Background > ...; ...
                            background.fillStyle = "rgba(255, 255, 255, 0.2)";
                            background.clearRect(particle.x - particle.size, particle.y - particle.size, particle.size * 2, particle.size * 3);

                            background.globalCompositeOperation = "destination-out";
                            background.beginPath();
                            background.arc(particle.x, particle.y, particle.size * 2, 0, 360);
                            background.closePath();
                            background.fill();

                            background.globalCompositeOperation = "source-over";
                            background.beginPath();
                            background.arc(particle.x, particle.y, particle.size, 0, 360);
                            background.closePath();
                            background.fill();

                            // Logic
                            if (particle.y < -particle.size || (particle.x < 0 || particle.x > background.canvas.width))
                                // Deletion
                                Particle.destroy(particle);

                            else {
                                // Modification > Particle > Y; ...
                                particle.y -= Math.random() / 2;
                                requestAnimationFrame(animateParticle)
                            }
                        }()
                    }

                    /* [Edges] */ {
                        // Constant > Render ...
                        var renderBounds = render.getBoundingClientRect();

                        // Modification > Background > (Line Width, Stroke Style)
                        background.lineWidth = 3;
                        background.strokeStyle = "#009900";

                        // ...; Loop
                        background.clearRect(0, 0, background.canvas.width, background.canvas.height);
                        for (var iterator = Node.count() - 1; ~iterator; --iterator) {
                            // Constant > Node ...
                            var node = Node.all[iterator];
                            var nodeBounds = node.element.getBoundingClientRect();

                            // Loop
                            for (var subiterator = node.neighbors.length - 1; ~subiterator; --subiterator) {
                                // Constant > Node Neighbor ...
                                var nodeNeighbor = node.neighbors[subiterator];
                                var nodeNeighborBounds = nodeNeighbor.element.getBoundingClientRect();

                                /* ... --- NOTE (Lapys) -> Draw a connecting Edge. */ {
                                    background.globalCompositeOperation = "source-over";
                                    background.beginPath();
                                    background.moveTo((nodeBounds.left - renderBounds.left) + ((nodeBounds.right - nodeBounds.left) / 2), (nodeBounds.top - renderBounds.top) + ((nodeBounds.bottom - nodeBounds.top) / 2));
                                    background.lineTo((nodeNeighborBounds.left - renderBounds.left) + ((nodeNeighborBounds.right - nodeNeighborBounds.left) / 2), (nodeNeighborBounds.top - renderBounds.top) + ((nodeNeighborBounds.bottom - nodeNeighborBounds.top) / 2));
                                    background.stroke();
                                    background.closePath()
                                }
                            }
                        }
                    }

                    /* ... */
                    requestAnimationFrame(Update)
                }
            }();
        </script>
    </body>
</html>
