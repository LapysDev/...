<!DOCTYPE html>
<html charset=UTF-8 dir=ltr encoding=UTF-8 lang=en-US language=English>
  <head>
    <!-- Document Metadata -->
    <meta charset="UTF-8"/>
    <meta content="height=device-height, initial-scale=1.0, maximum-scale=1.0, minimal-ui, minimum-scale=1.0, user-scalable=no, width=device-width" name="viewport"/>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>

    <!-- Document Stylesheet -->
    <style media=all type=text/css>@charset "us-ascii";
      /* <body> */
      body {
        background-color: #0F0F0F;
        display         : table-row-group;
        margin          : 0;
        overflow        : hidden
      }

      /* <body>, <canvas>, <html> */
      body, canvas, html {
        height: 100%;
        width : 100%
      }

      /* <canvas> */
      canvas {
        background-color      : #000000;
        border                : 1px solid #F0F0F0;
        box-sizing            : border-box;
        display               : table-row;
        margin                : auto;
        -ms-interpolation-mode: nearest-neighbor;
        image-rendering       : -webkit-crisp-edges;
        image-rendering       : -moz-crisp-edges;
        image-rendering       : crisp-edges;
        image-rendering       : pixelated
      }

      /* <html> */
      html {
        display                 : table;
        line-height             : 1.15;
        zoom                    : 1.0;
        -webkit-text-size-adjust: 100%
      }
    </style>
  </head>

  <body>
    <canvas id=canvas> </canvas>

    <input accept=".dfont, .otc, .otf, .ttc, .tte, .ttf, application/font-sfnt, application/x-font-ttf, font/otf, font/sfnt, font/ttf" id=file type="file"/>
    <input id=text maxlength=1 minlength=1 size=1 type=text value='A'/>

    <!-- Document Script -->
    <script defer language=javascript type=text/javascript>
      var context          = canvas.getContext("2d", {alpha: false, desynchronized: true});
      var offscreenCanvas  = canvas;
      var offscreenContext = context;

      /* Constant, Enumeration */
      var I = function(data) { return data }; // ->> Identity function/ matrix

      var colors = {
        black  : rgb(0.0, 0.0, 0.0),
        blue   : rgb(0.0, 0.0, 1.0),
        cyan   : rgb(0.0, 1.0, 1.0),
        gray   : rgb(0.5, 0.5, 0.5),
        green  : rgb(0.0, 1.0, 0.0),
        lime   : rgb(0.0, 1.0, 0.0),
        magenta: rgb(1.0, 0.0, 1.0),
        orange : rgb(1.0, 0.5, 0.0),
        red    : rgb(1.0, 0.0, 0.0),
        violet : rgb(1.0, 0.0, 0.5),
        white  : rgb(1.0, 1.0, 1.0),
        yellow : rgb(1.0, 1.0, 0.0)
      };

      /* Function */
      // [Draw] ...
      function drawCircle(coordinates, size, ...data) {
        drawEllipse(coordinates, new xy(size + coordinates.x, size + coordinates.y), ...data)
      }

      function drawEllipse(origin, target, ...data) {
        if (origin.x > target.x || target.y > target.y) return;
        var height = (int32_t) (target.y - origin.y) / 2;
        var width  = (int32_t) (target.x - origin.x) / 2;

        // ...
        for (var axis = height * width, x = 0, y = height; x !== width && 0 !== y; ) {
          drawPoint(new xy(origin.x + (width + x), origin.y + (height + y)), ...data); // ->> Bottom Right
          drawPoint(new xy(origin.x + (width + x), origin.y + (height - y)), ...data); // ->> Top    Right
          drawPoint(new xy(origin.x + (width - x), origin.y + (height + y)), ...data); // ->> Bottom Left
          drawPoint(new xy(origin.x + (width - x), origin.y + (height - y)), ...data); // ->> Top    Left

          // ... ->> Algorithm for bottom-right quadrant
          if (axis > ((height * pow(x + 1, 2)) / width) + ((width * pow(y + 0, 2)) / height)) { ++x; continue }
          if (axis > ((height * pow(x + 0, 2)) / width) + ((width * pow(y - 1, 2)) / height)) { --y; continue }
          if (axis > ((height * pow(x + 1, 2)) / width) + ((width * pow(y - 1, 2)) / height)) { ++x; --y }
        }
      }

      function drawGlyph(origin, target, unit, font, ...data) /* TODO (Lapys) */ {
        // Alias
        function F2DOT14       (number)                      { return (Fixed) (number, 2, 14) }                                                                                                                                                                                                                                       //
        function Fixed         (number, high = 16, low = 16) { var characteristics = Math.trunc(number), mantissa = Math.abs(number - characteristics); for (var rank = 1; ; rank *= 10) if (mantissa * rank >= (1 << low) - 1) { rank /= 10; return (characteristics & ((1 << high) - 1)) + (Math.trunc(mantissa * rank) / rank) } } // ->> Fixed-point number
        function FWORD         (integer)                     { return (int16) (integer) }                                                                                                                                                                                                                                             // ->> Quantity measured in font design units
        function LONGDATETIME  (integer)                     { var datetime = 0; for (var bit = 1, width = 64; integer > 0 && width; --width, bit *= 2) { datetime += bit * (integer % 2 === 1); integer /= 2 } return datetime }                                                                                                     // ->> Date-time represented in number of seconds since 12:00 midnight, January 1, 1904, UTC
        function Offset16      (integer)                     { return (uint16) (integer) }                                                                                                                                                                                                                                            // ->> Short offset to a table
        function Offset24      (integer)                     { return (uint24) (integer) }                                                                                                                                                                                                                                            // ->> 24-bit offset to a table
        function Offset32      (integer)                     { return (uint32) (integer) }                                                                                                                                                                                                                                            // ->> Long offset to a table
        function UFWORD        (integer)                     { return (uint16) (integer) }                                                                                                                                                                                                                                            // ->> Quantity measured in font design units
        function Version16Dot16(major, minor)                { if (arguments.length < 2) { minor = major; major = major >> 16 } return ((minor >>> 0) & 0xFFFF) | (((major >>> 0) & 0xFFFF) << 16) }                                                                                                                                  // ->> Packed 32-bit value with major and minor version numbers
          Version16Dot16.majorof = function(version) { return (version >>> 16) & 0xFFFF }
          Version16Dot16.minorof = function(version) { var version = version & 0xFFFF; return (((version >>> (4 * 0)) & 0xF) << (4 * 3)) | (((version >>> (4 * 1)) & 0xF) << (4 * 2)) | (((version >>> (4 * 2)) & 0xF) << (4 * 1)) | (((version >>> (4 * 3)) & 0xF) << (4 * 0)) };

        function int8  (integer) { return integer & 0x000000FF }
        function int16 (integer) { return integer & 0x0000FFFF }
        function int32 (integer) { return integer & 0xFFFFFFFF }
        function uint8 (integer) { return (integer >>> 0) & 0x000000FF }
        function uint16(integer) { return (integer >>> 0) & 0x0000FFFF }
        function uint24(integer) { return (integer >>> 0) & 0x00FFFFFF }
        function uint32(integer) { return (integer >>> 0) & 0xFFFFFFFF }

        function Tag(a, b, c, d) /* ->> Array of four `uint8`s (`0x20 <= x <= 0x7E`) used to identify baselines, design-variation axes, features, language systems, scripts, or tables */ {
          if (false === this instanceof xy)
          return new Tag(a, b, c, d);

          if (a instanceof xy) {
            this[0] = a[0];
            this[1] = a[1];
            this[2] = a[2];
            this[3] = a[3]
          }

          else {
            this[0] = (((uint8) (a) - 0x20) % 0x5E) + 0x20;
            this[1] = (((uint8) (b) - 0x20) % 0x5E) + 0x20;
            this[2] = (((uint8) (c) - 0x20) % 0x5E) + 0x20;
            this[3] = (((uint8) (d) - 0x20) % 0x5E) + 0x20
          }
        }
          Tag.prototype = {0: 0x20, 1: 0x20, 2: 0x20, 3: 0x20}; // --> [0x20, 0x20, 0x20, 0x20]

        // ... ->> Convert `font` to an 8-bit data stream (in this case a UTF-8 encoded string)
        if (typeof TextEncoder === "function")
          font = new TextEncoder().encode(font);

        else {
          var stream       = new (typeof Uint8Array === "function" ? Uint8Array : Array)(2 /* ->> Compensate for UTF-16 surrogate pairs */ * font.length);
          var streamLength = 0;

          // ...
          for (var index = 0, length = font.length; index !== length; ++index) {
            var codepoint = font.charCodeAt(index);

            // ... ->> Dual surrogate pair
            if (codepoint >= 0xD800 && codepoint <= 0xDBFF) {
              var next = font.charCodeAt(index + 1);

              // ...
              if ((next & 0xFC00) === 0xDC00) {
                codepoint = 0x10000 + (next & 0x03FF) + ((codepoint & 0x03FF) << 10);
                if (++index === length) break
              }
            }

            // ... ->> UTF-16 to UTF-8 code point conversion
            if (0 === (codepoint & 0xFFFFFF80))
              stream[streamLength++] = codepoint;

            else if (0 === (codepoint & 0xFFFFF800)) {
              stream[streamLength++] = 0xC0 | ((codepoint >>> 0x06) & 0x1F);
              stream[streamLength++] = 0x80 | ((codepoint >>> 0x00) & 0x3F)
            }

            else if (0 === (codepoint & 0xFFFF0000)) {
              if (codepoint >= 0xD800 && codepoint <= 0xDFFF) return;
              stream[streamLength++] = 0xE0 | ((codepoint >>> 0x0C) & 0x0F);
              stream[streamLength++] = 0x80 | ((codepoint >>> 0x06) & 0x3F);
              stream[streamLength++] = 0x80 | ((codepoint >>> 0x00) & 0x3F)
            }

            else if (0 === (codepoint & 0xFFE00000)) {
              stream[streamLength++] = 0xF0 | ((codepoint >>> 0x12) & 0x07);
              stream[streamLength++] = 0x80 | ((codepoint >>> 0x0C) & 0x3F);
              stream[streamLength++] = 0x80 | ((codepoint >>> 0x06) & 0x3F);
              stream[streamLength++] = 0x80 | ((codepoint >>> 0x00) & 0x3F)
            }

            else
              return
          }

          font = stream.slice(0, streamLength)
        }

        // ... ->> Assumed big-endian
        var entrySelector             = (uint16) (1);
        var rangeShift                = (uint16) (1);
        var scalableSplineFontVersion = (uint32) ((font[0] << (8 * 3)) | (font[1] << (8 * 2)) | (font[2] << (8 * 1)) | (font[3] << (8 * 0)));
        var searchRange               = (uint16) (1);
        var tableCount                = (uint16) ((font[4] << (8 * 1)) | (font[5] << (8 * 0)));
        var unit                      = unit.charAt(0) + "";

        // ...
        while (searchRange !== tableCount) {
          if (searchRange < tableCount) searchRange *= 2;
          if (searchRange > tableCount) { searchRange /= 2; break }
        }

        entrySelector = Math.log2(searchRange / 16);
        rangeShift    = ((tableCount * 16) - searchRange);

        console.log("…",            font);
        console.log("sfntVersion",   scalableSplineFontVersion);
        console.log("numTables",     tableCount);
        console.log("searchRange",   searchRange);
        console.log("entrySelector", entrySelector);
        console.log("rangeShift",    rangeShift);
      }

      function drawLine(origin, target, ...data) {
        var distances = new xy(abs(origin.x - target.x), abs(origin.y - target.y));
        var slope     = max   (abs(origin.x - target.x), abs(origin.y - target.y));
        var slopes    = new xy(0, 0);
        var x         = origin.x;
        var y         = origin.y;

        // ...
        while (
          (origin.x == target.x || x != target.x) &&
          (origin.y == target.y || y != target.y)
        ) {
          if (slope <= slopes.x) { slopes.x -= slope; origin.x < target.x ? ++x : --x }
          if (slope <= slopes.y) { slopes.y -= slope; origin.y < target.y ? ++y : --y }

          slopes.x += distances.x;
          slopes.y += distances.y;
          drawPoint(new xy(x, y), ...data)
        }
      }

      function drawPoint(coordinates, color = colors.white, transform = I, filter = I) {
        var color       = filter   (color);
        var coordinates = transform(coordinates);

        // ... ->> `…CanvasRenderingContext2d.prototype.putImage(…)` is terribly non-performant compared to `…CanvasRenderingContext2d.prototype.fillRect(…)`
        offscreenContext.fillStyle = "rgb(" + r(color) + ", " + g(color) + ", " + b(color) + ')';
        offscreenContext.fillRect(coordinates.x, coordinates.y, 1, 1)
      }

      function drawRectangle(origin, target, ...data) {
        if (origin.x > target.x || target.y > target.y)
          return;

        for (var x = target.x; origin.x !== --x; ) {
          drawPoint(new xy(x, origin.y), ...data);
          drawPoint(new xy(x, target.y), ...data)
        }

        for (var y = target.y; origin.y !== --y; ) {
          drawPoint(new xy(origin.x, y), ...data);
          drawPoint(new xy(target.x, y), ...data)
        }
      }

      function drawSpline(degree, origin, ...data) {
        var degree = (uint32_t) (degree);

        // ...
        if (0 === degree)
        return drawPoint(origin, ...data.slice(degree));

        var anchor      = origin;
        var controls    = [anchor, ...new Array(degree)];
        var subcontrols = new Array(degree + 1); // ->> Intermediate set of control points
        var x;
        var y;

        // ...
        for (var index = degree; index; --index)
        controls[index] = arguments[index + 1];

        data.splice(0, degree);

        for (var totalSamples = 256, currentSamples = totalSamples; currentSamples--; ) {
          for (var index = degree + 1; index--; )
          subcontrols[index] = (xy) (controls[index]);

          // ... ->> see `drawLine(…)`
          for (var subdegree = degree + 1; --subdegree; )
          for (var index = 0; index !== subdegree; ++index) {
            var origin = subcontrols[index + 0];
            var target = subcontrols[index + 1];

            var distances = new xy(abs(origin.x - target.x), abs(origin.y - target.y));
            var slope     = max   (abs(origin.x - target.x), abs(origin.y - target.y));
            var slopes    = new xy(0, 0);

            // ...
            x = origin.x;
            y = origin.y;

            for (var totalLength = distances.x + distances.y, currentLength = totalLength; (origin.x == target.x || x != target.x) && (origin.y == target.y || y != target.y); ) {
              if (slope <= slopes.x) { --currentLength; slopes.x -= slope; origin.x < target.x ? ++x : --x }
              if (slope <= slopes.y) { --currentLength; slopes.y -= slope; origin.y < target.y ? ++y : --y }

              slopes.x += distances.x;
              slopes.y += distances.y;

              if ((float) (currentLength / totalLength) <= (float) (currentSamples / totalSamples)) {
                origin.x = x;
                origin.y = y;

                break
              }
            }
          }

          drawLine(new xy(x, y), anchor, ...data);
          anchor = new xy(x, y)
        }
      }

      function drawSquare(coordinates, size, ...data) {
        drawRectangle(coordinates, new xy(size + coordinates.x, size + coordinates.y), ...data)
      }

      // [Filter] ...
      function bokehBlur   (spread,    filter = I) /* TODO (Lapys) */ { return null }
      function boxBlur     (spread,    filter = I) /* TODO (Lapys) */ { return null }
      function brightness  (intensity, filter = I) /* TODO (Lapys) */ { return null }
      function contrast    (intensity, filter = I) /* TODO (Lapys) */ { return null }
      function grayscale   (intensity, filter = I) /* TODO (Lapys) */ { return null }
      function guassianBlur(spread,    filter = I) /* TODO (Lapys) */ { return null }
      function hueRotate   (angle,     filter = I) /* TODO (Lapys) */ { return null }
      function invert      (intensity, filter = I) /* TODO (Lapys) */ { return null }
      function opacity     (intensity, filter = I) /* TODO (Lapys) */ { return null }
      function saturate    (intensity, filter = I) /* TODO (Lapys) */ { return null }
      function sepia       (intensity, filter = I) /* TODO (Lapys) */ { return null }

      // [Transform] ...
      function rotate(angle, anchor, transform = I) /* TODO (Lapys) */ { return null }
      function scale (size,  transform = I)         /* TODO (Lapys) */ { return null }
      function skew  (data,  transform = I)         /* TODO (Lapys) */ { return null }

      function translate(offset, transform = I) {
        return function(coordinates) {
          var coordinates = transform(coordinates);
          return new xy(coordinates.x + offset.x, coordinates.y + offset.y)
        }
      }

      // [Utility] ... ->> Optimized for 32-bit (signed) integers only unless otherwise specified
      function abs(integer) {
        var mask = ~(integer >>> 31) + 1;
        return (integer ^ mask) - mask
      }

      function b(color) {
        return (color >>> 0x00) & 0xFF
      }

      function float(number) {
        return +number
      }

      function g(color) {
        return (color >>> 0x08) & 0xFF
      }

      function int32_t(number) /* ->> Treated as a C-style cast, whereas it is a truncation function */ {
        return number | 0
      }

      function max(integerA, integerB) {
        var difference = integerA - integerB;
        return integerA - (difference * (difference >>> 31))
      }

      function pow(base, exponent) /* ->> `exponent` is a positive integer */ {
        for (var base = base, product = 1; ; base *= base) {
          if (exponent & 1 /* --> exponent % 2 */) product *= base;
          exponent >>>= 1; // --> exponent / 2
          if (0 === exponent) return product
        }
      }

      function r(color) {
        return (color >>> 0x10) & 0xFF
      }

      function rgb(red, green, blue) /* ->> Specified for floating-point channels between `+0.0` and `1.0` */ {
        return (((int32_t) (blue * 0xFF)) << 0x00) | (((int32_t) (green * 0xFF)) << 0x08) | (((int32_t) (red * 0xFF)) << 0x10)
      }

      function uint32_t(number) /* ->> See `int32_t(…)` */ {
        return number >>> 0
      }

      function xy(x, y) {
        if (this instanceof xy) {
          if (x instanceof xy) { this.x = x.x; this.y = x.y }
          else { this.x = (int32_t) (x); this.y = (int32_t) (y) }

          return // --> this
        }

        return new xy(x, y)
      }
        xy.prototype = {x: 0, y: 0};

      // ...
      function render() {
        // drawCircle   (xy(145, 20), 750 - 20,     colors.blue);
        // drawEllipse  (xy(20,  20), xy(980, 750), colors.red);
        // drawLine     (xy(20,  20), xy(980, 750), colors.magenta);
        // drawRectangle(xy(20,  20), xy(980, 750), colors.green);
        // drawSquare   (xy(145, 20), 750 - 20,     colors.cyan);

        drawLine  (   xy(20, 20),                                        xy(980, 980));
        drawSpline(1, xy(20, 20),                                        xy(980, 980), colors.blue);
        drawSpline(2, xy(20, 20), xy(980, 20),                           xy(980, 980), colors.red);
        drawSpline(3, xy(20, 20), xy(980, 20), xy(980, 20),              xy(980, 980), colors.green);
        drawSpline(4, xy(20, 20), xy(980, 20), xy(980, 20), xy(980, 20), xy(980, 980), colors.orange);

        // drawGlyph(xy(20, 20), xy(980, 980), 'A', "font.ttf");

        context.drawImage(offscreenContext.canvas, 0, 0)
      }

      function resize() {
        var size  = innerHeight < innerWidth ? innerHeight : innerWidth; // --> window . …
        var style = canvas.style;
        var zoom  = devicePixelRatio;

        // ...
        for (var node = canvas; 0x1 /* --> Node.ELEMENT_NODE */ === node.nodeType; node = node.parentNode)
        zoom *= getComputedStyle(node).getPropertyValue("zoom");

        canvas .height                = size * zoom;
        canvas .width                 = size * zoom;
        context.imageSmoothingEnabled = false;
        context.imageSmoothingQuality = "low";
        style  .height                = size + "px";
        style  .width                 = size + "px";

        if (typeof HTMLCanvasElement.prototype.transferControlToOffscreen === "function") {
          offscreenCanvas  = canvas.ownerDocument.createElement("canvas").transferControlToOffscreen();
          offscreenContext = offscreenCanvas.getContext("2d");

          offscreenCanvas .height                = canvas.height;
          offscreenCanvas .width                 = canvas.width;
          offscreenContext.imageSmoothingEnabled = false;
          offscreenContext.imageSmoothingQuality = "low"
        }

        // ...
        render()
      }

      /* ... */
      document.onreadystatechange = function() { if (this.readyState === "complete") resize() };
      file    .oninput            = function() { var file = this.files.item(0); if (null !== file) { var reader = new FileReader(); reader.onloadend = function() { drawGlyph(xy(0, 0), xy(canvas.width, canvas.height), text.value || ' ', this.result) }; reader.readAsText(file) } };
      window  .onresize           = function() { resize() }
    </script>
  </body>
</html>
