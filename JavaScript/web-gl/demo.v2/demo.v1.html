<!DOCTYPE html>
<!--[if lt IE 7]> <html class="internet-explorer-5 internet-explorer-6"> <![endif]-->
<!--[if IE 7]> <html class=internet-explorer-7> <![endif]-->
<!--[if IE 8]> <html class=internet-explorer-8> <![endif]-->
<!--[if IE 9]> <html class=internet-explorer-9> <![endif]-->
<html>
<head>
    <!-- Document Metadata -->
        <!-- Character Encoding Set -->
        <meta charset=utf-8>

    <!-- Document Stylesheet -->
    <style media=all type=text/css>
        /* DOM Elements */
            /* All */
            * { box-sizing: inherit }

            /* <body> */
            body { margin: 0 }

            /* <body>, <html>, <main>) */
            body, html, main { height: 100%; width: 100% }

            /* <html> */
            html { box-sizing: border-box }

        /* Components > Canvas */
        #canvas {
            border: 1.5px solid rgba(0, 0, 0, .1);
            box-shadow: 0 5px 5px 0 rgba(0, 0, 0, .3),
                0 0 10000px 10000px rgba(0, 0, 0, .675);
            height: 100%;
            margin: auto;
            outline: 1px solid #CCCCCC;
            position: relative;
            transition: .1s ease-out;
            width: 100%
        }
            /* States > Hover */
            #canvas:hover {
                box-shadow: 0 3px 3px 0 rgba(0, 0, 0, .5),
                    0 0 10000px 10000px rgba(0, 0, 0, .675)
            }
    </style>

    <!-- Document Title -->
    <title> WebGL | 3 - Spinning Triangle </title>
</head>

<body>
    <!-- Main -->
    <main>
        <!-- Canvas -->
        <canvas id=canvas> </canvas>
    </main>

    <!-- Scripts -->
        <!-- GL Matrix Script -->
        <script defer language=javascript src=gl-matrix.min.js type=text/javascript> </script>

        <!-- Document Script -->
        <script defer language=javascript type=text/javascript>
            /* Global > Canvas, Global, Renderer, Strict */
            const CANVAS = document.getElementById("canvas"),
                GLOBAL = this, RENDERER = CANVAS.getContext("webgl");
            var STRICT = false;

            /* Polyfill > ... */
            Math.perc = function perc(base, exponent) { return arguments.length == 1 ? base / 100 : base * (exponent / 100) };

            Object.iterate = function iterate(object, handler, INQUIRE_PROPERTY_VALUES_INSTEAD) { for (var propertyIdentifier in object) handler.call(object, INQUIRE_PROPERTY_VALUES_INSTEAD ? object[propertyIdentifier] : propertyIdentifier); return object };
            Object.port = function port(destination, source, OVERRIDE_PROPERTIES) { Array.prototype.concat.call([], Object.getOwnPropertyNames(source), Object.getOwnPropertySymbols(source)).forEach(propertyIdentifier => { (!Object.hasOwnProperty(destination, propertyIdentifier) || OVERRIDE_PROPERTIES) && Object.defineProperty(destination, propertyIdentifier, Object.getOwnPropertyDescriptor(source, propertyIdentifier)) }); return destination };

            String.prototype.remove = function remove(match) { return String.prototype.replace.call(this, match, "") + "" };

            /* Main */
            (function Main() {
                /* Class */
                    // Web GL Buffer
                    function WebGLBuffer(context) { return context.createBuffer() }

                    // Web GL Program
                    function WebGLProgram(context) { return context.createProgram() }

                    // Web GL Shader
                    function WebGLShader(context, type, source, PROGRAM_TO_ATTACH_SHADER) {
                        // Constant > Shader
                        const shader = context.createShader(context[type]);

                        // Context > (Shader Source, Compile Shader, Attach Shader)
                        context.shaderSource(shader, source);
                        context.compileShader(shader);
                        (typeof PROGRAM_TO_ATTACH_SHADER == "undefined") || context.attachShader(PROGRAM_TO_ATTACH_SHADER, shader);

                        // Return
                        return shader
                    }

                    // Web GL Vertex Array
                    function WebGLVertexArray(vertices) {
                        // Constant > Array
                        const array = [];

                        // Loop > Update > Array
                        vertices.forEach(vertex => array.push(vertex[0], vertex[1], vertex[2]));

                        // Return
                        return new Float32Array(array)
                    }

                /* Function */
                    // Restyle Canvas
                    function restyleCanvas() {
                        // Constant
                            // Canvas Parent Element (Height, Width)
                            const CANVAS_PARENT_ELEMENT_HEIGHT = +(getComputedStyle(CANVAS.parentElement).getPropertyValue("height").remove(/cm|em|ft|in|px|rem|vh|vw|%/)),
                                CANVAS_PARENT_ELEMENT_WIDTH = +(getComputedStyle(CANVAS.parentElement).getPropertyValue("width").remove(/cm|em|ft|in|px|rem|vh|vw|%/));

                            // Canvas (Height, Width)
                            const CANVAS_HEIGHT = Math.perc(CANVAS_PARENT_ELEMENT_HEIGHT, 95),
                                CANVAS_WIDTH = Math.perc(CANVAS_PARENT_ELEMENT_WIDTH, 95);

                            // Canvas Size --- NOTE (Lapys) -> Make the canvas a square instead.
                            const CANVAS_SIZE = Math.min(CANVAS_HEIGHT, CANVAS_WIDTH);

                        // Modification
                            // Canvas > (Height, Width)
                            CANVAS.height = CANVAS_SIZE;
                            CANVAS.width = CANVAS_SIZE;

                            // Renderer > Drawing Buffer (Height, Width)
                            RENDERER.drawingBufferHeight = CANVAS.height;
                            RENDERER.drawingBufferWidth = CANVAS.width;

                        /* Style > Canvas > ...
                                --- NOTE (Lapys) -> It would be cool to shade the area of the canvas not filled because its a square.
                                --- REDACT (Lapys)
                        */
                        Object.port(CANVAS.style, {
                            bottom: ((innerHeight - CANVAS_SIZE) / 2) + "px",
                            left: ((innerWidth - CANVAS_SIZE) / 2) + "px",
                            height: CANVAS.height + "px",
                            right: ((innerWidth - CANVAS_SIZE) / 2) + "px",
                            top: ((innerHeight - CANVAS_SIZE) / 2) + "px",
                            width: CANVAS.width + "px"
                        })
                    }; restyleCanvas();

                    // Setup WebGL Buffer
                    function setupWebGLBuffer(context, buffer, type, vertexArray, DRAW_INTENT) {
                        // Constant > Buffer Type
                        const BUFFER_TYPE = context[type];

                        // Context > (Bind Buffer, Buffer Data)
                        context.bindBuffer(BUFFER_TYPE, buffer);
                        context.bufferData(BUFFER_TYPE, vertexArray, STRICT = context[DRAW_INTENT ? DRAW_INTENT : "STATIC_DRAW"]);
                    }

                    // Setup WebGL Vertex Attribute Location
                    function setupWebGLVertexAttributeLocation(context, vertexAttributeLocation, buffer, bufferType, NORMALIZE, STRIDE, OFFSET) {
                        // Context > (Enable Vertex Attribute Array, Bind Buffer, Vertex Attribute Pointer)
                        context.enableVertexAttribArray(vertexAttributeLocation);
                        context.bindBuffer(context[bufferType], buffer);
                        context.vertexAttribPointer(vertexAttributeLocation, 3, context["FLOAT"], STRICT = !!NORMALIZE, STRICT = +(STRIDE || 0), STRICT = +(OFFSET || 0))
                    }

                /* Event */
                    // Document > (Ready State Change, Resize)
                    document.onreadystatechange = function() { (document.readyState == "complete") && Update(); document.onreadystatechange = null };
                    document.onresize = restyleCanvas;

                    // Global > On Resize
                    GLOBAL.onresize = restyleCanvas;

                /* Phase */
                    /* Initiate --- NOTE (Lapys) -> Load up all the boilerplate code and let all third-party code install. */
                    function Initiate() {
                        /* Global */
                            // Attribute Locations, Buffers, Shaders, Uniform Locations, Vertex Data
                            const ATTRIBUTE_LOCATIONS = {}, BUFFERS = {}, SHADERS = {}, UNIFORM_LOCATIONS = {}, VERTEX_DATA = {};

                            // Matrix, Program
                            var MATRIX = null; // NOTE (Lapys) -> Usually used for transformation data.
                            const PROGRAM = new WebGLProgram(RENDERER);

                        /* Function */
                            /* Animation[ | Continuous] Draw */
                            function ContinuousDraw() {
                                // GL Matrix > 4x4 Matrix > Rotate Z
                                GLMatrix.mat4.rotateZ(MATRIX, MATRIX, Math.PI / 2 / 70); // NOTE (Lapys) -> Rotate (on the Z-axis).

                                // Renderer
                                    // Uniform 4x4 Float Vector Matrix --- NOTE (Lapys) -> Link the transformation data to the WebGL Rendering Context (Renderer).
                                    RENDERER.uniformMatrix4fv(UNIFORM_LOCATIONS["MATRIX"], false /* NOTE (Lapys) -> Transpose? */, MATRIX);

                                    // Draw Arrays --- NOTE (Lapys) -> Re-render the updated drawing.
                                    RENDERER.drawArrays(RENDERER["TRIANGLES"], 0, 3);

                                // Request Animation Frame > Continuous Draw
                                requestAnimationFrame(ContinuousDraw)
                            }

                            /* Initial Draw --- WARN (Lapys) -> Called by `IntegrateGLMatrix` module. */
                            function InitialDraw() {
                                // Update
                                    // Attribute Locations
                                    Object.port(ATTRIBUTE_LOCATIONS, {
                                        COLOR: RENDERER.getAttribLocation(PROGRAM, "color"),
                                        POSITION: RENDERER.getAttribLocation(PROGRAM, "position")
                                    });

                                    // Matrix
                                    MATRIX = GLMatrix.mat4.create();

                                    // Uniform Locations
                                    Object.port(UNIFORM_LOCATIONS, {
                                        MATRIX: RENDERER.getUniformLocation(PROGRAM, "matrix")
                                    });

                                // Renderer > Use Program
                                RENDERER.useProgram(PROGRAM);

                                /* GL Matrix > 4x4 Matrix > (Translate, Scale)
                                        --- NOTE (Lapys) -> Add some non-default transformation data.
                                        --- WARN (Lapys) -> Transformations are applied in reverse sequence.
                                */
                                GLMatrix.mat4.translate(MATRIX, MATRIX, [.2, .5, 0]); // NOTE (Lapys) -> Translate
                                GLMatrix.mat4.scale(MATRIX, MATRIX, [.25, .25, .25]); // NOTE (Lapys) -> Scale.

                                // Renderer > Uniform 4x4 Float Vector Matrix
                                RENDERER.uniformMatrix4fv(UNIFORM_LOCATIONS["MATRIX"], false, MATRIX);

                                // Loop > Setup WebGL Vertex Attribute Location
                                Object.iterate(ATTRIBUTE_LOCATIONS, attributeLocationName => setupWebGLVertexAttributeLocation(RENDERER, ATTRIBUTE_LOCATIONS[attributeLocationName], BUFFERS[attributeLocationName], "ARRAY_BUFFER", STRICT = false, STRICT = 0, STRICT = 0));

                                // Renderer > Draw Arrays
                                RENDERER.drawArrays(RENDERER["TRIANGLES"], 0, 3);

                                // Continuous Draw
                                ContinuousDraw()
                            }

                            /* Integrate GL Matrix --- NOTE (Lapys) -> Unfortunately, GL Matrix seems to be asynchronously integrated. */
                            function IntegrateGLMatrix() {
                                // Logic
                                if (typeof glMatrix == "undefined")
                                    // Initialization > Animation Frame ID
                                    var animationFrameID = requestAnimationFrame(
                                        /* NOTE (Lapys) -> Re-assert if the GL Matrix framework is ready. */
                                        function() { IntegrateGLMatrix(); cancelAnimationFrame(animationFrameID) }
                                    );

                                else {
                                    /* Global > GL Matrix */
                                    Object.defineProperty(GLOBAL, "GLMatrix", {configurable: false, enumerable: true, value: glMatrix, writable: false});

                                    // Initial Draw
                                    InitialDraw()
                                }
                            }

                        /* Update */
                            // Buffers
                            Object.port(BUFFERS, {
                                COLOR: new WebGLBuffer(RENDERER),
                                POSITION: new WebGLBuffer(RENDERER)
                            });

                            // Shaders
                            Object.port(SHADERS, {
                                // [Fragment]
                                FRAGMENT: new WebGLShader(RENDERER, "FRAGMENT_SHADER", `
                                    // ...
                                    precision mediump float;

                                    // Initialization > Varying Color
                                    varying vec3 varyingColor;

                                    /* Main */
                                    void main() { gl_FragColor = vec4(varyingColor, 1); }
                                `.slice(1, -1).remove(/                            /g), STRICT = PROGRAM),

                                // [Vertex]
                                VERTEX: new WebGLShader(RENDERER, "VERTEX_SHADER", `
                                    // ...
                                    precision mediump float;

                                    // Initialization > (Color, Position, Matrix, Varying Color)
                                    attribute vec3 color, position;
                                    uniform mat4 matrix;
                                    varying vec3 varyingColor;

                                    /* Main */
                                    void main() { gl_Position = matrix * vec4(position, 1); varyingColor = color; }
                                `.slice(1, -1).remove(/                            /g), STRICT = PROGRAM)
                            });

                            // Vertex Data
                            Object.port(VERTEX_DATA, {
                                COLOR: new WebGLVertexArray([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),
                                POSITION: new WebGLVertexArray([[0, .707, 0], [1, -1, 0], [-1, -1, 0]])
                            });

                        // Loop > Setup WebGL Buffer; Renderer > Link Program
                        Object.iterate(BUFFERS, bufferName => setupWebGLBuffer(RENDERER, BUFFERS[bufferName], "ARRAY_BUFFER", VERTEX_DATA[bufferName], STRICT = "STATIC_DRAW"));
                        RENDERER.linkProgram(PROGRAM);

                        // ...
                        IntegrateGLMatrix();

                        // Return
                        return 0
                    }

                    /* Update --- WARN (Lapys) -> Called by the Initiate phase. */
                    function Update() { return 0 }

                    /* Reset */
                    function Reset() { return 0 }

                    /* Terminate */
                    function Terminate() { return 0 }

                // Logic > (Error | Initiate)
                if (RENDERER === null) throw new Error("WebGL must be supported");
                else Initiate();

                // Return
                return 0
            })()
        </script>
</body>
</html>
