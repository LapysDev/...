// UnityEngine.RectTransformUtility.PixelAdjustPoint
// UnityEngine.RectTransformUtility.ScreenPointToRay
global using Animation = Game.Animation;                                                             //
global using Game.Collections;                                                                       // ->> Expose custom collections e.g. `GameObjectSharedList<T>`, `RefDictionary<T>`, …
global using GameBurst = Unity.Burst.BurstCompileAttribute;                                          //
global using GameExecutionOrder = UnityEngine.DefaultExecutionOrder;                                 //
global using GameLayout         = System.Runtime.InteropServices.StructLayoutAttribute;              // ->> Un-manages the structure of class types
global using GameMethod         = System.Runtime.CompilerServices.MethodImplAttribute;               // ->> Modify function with compile attributes e.g. inlined, optimized, unmanaged, …, e.t.c.
global using GameOffset         = System.Runtime.InteropServices.FieldOffsetAttribute;               // ->> Adjust offset of fields within structurally-unmanaged class types
global using GameUnburst        = Unity.Burst.BurstDiscardAttribute;                                 // ->> `Unity.Burst.CompilerServices.IgnoreWarning(…)`?
#if NET7_0 || NET7_0_OR_GREATER                                                                      // ->> Modify constructor with diagnostic features
  global using GameConstructor = System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute;       //    ^^
#endif                                                                                               //
#if NET9_0 || NET9_0_OR_GREATER                                                                      // ->> Modify function priority over another overload during resolution; Defaults to `GameResolution(0)` for all functions
  global using GameResolution = System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute; //    ^^
#endif                                                                                               //
global using static System.Runtime.CompilerServices.MethodImplOptions;                               // ->> Use case: `𝑓 GameMethod(AggressiveOptimization, …)`
global using static System.Runtime.InteropServices.LayoutKind;                                       // ->> Use case: `𝑓 GameLayout(Sequential, …)`
using               UnityEngine.InputSystem;                                                         //

/* C# Polyfills */
namespace System.Runtime.Versioning {
  [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Constructor | System.AttributeTargets.Method | System.AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
  internal sealed class NonVersionableAttribute : System.Attribute {
    public NonVersionableAttribute() {}
  }
}

#if !(NET5_0 || NET5_0_OR_GREATER)
  namespace System.Runtime.CompilerServices {
    // ->> `init` @ `https://web.archive.org/web/20220918192058/https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/init`
    internal static class IsExternalInit {}
  }
#endif

#if !(NET7_0 || NET7_0_OR_GREATER)
  namespace System.Runtime.CompilerServices {
    // ->> `required` @ `https://web.archive.org/web/20220924164132/https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/required`
    public        class CompilerFeatureRequiredAttribute : System.Attribute { public CompilerFeatureRequiredAttribute(string name) {} }
    public sealed class RequiredMemberAttribute          : System.Attribute {}
  }

  namespace System.Diagnostics.CodeAnalysis {
    // ->> `System.Diagnostics.CodeAnalysis.UnscopedRefAttribute` @ `https://web.archive.org/web/20250401033710/https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.codeanalysis.unscopedrefattribute?view=net-9.0`
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.Diagnostics.DebuggerNonUserCode]
    [System.AttributeUsage(System.AttributeTargets.Method | System.AttributeTargets.Parameter | System.AttributeTargets.Property, Inherited = false)]
    sealed class UnscopedRefAttribute : System.Attribute {}
  }

  // ->> `System.Diagnostics.CodeAnalysis.SetsRequiredMembers` @ `https://web.archive.org/web/20250401051947/https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.codeanalysis.setsrequiredmembersattribute?view=net-9.0`
  [System.AttributeUsage(System.AttributeTargets.Constructor, AllowMultiple = false, Inherited = false)]
  [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
  [System.Diagnostics.DebuggerNonUserCode]
  public sealed class GameConstructor : System.Attribute {}
#endif

#if !(NET8_0 || NET8_0_OR_GREATER)
  namespace System.Runtime.CompilerServices {
    // ->> Collection Expressions @ `https://web.archive.org/web/20231114165920/https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/collection-expressions`
    [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Interface | System.AttributeTargets.Struct, Inherited = false)]
    [System.Diagnostics.DebuggerNonUserCode]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class CollectionBuilderAttribute : System.Attribute {
      public System.Type BuilderType { get; }
      public string      MethodName  { get; }

      /* … */
      public CollectionBuilderAttribute(System.Type builderType, string methodName) {
        this.BuilderType = builderType;
        this.MethodName  = methodName;
      }
    }
  }
#endif

#if !(NET9_0 || NET9_0_OR_GREATER)
  // ->> `System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute` @ `https://web.archive.org/web/20240920192519/https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.overloadresolutionpriorityattribute?view=net-9.0`
  [System.AttributeUsage(System.AttributeTargets.Method | System.AttributeTargets.Constructor | System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
  [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
  [System.Diagnostics.DebuggerNonUserCode]
  public sealed class GameResolution : System.Attribute {
    public int Priority { get; init; }
    public GameResolution(int priority) => this.Priority = priority;
  }
#endif

#if NET46X || NET47X || NET48X || NETCOREAPP2X || NETSTANDARD2_0
  namespace System {
    // ->> `System.Index` @ `https://web.archive.org/web/20241129171203/https://learn.microsoft.com/en-us/dotnet/api/system.index?view=net-9.0`
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.Diagnostics.DebuggerNonUserCode]
    public readonly struct Index : System.IEquatable<Index> {
      public  static   Index End       => new(~0);
      public  static   Index Start     => new(+0);
      public  readonly bool  IsFromEnd => this.value < 0;
      public  readonly int   Value     => this.value < 0 ? ~this.value : this.value;
      private readonly int   value;

      /* … */
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] private Index(int value)                       => this.value = value;
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public  Index(int value, bool fromEnd = false) {  this.value = fromEnd ? ~value : value; if (value < 0) { throw new System.ArgumentOutOfRangeException(nameof(value)); } }

      /* … */
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public  readonly override bool   Equals                         (object? value) => value is Index index && this.Equals(index);
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public  readonly          bool   Equals                         (Index   index) => index.value == this.value;
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public  static            Index  FromEnd                        (int     value) { if (value < 0) { throw new System.IndexOutOfRangeException(nameof(value)); } return new(~value); }
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public  static            Index  FromStart                      (int     value) { if (value < 0) { throw new System.IndexOutOfRangeException(nameof(value)); } return new( value); }
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public  readonly override int    GetHashCode                    ()              => this.value.GetHashCode();
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public  readonly          int    GetOffset                      (int length)    => this.IsFromEnd ? this.value + (length + 1) : this.value;
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public  readonly override string ToString                       ()              => this.IsFromEnd ? this.ToStringFromEnd() : ((uint) this.Value).ToString();
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] private readonly          string ToStringFromEnd                ()              => '^' + this.Value.ToString();
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] bool                             System.IEquatable<Index>.Equals(Index index)   => this.Equals(index);

      /* … */
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      public static implicit operator Index(int value) => Index.FromStart(value);
    }

    // ->> `System.Range` @ `https://web.archive.org/web/20241231015910/https://learn.microsoft.com/en-us/dotnet/api/system.range?view=net-9.0`
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.Diagnostics.DebuggerNonUserCode]
    public readonly struct Range : System.IEquatable<Range> {
      public static   Range        All            => new(System.Index.Start, System.Index.End);
      public readonly System.Index End   { get; } =  System.Index.End;
      public readonly System.Index Start { get; } =  System.Index.Start;

      /* … */
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      public Range(System.Index start, System.Index end) {
        this.End   = end;
        this.Start = start;
      }

      /* … */
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public static            Range                    EndAt                          (System.Index end)    => new(System.Index.Start, end);
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public readonly override bool                     Equals                         (object?      value)  => value is Range range && this.Equals(range);
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public readonly          bool                     Equals                         (in Range     range)  => this.End.Equals(range.End) && this.Start.Equals(range.Start);
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public readonly override int                      GetHashCode                    ()                    => System.HashCode.Combine(this.End, this.Start);
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public readonly          (int Offset, int Length) GetOffsetAndLength             (int          length) { (System.Index endIndex, System.Index startIndex) = (this.End, this.Start); (int end, int start) = (endIndex.IsFromEnd ? length - endIndex.Value : endIndex.Value, startIndex.IsFromEnd ? length - startIndex.Value : startIndex.Value); if ((uint) end > (uint) length || (uint) end < (uint) start) { throw new System.ArgumentOutOfRangeException(nameof(length)); } return (start, end - start); }
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public static            Range                    StartAt                        (System.Index start)  => new(start, System.Index.End);
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] public readonly override string?                  ToString                       ()                    => this.Start.ToString() + ".." this.End.ToString();
      [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)] bool                                              System.IEquatable<Range>.Equals(Range range)         => this.Equals(range);
    }
  }

  namespace System.Runtime.CompilerServices {
    // ->> `System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray<…>(…)` @ `https://web.archive.org/web/20250420233858/https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.runtimehelpers.getsubarray?view=net-9.0`
    public static partial class RuntimeHelpers {
      public static T[] GetSubArray<T>(T[] array, System.Range range) {
        (int offset, int length) = range.GetOffsetAndLength(array.Length);
        T[] subarray;

        // …
        if (typeof(T[]) == array.GetType()) {
          if (0 == length)
          return System.Array.Empty<T>();

          subarray = new T[length];
        } else subarray = System.Runtime.CompilerServices.Unsafe.As<T[]>(System.Array.CreateInstance(array.GetType(), length));

        System.Array.Copy(array, offset, subarray, 0, length);
        return subarray;
      }
    }
  }
#endif

/* Game */
namespace Game /* ->> Class types and delegates */ {
  namespace Collections {
    public readonly struct DeviceState : /* System.Enum, System.ValueType */ Game.Collections.IRefComparable<DeviceState>, Game.Collections.IRefEquatable<DeviceState>, System.IFormattable {
      public static readonly     DeviceState BEGIN   =  new((byte) 0u);
      public static readonly     DeviceState CURRENT =  new((byte) 1u);
      public static readonly     DeviceState END     =  new((byte) 2u);
      public static ref readonly DeviceState ENTER   => ref DeviceState.BEGIN;
      public static ref readonly DeviceState HELD    => ref DeviceState.CURRENT;
      public static readonly     DeviceState INVALID =  new(byte.MaxValue);
      public static ref readonly DeviceState LEAVE   => ref DeviceState.END;
      public static ref readonly DeviceState ONGOING => ref DeviceState.CURRENT;
      public static ref readonly DeviceState PRESS   => ref DeviceState.BEGIN;
      public static ref readonly DeviceState RELEASE => ref DeviceState.END;
      public static ref readonly DeviceState UNKNOWN => ref DeviceState.INVALID;

      public  readonly bool HasValue => !this.Equals(in DeviceState.INVALID);
      private readonly byte value; // ->> Support for `operator` `ref` returns would replace `DeviceState::value`’s entire purpose

      /* … */
      [GameMethod(AggressiveInlining)]
      private DeviceState(byte value) => this.value = value;

      [GameMethod(AggressiveInlining)] public            readonly int                      CompareTo                                                             (in DeviceState deviceState)                               => deviceState.value > this.value ? -1 : deviceState.value < this.value ? +1 : 0;
      [GameMethod(AggressiveInlining)] public            readonly bool                     Equals                                                                (in DeviceState deviceState)                               => deviceState.value == this.value; // ->> Formerly used `Util.Reference<DeviceState>.Equals(…)`
      [GameMethod(AggressiveInlining)] public   override readonly bool                     Equals                                                                (object?        value)                                     => value is DeviceState deviceState && this.Equals(deviceState);
      [GameMethod(AggressiveInlining)] internal static            uint                     GetCode                                                               (in DeviceState deviceState)                               => deviceState.value;
      [GameMethod(AggressiveInlining)] internal static            ref readonly DeviceState GetDeviceState                                                        (uint           code)                                      { switch (code) { case 0u: return ref DeviceState.BEGIN; case 1u: return ref DeviceState.CURRENT; case 2u: return ref DeviceState.END; } return ref DeviceState.INVALID; }
      [GameMethod(AggressiveInlining)] public   override readonly int                      GetHashCode                                                           ()                                                         => (int) DeviceState.GetCode(this);
      [GameMethod(AggressiveInlining)] public   override readonly string?                  ToString                                                              ()                                                         { uint index = DeviceState.GetCode(this); return $"DeviceState.{(index != byte.MaxValue ? Util.Reference<string>.At(new[] {"BEGIN", "CURRENT", "END"}, index) : "UNKNOWN")}"; }
      [GameMethod(AggressiveInlining)] readonly int                                        Game.Collections.IRefComparable<DeviceState>.CompareTo        (ref DeviceState deviceState)                              => this.CompareTo(in deviceState);
      [GameMethod(AggressiveInlining)] readonly bool                                       Game.Collections.IRefEquatable<DeviceState>.Equals            (ref DeviceState deviceState)                              => this.Equals   (in deviceState);
      [GameMethod(AggressiveInlining)] readonly int                                        Game.Collections.IRefReadOnlyComparable<DeviceState>.CompareTo(in  DeviceState deviceState)                              => this.CompareTo(in deviceState);
      [GameMethod(AggressiveInlining)] readonly bool                                       Game.Collections.IRefReadOnlyEquatable<DeviceState>.Equals    (in  DeviceState deviceState)                              => this.Equals   (in deviceState);
      [GameMethod(NoInlining)]         readonly int                                        System.IComparable.CompareTo                                          (object?         value)                                    { if (value is DeviceState deviceState) return this.CompareTo(deviceState); throw new System.NotSupportedException("Device state can not compare values"); }
      [GameMethod(AggressiveInlining)] readonly int                                        System.IComparable<DeviceState>.CompareTo                             (DeviceState     deviceState)                              => this.CompareTo(deviceState);
      [GameMethod(AggressiveInlining)] readonly bool                                       System.IEquatable<DeviceState>.Equals                                 (DeviceState     deviceState)                              => false;
      [GameMethod(AggressiveInlining)] readonly string                                     System.IFormattable.ToString                                          (string?         format, System.IFormatProvider? provider) => this.ToString()!;

      /* … */
      [GameMethod(AggressiveInlining)] public static bool        operator false(in DeviceState state)                         => !state.HasValue;
      [GameMethod(AggressiveInlining)] public static bool        operator true (in DeviceState state)                         =>  state.HasValue;
      [GameMethod(AggressiveInlining)] public static DeviceState operator +    (in DeviceState state)                         =>  DeviceState.GetDeviceState((uint) +DeviceState.GetCode(in state));
      [GameMethod(AggressiveInlining)] public static DeviceState operator -    (in DeviceState state)                         =>  DeviceState.GetDeviceState((uint) -DeviceState.GetCode(in state));
      [GameMethod(AggressiveInlining)] public static bool        operator !    (in DeviceState state)                         => !state.HasValue;
      [GameMethod(AggressiveInlining)] public static DeviceState operator ~    (in DeviceState state)                         =>  DeviceState.GetDeviceState((uint) ~DeviceState.GetCode(in state));
      [GameMethod(AggressiveInlining)] public static DeviceState operator ++   (in DeviceState state)                         =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  + 1u))                                     : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator --   (in DeviceState state)                         =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  - 1u))                                     : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator +    (in DeviceState state,  in bool        value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  +         (value ? 1u : 0u)))              : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator +    (in DeviceState state,  in ulong       value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  +         value))                          : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator +    (in DeviceState stateA, in DeviceState stateB) =>  stateA.HasValue && stateB.HasValue ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in stateA) +         DeviceState.GetCode(in stateB))) : stateA;
      [GameMethod(AggressiveInlining)] public static DeviceState operator -    (in DeviceState state,  in bool        value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  -         (value ? 1u : 0u)))              : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator -    (in DeviceState state,  in ulong       value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  -         value))                          : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator -    (in DeviceState stateA, in DeviceState stateB) =>  stateA.HasValue && stateB.HasValue ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in stateA) -         DeviceState.GetCode(in stateB))) : stateA;
      [GameMethod(AggressiveInlining)] public static DeviceState operator *    (in DeviceState state,  in bool        value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  *         (value ? 1u : 0u)))              : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator *    (in DeviceState state,  in ulong       value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  *         value))                          : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator *    (in DeviceState stateA, in DeviceState stateB) =>  stateA.HasValue && stateB.HasValue ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in stateA) *         DeviceState.GetCode(in stateB))) : stateA;
      [GameMethod(AggressiveInlining)] public static DeviceState operator /    (in DeviceState state,  in bool        value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  /         (value ? 1u : 0u)))              : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator /    (in DeviceState state,  in ulong       value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  /         value))                          : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator /    (in DeviceState stateA, in DeviceState stateB) =>  stateA.HasValue && stateB.HasValue ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in stateA) /         DeviceState.GetCode(in stateB))) : stateA;
      [GameMethod(AggressiveInlining)] public static DeviceState operator %    (in DeviceState state,  in bool        value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  %         (value ? 1u : 0u)))              : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator %    (in DeviceState state,  in ulong       value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  %         value))                          : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator %    (in DeviceState stateA, in DeviceState stateB) =>  stateA.HasValue && stateB.HasValue ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in stateA) %         DeviceState.GetCode(in stateB))) : stateA;
      [GameMethod(AggressiveInlining)] public static DeviceState operator &    (in DeviceState state,  in bool        value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  &         (value ? 1 : 0)))                : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator &    (in DeviceState state,  in ulong       value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  &   (int) value))                          : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator &    (in DeviceState stateA, in DeviceState stateB) =>  stateA.HasValue && stateB.HasValue ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in stateA) &   (int) DeviceState.GetCode(in stateB))) : stateA;
      [GameMethod(AggressiveInlining)] public static DeviceState operator |    (in DeviceState state,  in bool        value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  |         (value ? 1u : 0u)))              : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator |    (in DeviceState state,  in ulong       value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  |         value))                          : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator |    (in DeviceState stateA, in DeviceState stateB) =>  stateA.HasValue && stateB.HasValue ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in stateA) |         DeviceState.GetCode(in stateB))) : stateA;
      [GameMethod(AggressiveInlining)] public static DeviceState operator ^    (in DeviceState state,  in bool        value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  ^         (value ? 1 : 0)))                : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator ^    (in DeviceState state,  in ulong       value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  ^   (int) value))                          : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator ^    (in DeviceState stateA, in DeviceState stateB) =>  stateA.HasValue && stateB.HasValue ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in stateA) ^   (int) DeviceState.GetCode(in stateB))) : stateA;
      [GameMethod(AggressiveInlining)] public static DeviceState operator <<   (in DeviceState state,  in bool        value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  <<        (value ? 1 : 0)))                : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator <<   (in DeviceState state,  in ulong       value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  <<  (int) value))                          : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator <<   (in DeviceState stateA, in DeviceState stateB) =>  stateA.HasValue && stateB.HasValue ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in stateA) <<  (int) DeviceState.GetCode(in stateB))) : stateA;
      [GameMethod(AggressiveInlining)] public static DeviceState operator >>   (in DeviceState state,  in bool        value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  >>        (value ? 1 : 0)))                : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator >>   (in DeviceState state,  in ulong       value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  >>  (int) value))                          : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator >>   (in DeviceState stateA, in DeviceState stateB) =>  stateA.HasValue && stateB.HasValue ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in stateA) >>  (int) DeviceState.GetCode(in stateB))) : stateA;
      [GameMethod(AggressiveInlining)] public static DeviceState operator >>>  (in DeviceState state,  in bool        value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  >>>       (value ? 1 : 0)))                : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator >>>  (in DeviceState state,  in ulong       value)  =>  state .HasValue                    ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in state)  >>> (int) value))                          : state;
      [GameMethod(AggressiveInlining)] public static DeviceState operator >>>  (in DeviceState stateA, in DeviceState stateB) =>  stateA.HasValue && stateB.HasValue ? DeviceState.GetDeviceState((uint) (DeviceState.GetCode(in stateA) >>> (int) DeviceState.GetCode(in stateB))) : stateA;
      [GameMethod(AggressiveInlining)] public static bool        operator ==   (in DeviceState stateA, in DeviceState stateB) =>  stateA.Equals   (in stateB);
      [GameMethod(AggressiveInlining)] public static bool        operator !=   (in DeviceState stateA, in DeviceState stateB) => !stateA.Equals   (in stateB);
      [GameMethod(AggressiveInlining)] public static bool        operator <    (in DeviceState stateA, in DeviceState stateB) =>  stateA.CompareTo(in stateB) <  0;
      [GameMethod(AggressiveInlining)] public static bool        operator >    (in DeviceState stateA, in DeviceState stateB) =>  stateA.CompareTo(in stateB) >  0;
      [GameMethod(AggressiveInlining)] public static bool        operator <=   (in DeviceState stateA, in DeviceState stateB) =>  stateA.CompareTo(in stateB) <= 0;
      [GameMethod(AggressiveInlining)] public static bool        operator >=   (in DeviceState stateA, in DeviceState stateB) =>  stateA.CompareTo(in stateB) >= 0;

      [GameMethod(AggressiveInlining)] public static implicit operator bool(in DeviceState state) => state.HasValue;
      [GameMethod(AggressiveInlining)] public static implicit operator uint(in DeviceState state) => DeviceState.GetCode(in state);
    }

    public sealed class EventHandler<T> : Game.Collections.RefList<Game.Collections.HandlerInfo<T>>, Game.Collections.IEventHandler, Game.Collections.IRefReadOnlyEquatable<EventHandler<T>>, System.ICloneable where T : Game.Events, new() /* ->> `event` @ `https://web.archive.org/web/20220923174214/https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/event` */ {
      [GameConstructor, GameMethod(AggressiveInlining)] public  EventHandler()                                                                                       : base(1u)                                                                                 {}
      [GameConstructor, GameMethod(AggressiveInlining)] public  EventHandler(EventHandler<T> events)                                                                 : this((Game.Collections.RefList<Game.Collections.HandlerInfo<T>>) events) {}
      [GameConstructor, GameMethod(AggressiveInlining)] private EventHandler(Game.Collections.RefReadOnlyList<Game.Collections.HandlerInfo<T>> list) : base(list)                                                                               {}

      /* … ->> Keep some methods accessible for multicast queuing, “privately” inherit other `class Game.Collections.RefList` methods */
      [GameMethod(AggressiveInlining), GameResolution(0)] public   new               void                                                                                 Add                                                                   (in Game.Collections.HandlerInfo<T>                                      handler)                                                                                                                                                                                                                  { if (Game.Collections.HandlerInfo<T>.DefaultValue != handler.value) base.Add(in handler); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public   new               void                                                                                 AddRange                                                              (System.Collections.Generic.IEnumerable<Game.Collections.HandlerInfo<T>> handlers)                                                                                                                                                                                                                 { foreach (Game.Collections.HandlerInfo<T> handler in handlers)      this.Add(in handler); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public   new               void                                                                                 AddRange                                                              (in System.ReadOnlyMemory              <Game.Collections.HandlerInfo<T>> handlers)                                                                                                                                                                                                                 => this.AddRange(handlers.Span);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   new               void                                                                                 AddRange                                                              (in System.ReadOnlySpan                <Game.Collections.HandlerInfo<T>> handlers)                                                                                                                                                                                                                 { foreach (ref readonly Game.Collections.HandlerInfo<T> handler in handlers) this.Add(in handler); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public   new               ref readonly Game.Collections.HandlerInfo<T>                                 Append                                                                (in Game.Collections.HandlerInfo<T>                                      handler)                                                                                                                                                                                                                  => ref (Game.Collections.HandlerInfo<T>.DefaultValue != handler.value ? ref base.Append(in handler) : ref handler);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               EventHandler<T>                                                                      AsCopy                                                                ()                                                                                                                                                                                                                                                                                                         => new(this);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               EventHandler<T>                                                                      AsReadOnly                                                            ()                                                                                                                                                                                                                                                                                                         =>     this;
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  BinarySearch                                                          (in Game.Collections.HandlerInfo<T> handler)                                                                                                                                                                                                                                                       =>     base.BinarySearch(in handler);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               int                                                                                  BinarySearch                                                          (in Game.Collections.HandlerInfo<T> handler, Game.Collections.IRefReadOnlyComparer<Game.Collections.HandlerInfo<T>>? comparer)                                                                                                                                                     =>     base.BinarySearch(in handler, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  BinarySearch                                                          (in Game.Collections.HandlerInfo<T> handler, System.Collections.Generic.IComparer<Game.Collections.HandlerInfo<T>>?          comparer)                                                                                                                                                     =>     base.BinarySearch(in handler, comparer);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               int                                                                                  BinarySearch                                                          (uint                                       index,   uint                                                                                    length, in Game.Collections.HandlerInfo<T> handler, Game.Collections.IRefReadOnlyComparer<Game.Collections.HandlerInfo<T>>? comparer) =>     base.BinarySearch(index, length, in handler, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  BinarySearch                                                          (uint                                       index,   uint                                                                                    length, in Game.Collections.HandlerInfo<T> handler, System.Collections.Generic.IComparer         <Game.Collections.HandlerInfo<T>>? comparer) =>     base.BinarySearch(index, length, in handler, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   new               void                                                                                 Clear                                                                 ()                                                                                                                                                                                                                                                                                                         =>     base.Clear       ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public   new /* virtual */ object                                                                               Clone                                                                 ()                                                                                                                                                                                                                                                                                                         =>     base.Clone       ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public   static            void                                                                                 Combine                                                               (EventHandler                           <T>                                                                                events, in Game.Collections.HandlerInfo<T> handler)                                                                                                                     { if (Game.Collections.HandlerInfo<T>.DefaultValue != handler.value) events.Add(in handler); } // ->> Based on `𝑓 System.Delegate.Combine(…)`
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               bool                                                                                 Contains                                                              (in Game.Collections.HandlerInfo<T>                                                                                handler)                                                                                                                                                                        =>     base.Contains(in handler);
      [GameMethod(AggressiveInlining), GameResolution(0)] public                     uint                                                                                 CountInvocationList                                                   ()                                                                                                                                                                                                                                                                                                         =>     base.Count;
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               Game.Collections.RefList<U>                                                  ConvertAll<U>                                                         (Game.RefConverter              <Game.Collections.HandlerInfo<T>, U>                                       converter) where U : Game.Events, new()                                                                                                                                 =>     base.ConvertAll(converter);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               Game.Collections.RefList<U>                                                  ConvertAll<U>                                                         (Game.RefReadOnlyConverter      <Game.Collections.HandlerInfo<T>, U>                                       converter) where U : Game.Events, new()                                                                                                                                 =>     base.ConvertAll(converter);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               Game.Collections.RefList<U>                                                  ConvertAll<U>                                                         (System.Converter                       <Game.Collections.HandlerInfo<T>, U>                                       converter) where U : Game.Events, new()                                                                                                                                 =>     base.ConvertAll(converter);
      [GameMethod(AggressiveInlining), GameResolution(2)] private                    EventHandler<U>                                                                      ConvertAll<U>                                                         (Game.RefConverter              <Game.Collections.HandlerInfo<T>, Game.Collections.HandlerInfo<U>> converter) where U : Game.Events, new()                                                                                                                                 => new(base.ConvertAll(converter));
      [GameMethod(AggressiveInlining), GameResolution(1)] private                    EventHandler<U>                                                                      ConvertAll<U>                                                         (Game.RefReadOnlyConverter      <Game.Collections.HandlerInfo<T>, Game.Collections.HandlerInfo<U>> converter) where U : Game.Events, new()                                                                                                                                 => new(base.ConvertAll(converter));
      [GameMethod(AggressiveInlining), GameResolution(0)] private                    EventHandler<U>                                                                      ConvertAll<U>                                                         (System.Converter                       <Game.Collections.HandlerInfo<T>, Game.Collections.HandlerInfo<U>> converter) where U : Game.Events, new()                                                                                                                                 => new(base.ConvertAll(converter));
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               void                                                                                 CopyTo                                                                (Game.Collections.HandlerInfo<T>[]                                                                                 array)                                                                                                                                                                          =>     base.CopyTo    (array);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               void                                                                                 CopyTo                                                                (Game.Collections.HandlerInfo<T>[]                                                                                 array, int                                       index)                                                                                                                         =>     base.CopyTo    (array, index); // ->> Strictly for `struct Util.Array<T>.Copyable` to work with
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               void                                                                                 CopyTo                                                                (Game.Collections.HandlerInfo<T>[]                                                                                 array, uint                                      index)                                                                                                                         =>     base.CopyTo    (array, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               void                                                                                 CopyTo                                                                (uint                                                                                                                      index, Game.Collections.HandlerInfo<T>[] array, uint arrayIndex, uint length)                                                                                           =>     base.CopyTo    (index, array, arrayIndex, length);
      [GameMethod(AggressiveInlining), GameResolution(0)] public                     void                                                                                 DynamicInvoke                                                         (params object?[]?                                                                                                         arguments)                                                                                                                                                                      { using (Game.Collections.RefList<Game.Collections.HandlerInfo<T>>.Enumerator enumerator = this.GetEnumerator()) while (enumerator.MoveNext()) enumerator.Current.DynamicInvoke(); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public                     bool                                                                                 Equals                                                                (in EventHandler<T>                                                                                                        events)                                                                                                                                                                         =>     base.Equals       ((Game.Collections.RefList<Game.Collections.HandlerInfo<T>>) events);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   override          bool                                                                                 Equals                                                                (object?                                                                                                                   value)                                                                                                                                                                          =>     base.Equals       (value);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               bool                                                                                 Exists                                                                (Game.RefPredicate        <Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      =>     base.Exists       (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               bool                                                                                 Exists                                                                (Game.RefReadOnlyPredicate<Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      =>     base.Exists       (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               bool                                                                                 Exists                                                                (System.Predicate                 <Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      =>     base.Exists       (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               ref Game.Collections.HandlerInfo<T>                                          Find                                                                  (Game.RefPredicate        <Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      => ref base.Find         (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               ref Game.Collections.HandlerInfo<T>                                          Find                                                                  (Game.RefReadOnlyPredicate<Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      => ref base.Find         (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               ref Game.Collections.HandlerInfo<T>                                          Find                                                                  (System.Predicate                 <Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      => ref base.Find         (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               EventHandler<T>                                                                      FindAll                                                               (Game.RefPredicate        <Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      => new(base.FindAll      (predicate));
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               EventHandler<T>                                                                      FindAll                                                               (Game.RefReadOnlyPredicate<Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      => new(base.FindAll      (predicate));
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               EventHandler<T>                                                                      FindAll                                                               (System.Predicate                 <Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      => new(base.FindAll      (predicate));
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               int                                                                                  FindIndex                                                             (Game.RefPredicate        <Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      =>     base.FindIndex    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               int                                                                                  FindIndex                                                             (Game.RefReadOnlyPredicate<Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      =>     base.FindIndex    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  FindIndex                                                             (System.Predicate                 <Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      =>     base.FindIndex    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               int                                                                                  FindIndex                                                             (uint                                                                                                                      index,              Game.RefPredicate        <Game.Collections.HandlerInfo<T>> predicate)                                                                       =>     base.FindIndex    (index,         predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               int                                                                                  FindIndex                                                             (uint                                                                                                                      index,              Game.RefReadOnlyPredicate<Game.Collections.HandlerInfo<T>> predicate)                                                                       =>     base.FindIndex    (index,         predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  FindIndex                                                             (uint                                                                                                                      index,              System.Predicate                 <Game.Collections.HandlerInfo<T>> predicate)                                                                       =>     base.FindIndex    (index,         predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               int                                                                                  FindIndex                                                             (uint                                                                                                                      index, uint length, Game.RefPredicate        <Game.Collections.HandlerInfo<T>> predicate)                                                                       =>     base.FindIndex    (index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               int                                                                                  FindIndex                                                             (uint                                                                                                                      index, uint length, Game.RefReadOnlyPredicate<Game.Collections.HandlerInfo<T>> predicate)                                                                       =>     base.FindIndex    (index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  FindIndex                                                             (uint                                                                                                                      index, uint length, System.Predicate                 <Game.Collections.HandlerInfo<T>> predicate)                                                                       =>     base.FindIndex    (index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               ref Game.Collections.HandlerInfo<T>                                          FindLast                                                              (Game.RefPredicate        <Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      => ref base.FindLast     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               ref Game.Collections.HandlerInfo<T>                                          FindLast                                                              (Game.RefReadOnlyPredicate<Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      => ref base.FindLast     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               ref Game.Collections.HandlerInfo<T>                                          FindLast                                                              (System.Predicate                 <Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      => ref base.FindLast     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               int                                                                                  FindLastIndex                                                         (Game.RefPredicate        <Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      =>     base.FindLastIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               int                                                                                  FindLastIndex                                                         (Game.RefReadOnlyPredicate<Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      =>     base.FindLastIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  FindLastIndex                                                         (System.Predicate                 <Game.Collections.HandlerInfo<T>>                                                predicate)                                                                                                                                                                      =>     base.FindLastIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               int                                                                                  FindLastIndex                                                         (uint                                                                                                                      index,              Game.RefPredicate        <Game.Collections.HandlerInfo<T>> predicate)                                                                       =>     base.FindLastIndex(index,         predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               int                                                                                  FindLastIndex                                                         (uint                                                                                                                      index,              Game.RefReadOnlyPredicate<Game.Collections.HandlerInfo<T>> predicate)                                                                       =>     base.FindLastIndex(index,         predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  FindLastIndex                                                         (uint                                                                                                                      index,              System.Predicate                 <Game.Collections.HandlerInfo<T>> predicate)                                                                       =>     base.FindLastIndex(index,         predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               int                                                                                  FindLastIndex                                                         (uint                                                                                                                      index, uint length, Game.RefPredicate        <Game.Collections.HandlerInfo<T>> predicate)                                                                       =>     base.FindLastIndex(index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               int                                                                                  FindLastIndex                                                         (uint                                                                                                                      index, uint length, Game.RefReadOnlyPredicate<Game.Collections.HandlerInfo<T>> predicate)                                                                       =>     base.FindLastIndex(index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  FindLastIndex                                                         (uint                                                                                                                      index, uint length, System.Predicate                 <Game.Collections.HandlerInfo<T>> predicate)                                                                       =>     base.FindLastIndex(index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               void                                                                                 ForEach                                                               (Game.RefAction        <Game.Collections.HandlerInfo<T>>                                                   action)                                                                                                                                                                         =>     base.ForEach      (action);
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               void                                                                                 ForEach                                                               (Game.RefReadOnlyAction<Game.Collections.HandlerInfo<T>>                                                   action)                                                                                                                                                                         =>     base.ForEach      (action);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               void                                                                                 ForEach                                                               (System.Action                 <Game.Collections.HandlerInfo<T>>                                                   action)                                                                                                                                                                         =>     base.ForEach      (action);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               Game.Collections.RefList<Game.Collections.HandlerInfo<T>>.Enumerator GetEnumerator                                                         ()                                                                                                                                                                                                                                                                                                         =>     base.GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)] public   override          int                                                                                  GetHashCode                                                           ()                                                                                                                                                                                                                                                                                                         =>     base.GetHashCode  ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public   /* virtual */     System.Delegate[]                                                                    GetInvocationList                                                     ()                                                                                                                                                                                                                                                                                                         =>     base.ConvertAll([GameMethod(AggressiveInlining)] static (in Game.Collections.HandlerInfo<T> handler) => (System.Delegate) handler.Invoke).Items; // ->> `Util.Array<Game.Collections.RefReadOnlyList<System.Delegate>>.From(…)`
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               EventHandler<T>                                                                      GetRange                                                              (uint                                       index, uint length)                                                                                                                                                                                                                                            => new(base.GetRange(index, length));
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  IndexOf                                                               (in Game.Collections.HandlerInfo<T> handler)                                                                                                                                                                                                                                                       =>     base.IndexOf (in handler);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  IndexOf                                                               (in Game.Collections.HandlerInfo<T> handler, uint                                                                            index)                                                                                                                                                                =>     base.IndexOf (in handler, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  IndexOf                                                               (in Game.Collections.HandlerInfo<T> handler, uint                                                                            index, uint length)                                                                                                                                                   =>     base.IndexOf (in handler, index, length);
      [GameMethod(AggressiveInlining), GameResolution(0)] internal new               void                                                                                 Insert                                                                (uint                                       index,   in Game.Collections.HandlerInfo<T>                                      handler)                                                                                                                                                              { if (Game.Collections.HandlerInfo<T>.DefaultValue != handler.value) base.Insert(index, in handler); }
      [GameMethod(AggressiveInlining), GameResolution(0)] internal new               void                                                                                 InsertRange                                                           (uint                                       index,   System.Collections.Generic.IEnumerable<Game.Collections.HandlerInfo<T>> handlers)                                                                                                                                                             { foreach (Game.Collections.HandlerInfo<T> handler in handlers) { if (Game.Collections.HandlerInfo<T>.DefaultValue != handler.value) this.Insert(index++, in handler); } }
      [GameMethod(AggressiveInlining), GameResolution(0)] internal new               void                                                                                 InsertRange                                                           (uint                                       index,   in System.ReadOnlyMemory              <Game.Collections.HandlerInfo<T>> handlers)                                                                                                                                                             => this.InsertRange(index, handlers.Span);
      [GameMethod(AggressiveInlining), GameResolution(0)] internal new               void                                                                                 InsertRange                                                           (uint                                       index,   in System.ReadOnlySpan                <Game.Collections.HandlerInfo<T>> handlers)                                                                                                                                                             { foreach (ref readonly Game.Collections.HandlerInfo<T> handler in handlers) { if (Game.Collections.HandlerInfo<T>.DefaultValue != handler.value) this.Insert(index++, in handler); } }
      [GameMethod(AggressiveInlining), GameResolution(0)] public                     void                                                                                 Invoke                                                                ()                                                                                                                                                                                                                                                                                                         { using (Game.Collections.RefList<Game.Collections.HandlerInfo<T>>.Enumerator enumerator = this.GetEnumerator()) while (enumerator.MoveNext()) enumerator.Current.Invoke(); }
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  LastIndexOf                                                           (in Game.Collections.HandlerInfo<T>                                       handler)                                                                                                                                                                                                                 => base.LastIndexOf(in handler);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  LastIndexOf                                                           (in Game.Collections.HandlerInfo<T>                                       handler, uint index)                                                                                                                                                                                                     => base.LastIndexOf(in handler, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               int                                                                                  LastIndexOf                                                           (in Game.Collections.HandlerInfo<T>                                       handler, uint index, uint length)                                                                                                                                                                                        => base.LastIndexOf(in handler, index, length);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   new               ref readonly Game.Collections.HandlerInfo<T>                                 Prepend                                                               (in Game.Collections.HandlerInfo<T>                                       handler)                                                                                                                                                                                                                 => ref (Game.Collections.HandlerInfo<T>.DefaultValue != handler.value ? ref base.Prepend(in handler) : ref handler);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               ref          Game.Collections.HandlerInfo<T>                                 Random                                                                ()                                                                                                                                                                                                                                                                                                         => ref base.Random();
      [GameMethod(AggressiveInlining), GameResolution(0)] public   new               bool                                                                                 Remove                                                                (in Game.Collections.HandlerInfo<T>                                       handler)                                                                                                                                                                                                                 =>     base.Remove(in handler);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   static            void                                                                                 Remove                                                                (EventHandler                           <T>                                       events, in Game.Collections.HandlerInfo<T> handler)                                                                                                                                                              { for (uint index = events.Count; 0u != index--; ) if (events[index].value == handler.value) { events.RemoveAt(index); return; } } // ->> Based on `𝑓 System.Delegate.Remove(…)`
      [GameMethod(AggressiveInlining), GameResolution(1)] public   new               uint                                                                                 RemoveAll                                                             (Game.RefPredicate              <Game.Collections.HandlerInfo<T>> predicate)                                                                                                                                                                                                               => base.RemoveAll  (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   new               uint                                                                                 RemoveAll                                                             (Game.RefReadOnlyPredicate      <Game.Collections.HandlerInfo<T>> predicate)                                                                                                                                                                                                               => base.RemoveAll  (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   new               uint                                                                                 RemoveAll                                                             (System.Predicate                       <Game.Collections.HandlerInfo<T>> predicate)                                                                                                                                                                                                               => base.RemoveAll  (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   new               void                                                                                 RemoveAt                                                              (uint                                                                             index)                                                                                                                                                                                                                   => base.RemoveAt   (index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   new               void                                                                                 RemoveRange                                                           (uint                                                                             index, uint length)                                                                                                                                                                                                      => base.RemoveRange(index, length);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               void                                                                                 Reverse                                                               ()                                                                                                                                                                                                                                                                                                         => base.Reverse    ();
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               void                                                                                 Reverse                                                               (uint index, uint length)                                                                                                                                                                                                                                                                                  => base.Reverse    (index, length);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               void                                                                                 Sort                                                                  ()                                                                                                                                                                                                                                                                                                         => base.Sort       ();
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               void                                                                                 Sort                                                                  (Game.RefComparison          <Game.Collections.HandlerInfo<T>>? comparison)                                                                                                                                                                                                                => base.Sort       (comparison);
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               void                                                                                 Sort                                                                  (Game.RefReadOnlyComparison  <Game.Collections.HandlerInfo<T>>? comparison)                                                                                                                                                                                                                => base.Sort       (comparison);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               void                                                                                 Sort                                                                  (System.Collections.Generic.IComparer<Game.Collections.HandlerInfo<T>>? comparer)                                                                                                                                                                                                                  => base.Sort       (comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               void                                                                                 Sort                                                                  (System.Comparison                   <Game.Collections.HandlerInfo<T>>? comparison)                                                                                                                                                                                                                => base.Sort       (comparison);
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               void                                                                                 Sort                                                                  (uint                                                                           index, uint length, Game.Collections.IRefComparer        <Game.Collections.HandlerInfo<T>>? comparer)                                                                                                      => base.Sort       (index, length, comparer);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               void                                                                                 Sort                                                                  (uint                                                                           index, uint length, Game.Collections.IRefReadOnlyComparer<Game.Collections.HandlerInfo<T>>? comparer)                                                                                                      => base.Sort       (index, length, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               void                                                                                 Sort                                                                  (uint                                                                           index, uint length, System.Collections.Generic.IComparer         <Game.Collections.HandlerInfo<T>>? comparer)                                                                                                      => base.Sort       (index, length, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               Game.Collections.HandlerInfo<T>[]                                            ToArray                                                               ()                                                                                                                                                                                                                                                                                                         => base.ToArray    ();
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               void                                                                                 TrimExcess                                                            ()                                                                                                                                                                                                                                                                                                         => base.TrimExcess ();
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               void                                                                                 TrimExcess                                                            (uint                                                                             capacity)                                                                                                                                                                                                                => base.TrimExcess (capacity);
      [GameMethod(AggressiveInlining), GameResolution(1)] private  new               bool                                                                                 TrueForAll                                                            (Game.RefPredicate              <Game.Collections.HandlerInfo<T>> predicate)                                                                                                                                                                                                               => base.TrueForAll (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] private  new               bool                                                                                 TrueForAll                                                            (Game.RefReadOnlyPredicate      <Game.Collections.HandlerInfo<T>> predicate)                                                                                                                                                                                                               => base.TrueForAll (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               bool                                                                                 TrueForAll                                                            (System.Predicate                       <Game.Collections.HandlerInfo<T>> predicate)                                                                                                                                                                                                               => base.TrueForAll (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               bool                                                                                 TryAdd                                                                (in Game.Collections.HandlerInfo<T>                                       handler)                                                                                                                                                                                                                 { if (!base.Contains(in handler)) { this.Add(in handler); return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(0)] private  new               ref readonly Game.Collections.HandlerInfo<T>                                 TryAppend                                                             (in Game.Collections.HandlerInfo<T>                                       handler)                                                                                                                                                                                                                 { int index = base.IndexOf(in handler); return ref (index == -1 ? ref this.Append(in handler) : ref base.GetValue((uint) index)); }
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                                                                            Game.Collections.IRefReadOnlyEquatable<EventHandler<T>>.Equals(in EventHandler                        <T>                                       events)                                                                                                                                                                                                                  => this.Equals     (in events);
      [GameMethod(AggressiveInlining), GameResolution(0)] object                                                                                                          System.ICloneable.Clone                                               ()                                                                                                                                                                                                                                                                                                         => base.Clone      ();
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                                                                            System.IEquatable<EventHandler<T>>.Equals                             (EventHandler<T> events)                                                                                                                                                                                                                                                                                   => this.Equals     (events);

      /* … */
      [GameMethod(AggressiveInlining), GameResolution(0)] public static EventHandler<T> operator +(EventHandler<T> events, in Game.Collections.HandlerInfo<T> handler) { EventHandler<T>.Combine(events, in handler); return events; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static EventHandler<T> operator -(EventHandler<T> events, in Game.Collections.HandlerInfo<T> handler) { EventHandler<T>.Remove (events, in handler); return events; }

      [GameMethod(AggressiveInlining), GameResolution(0)]
      public static implicit operator System.Delegate(in EventHandler<T> events) => events.Invoke;
    }

    public class GameObjectIterator : Game.Collections.IRefEquatable<GameObjectIterator>, /* ->> Ranged `foreach …` shorthand support */ System.Collections.Generic.IEnumerable<UnityEngine.GameObject>, System.Collections.Generic.IEnumerator<UnityEngine.GameObject> {
      private enum HierarchyCurrent : sbyte { Unmoved = -1, Pending,     Moved };
      public  enum Kind             : byte  { Children,     Descendants, Hierarchy };

      public                 UnityEngine.GameObject                                  Current                                                                => (GameObjectIterator.HierarchyCurrent.Pending == this.uproot ? this.root : (UnityEngine.Transform) this.subenumerator.Current).gameObject;
      private readonly       GameObjectIterator.Kind                                 kind                                                                   =  default;
      private readonly       System.Collections.Generic.Queue<UnityEngine.Transform> hierarchy                                                              =  new();
      private readonly       UnityEngine.Transform                                   root                                                                   =  null!;
      private /* required */ System.Collections.IEnumerator                          subenumerator                                                          =  null!;
      private /* required */ GameObjectIterator.HierarchyCurrent                     uproot                                                                 =  GameObjectIterator.HierarchyCurrent.Unmoved;
      UnityEngine.GameObject                                                         System.Collections.Generic.IEnumerator<UnityEngine.GameObject>.Current => this.Current;
      object                                                                         System.Collections.IEnumerator.Current                                 => this.Current!;

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)]
      internal GameObjectIterator(GameObjectIterator.Kind kind, UnityEngine.Transform gameObjectTransform) {
        this.kind          = kind;
        this.root          = gameObjectTransform;
        this.subenumerator = gameObjectTransform.GetEnumerator();

        switch (this.kind) {
          case GameObjectIterator.Kind.Children   :                                                                                                                  break;
          case GameObjectIterator.Kind.Descendants: this.hierarchy = new(gameObjectTransform.childCount);                                                            break;
          case GameObjectIterator.Kind.Hierarchy  : this.hierarchy = new(gameObjectTransform.childCount); this.uproot = GameObjectIterator.HierarchyCurrent.Unmoved; break;
        }
      }

      /* … */
      [GameMethod(AggressiveInlining)] public void               Dispose      ()                                 { /* Do nothing… */ }
      [GameMethod(AggressiveInlining)] public bool               Equals       (in GameObjectIterator enumerator) => false;
      [GameMethod(AggressiveInlining)] public GameObjectIterator GetEnumerator()                                 => this;

      public bool MoveNext() {
        switch (kind) {
          case GameObjectIterator.Kind.Children:
            return this.subenumerator.MoveNext();

          case GameObjectIterator.Kind.Descendants:
            if (this.subenumerator.MoveNext()) {
              this.hierarchy.Enqueue((UnityEngine.Transform) this.subenumerator.Current);
              return true;
            }

            do {
              if (this.hierarchy.IsEmpty())
              return false;

              this.subenumerator = this.hierarchy.Dequeue().GetEnumerator();
            } while (!this.subenumerator.MoveNext()); // ->> Move `System.Collections.IEnumerator` to first enumerable item — if existing

            return true;

          case GameObjectIterator.Kind.Hierarchy:
            switch (this.uproot) {
              case GameObjectIterator.HierarchyCurrent.Moved  :                                                            break;
              case GameObjectIterator.HierarchyCurrent.Pending: this.uproot = GameObjectIterator.HierarchyCurrent.Moved;   break;
              case GameObjectIterator.HierarchyCurrent.Unmoved: this.uproot = GameObjectIterator.HierarchyCurrent.Pending; return true;
            }

            goto case GameObjectIterator.Kind.Descendants;
        }

        return false;
      }

      [GameMethod(AggressiveInlining)]
      public void Reset() {
        this.hierarchy.Clear();
        this.subenumerator = this.root.GetEnumerator(); // ->> `System.Collections.IEnumerator::Reset()` unneeded
        this.uproot        = GameObjectIterator.HierarchyCurrent.Unmoved;
      }

      [GameMethod(AggressiveInlining)] bool                                                           Game.Collections.IRefEquatable<GameObjectIterator>.Equals           (ref GameObjectIterator enumerator) => this.Equals       (in enumerator);
      [GameMethod(AggressiveInlining)] bool                                                           Game.Collections.IRefReadOnlyEquatable<GameObjectIterator>.Equals   (in  GameObjectIterator enumerator) => this.Equals       (in enumerator);
      [GameMethod(AggressiveInlining)] System.Collections.Generic.IEnumerator<UnityEngine.GameObject> System.Collections.Generic.IEnumerable<UnityEngine.GameObject>.GetEnumerator()                                  => this.GetEnumerator();
      [GameMethod(AggressiveInlining)] System.Collections.IEnumerator                                 System.Collections.IEnumerable.GetEnumerator                                ()                                  => this.GetEnumerator();
      [GameMethod(AggressiveInlining)] bool                                                           System.Collections.IEnumerator.MoveNext                                     ()                                  => this.MoveNext     ();
      [GameMethod(AggressiveInlining)] void                                                           System.Collections.IEnumerator.Reset                                        ()                                  => this.Reset        ();
      [GameMethod(AggressiveInlining)] void                                                           System.IDisposable.Dispose                                                  ()                                  => this.Dispose      ();
      [GameMethod(AggressiveInlining)] bool                                                           System.IEquatable<GameObjectIterator>.Equals                                (GameObjectIterator enumerator)     => this.Equals       (enumerator);
    }

    public /* readonly */ struct HandlerInfo<T> : Game.Collections.IHandlerInfo, Game.Collections.IRefReadOnlyEquatable<HandlerInfo<T>> where T : Game.Events, new() /* ->> Based on `System.MulticastDelegate` */ {
      internal readonly       Game.Handler<T> value                                          =  HandlerInfo<T>.DefaultValue; // ->> Callback function(s)
      internal readonly       object?                 target                                         =  null;                        // ->> Callback source
      internal /* readonly */ T                       metadata                                       =  default!;                    // ->> Callback event data
      readonly object                                 Game.Collections.IHandlerInfo.metadata => this.metadata!;
      readonly object?                                Game.Collections.IHandlerInfo.target   => this.target;

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)] public HandlerInfo(in HandlerInfo<T>       handler) : this(handler.value, handler.target, handler.metadata) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public HandlerInfo(Game.Handler<T> value, object? target, in T metadata)                            { this.metadata = metadata; this.target = target; this.value = value ?? this.value; }

      /* … */
      [GameMethod(AggressiveInlining)] internal /* virtual */ readonly object            Clone                                                                ()                                    => new HandlerInfo<T>((Game.Handler<T>) this.value.Clone(), this.target, this.metadata);
      [GameMethod(NoInlining)]         internal static                 void              DefaultValue                                                         (object?           target, in T data) {}
      [GameMethod(AggressiveInlining)] internal               readonly void              DynamicInvoke                                                        (params object?[]? arguments)         => this.value.DynamicInvoke(new object?[] {this.target, this.metadata});
      [GameMethod(AggressiveInlining)] public                 readonly bool              Equals                                                               (in HandlerInfo<T> handler)           => handler.target == this.target && handler.value == this.value && System.Collections.Generic.EqualityComparer<T>.Default.Equals(this.metadata, handler.metadata);
      [GameMethod(AggressiveInlining)] public   override      readonly bool              Equals                                                               (object?           value)             => value is not null && value switch { HandlerInfo<T> handler => this.Equals(handler), _ => this.GetHashCode() == value!.GetHashCode() };
      [GameMethod(AggressiveInlining)] public   override      readonly int               GetHashCode                                                          ()                                    => System.HashCode.Combine(this.metadata, this.target, this.value);
      [GameMethod(AggressiveInlining)] internal /* virtual */ readonly System.Delegate[] GetInvocationList                                                    ()                                    => this.value.GetInvocationList();
      [GameMethod(AggressiveInlining)] internal               readonly void              Invoke                                                               ()                                    => this.value.Invoke(this.target, in this.metadata);
      [GameMethod(AggressiveInlining)] public   override      readonly string?           ToString                                                             ()                                    => $"[[{this.target}] {this.metadata}]";
      [GameMethod(AggressiveInlining)] readonly bool                                     Game.Collections.IRefReadOnlyEquatable<HandlerInfo<T>>.Equals(in HandlerInfo<T> handler)           => this.Equals(in handler);
      [GameMethod(AggressiveInlining)] readonly bool                                     System.IEquatable<HandlerInfo<T>>.Equals                             (HandlerInfo   <T> handler)           => this.Equals(handler);

      /* … */
      [GameMethod(AggressiveInlining)]
      public static implicit operator Game.Handler<T>(in HandlerInfo<T> handler) => handler.value;
    }

    public interface IEventHandler {}

    public interface IHandlerInfo {
      internal abstract object  metadata { get; }
      internal abstract object? target   { get; }
    }

    public interface IKeyValuePair {
      public abstract object  Key   { get; }
      public abstract object? Value { get; }
    }

    public interface IMono : Game.Collections.IRefEquatable<IMono> {
      public abstract bool    HasValue { get; }
      public abstract object? Value    { get; }
    }

    internal struct IndexFor<T> : Game.Collections.IRefComparable<IndexFor<T>>, Game.Collections.IRefEquatable<IndexFor<T>>, System.IConvertible, System.IFormattable {
      internal uint value;

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)]
      public IndexFor(uint value = default) => this.value = value;

      /* … */
      [GameMethod(AggressiveInlining)] public static            ulong                                         BigMul                                                                (in IndexFor<T> indexA, in IndexFor<T> indexB)                                                                                                                                 => (ulong) System.Math.BigMul((int) indexA.value, (int) indexB.value);
      [GameMethod(AggressiveInlining)] public static            IndexFor<T>                                   Clamp                                                                 (in IndexFor<T> index,  in IndexFor<T> minimum, in IndexFor<T> maximum)                                                                                                        => new    (System.Math.Clamp (index.value, minimum.value, maximum.value));
      [GameMethod(AggressiveInlining)] public          readonly int                                           CompareTo                                                             (in IndexFor<T> index)                                                                                                                                                         => this.value.CompareTo(index.value);
      [GameMethod(AggressiveInlining)] public          readonly int                                           CompareTo                                                             (object?        value)                                                                                                                                                         => this.value.CompareTo(value);
      [GameMethod(AggressiveInlining)] public static            (IndexFor<T> Quotient, IndexFor<T> Remainder) DivRem                                                                (in IndexFor<T> indexA, in IndexFor<T> indexB)                                                                                                                                 { long quotient = System.Math.DivRem((long) indexA.value, (long) indexB.value, out long remainder); return (new((uint) quotient), new((uint) remainder)); }
      [GameMethod(AggressiveInlining)] public          readonly bool                                          Equals                                                                (in IndexFor<T> index)                                                                                                                                                         => this.value.Equals     (index.value);
      [GameMethod(AggressiveInlining)] public override readonly bool                                          Equals                                                                (object?        value)                                                                                                                                                         => this.value.Equals     (value);
      [GameMethod(AggressiveInlining)] public override readonly int                                           GetHashCode                                                           ()                                                                                                                                                                             => this.value.GetHashCode();
      [GameMethod(AggressiveInlining)] public          readonly System.TypeCode                               GetTypeCode                                                           ()                                                                                                                                                                             => System.Type.GetTypeCode(typeof(IndexFor<T>));
      [GameMethod(AggressiveInlining)] public static            bool                                          IsEvenInteger                                                         (in IndexFor<T>               index)                                                                                                                                           => 0 == (index.value & 1);
      [GameMethod(AggressiveInlining)] public static            bool                                          IsOddInteger                                                          (in IndexFor<T>               index)                                                                                                                                           => 1 == (index.value & 1);
      [GameMethod(AggressiveInlining)] public static            bool                                          IsPow2                                                                (in IndexFor<T>               index)                                                                                                                                           { IndexFor<T> logarithm = IndexFor<T>.Log2(index); uint exponent = 0u; while (0u != logarithm.value--) { exponent = 0u != exponent ? exponent << 1 : 2u; } return exponent == index.value; }
      [GameMethod(AggressiveInlining)] public static            byte                                          LeadingZeroCount                                                      (in IndexFor<T>               index)                                                                                                                                           { byte n = 32; uint x = index.value, y; y = x >>> 16; if (0u != y) { n -= 16; x = y; } y = x >>> 8; if (0u != y) { n -= 8; x = y; } y = x >>> 4; if (0u != y) { n -= 4; x = y; } y = x >>> 2; if (0u != y) { n -= 2; x = y; } y = x >>> 1; if (0u != y) { return (byte) (n - 2u); } return (byte) (n - x); }
      [GameMethod(AggressiveInlining)] public static            IndexFor<T>                                   Log2                                                                  (in IndexFor<T>               index)                                                                                                                                           { uint logarithm = 0u; for (uint exponent = index.value; 0u != exponent; exponent >>>= 1) { ++logarithm; } return new(logarithm); }
      [GameMethod(AggressiveInlining)] public static            ref readonly IndexFor<T>                      Max                                                                   (in IndexFor<T>               indexA, in IndexFor<T> indexB)                                                                                                                   => ref (indexB.value > indexA.value ? ref indexB : ref indexA);
      [GameMethod(AggressiveInlining)] public static            ref readonly IndexFor<T>                      Min                                                                   (in IndexFor<T>               indexA, in IndexFor<T> indexB)                                                                                                                   => ref (indexB.value < indexA.value ? ref indexB : ref indexA);
      [GameMethod(AggressiveInlining)] public static            IndexFor<T>                                   Parse                                                                 (string                       text)                                                                                                                                            => new((uint) long.Parse(text));
      [GameMethod(AggressiveInlining)] public static            IndexFor<T>                                   Parse                                                                 (string                       text,       System.Globalization.NumberStyles style)                                                                                             => new((uint) long.Parse(text, style));
      [GameMethod(AggressiveInlining)] public static            IndexFor<T>                                   Parse                                                                 (string                       text,       System.IFormatProvider?           provider)                                                                                          => new((uint) long.Parse(text, provider));
      [GameMethod(AggressiveInlining)] public static            IndexFor<T>                                   Parse                                                                 (in System.ReadOnlySpan<byte> bytes,      System.IFormatProvider?           provider)                                                                                          => new       (uint.Parse(System.Runtime.InteropServices.MemoryMarshal.Cast<byte, char>(bytes), System.Globalization.NumberStyles.Integer, provider));
      [GameMethod(AggressiveInlining)] public static            IndexFor<T>                                   Parse                                                                 (in System.ReadOnlySpan<char> characters, System.IFormatProvider?           provider)                                                                                          => new       (uint.Parse(characters,                                                           System.Globalization.NumberStyles.Integer, provider));
      [GameMethod(AggressiveInlining)] public static            IndexFor<T>                                   Parse                                                                 (string                       text,       System.Globalization.NumberStyles style,                                             System.IFormatProvider? provider)               => new((uint) long.Parse(text,                                                                 style,                                     provider));
      [GameMethod(AggressiveInlining)] public static            IndexFor<T>                                   Parse                                                                 (in System.ReadOnlySpan<byte> bytes,      System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, System.IFormatProvider? provider = null)        => new(       uint.Parse(System.Runtime.InteropServices.MemoryMarshal.Cast<byte, char>(bytes), style,                                     provider));
      [GameMethod(AggressiveInlining)] public static            IndexFor<T>                                   Parse                                                                 (in System.ReadOnlySpan<char> characters, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, System.IFormatProvider? provider = null)        => new       (uint.Parse(characters,                                                           style,                                     provider));
      [GameMethod(AggressiveInlining)] public static            byte                                          PopCount                                                              (in IndexFor           <T>    index)                                                                                                                                           { byte count = 0; for (uint value = index.value; 0u != value; value >>>= 1) { if (0 != (value & 1)) ++count; } return count; }
      [GameMethod(AggressiveInlining)] public static            IndexFor<T>                                   RotateLeft                                                            (in IndexFor           <T>    index, uint count)                                                                                                                               => (index.value <<  (int) count) | (index.value >>> (int) (32u - count));
      [GameMethod(AggressiveInlining)] public static            IndexFor<T>                                   RotateRight                                                           (in IndexFor           <T>    index, uint count)                                                                                                                               => (index.value >>> (int) count) | (index.value <<  (int) (32u - count));
      [GameMethod(AggressiveInlining)] public static            int                                           Sign                                                                  (in IndexFor           <T>    index)                                                                                                                                           => 0u == index.value ? 0 : 1;
      [GameMethod(AggressiveInlining)] public override readonly string?                                       ToString                                                              ()                                                                                                                                                                             => this.value.ToString();
      [GameMethod(AggressiveInlining)] public          readonly string                                        ToString                                                              (string?                      format)                                                                                                                                          => this.value.ToString(format);
      [GameMethod(AggressiveInlining)] public          readonly string                                        ToString                                                              (System.IFormatProvider?      provider)                                                                                                                                        => this.value.ToString(provider);
      [GameMethod(AggressiveInlining)] public          readonly string                                        ToString                                                              (string?                      format, System.IFormatProvider? provider)                                                                                                        => this.value.ToString(format, provider);
      [GameMethod(AggressiveInlining)] public static            byte                                          TrailingZeroCount                                                     (in IndexFor   <T>            index)                                                                                                                                           { byte n = 31; uint x = index.value, y; if (0u == x) return 32; y = x << 16; if (0u != y) { n -= 16; x = y; } y = x << 8; if (0u != y) { n -= 8; x = y; } y = x << 4; if (0u != y) { n -= 4; x = y; } y = x << 2; if (0u != y) { n -= 2; x = y; } return (byte) (n - ((x << 1) >>> 31)); }
      [GameMethod(AggressiveInlining)] public          readonly bool                                          TryFormat                                                             (in System.Span<byte>         bytes,       out uint                          count, in System.ReadOnlySpan<char> format = default, System.IFormatProvider? provider = default) { bool formatted = this.value.TryFormat(System.Runtime.InteropServices.MemoryMarshal.Cast<byte, char>(bytes), out int subcount, format, provider);                               count  = (uint) subcount;       return formatted; }
      [GameMethod(AggressiveInlining)] public          readonly bool                                          TryFormat                                                             (in System.Span<char>         characters,  out uint                          count, in System.ReadOnlySpan<char> format = default, System.IFormatProvider? provider = default) { bool formatted = this.value.TryFormat(characters,                                                           out int subcount, format, provider);                               count  = (uint) subcount;       return formatted; }
      [GameMethod(AggressiveInlining)] public static            bool                                          TryParse                                                              (string?                      text,        out IndexFor<T>                   result)                                                                                           { bool parsed    = long.TryParse(text,                                                                 System.Globalization.NumberStyles.Integer, null,     out long subresult); result = new((uint) subresult); return parsed; }
      [GameMethod(AggressiveInlining)] public static            bool                                          TryParse                                                              (in System.ReadOnlySpan<byte> bytes,       out IndexFor<T>                   result)                                                                                           { bool parsed    = uint.TryParse(System.Runtime.InteropServices.MemoryMarshal.Cast<byte, char>(bytes), System.Globalization.NumberStyles.Integer, null,     out uint subresult); result = new(subresult);        return parsed; }
      [GameMethod(AggressiveInlining)] public static            bool                                          TryParse                                                              (in System.ReadOnlySpan<char> characters,  out IndexFor<T>                   result)                                                                                           { bool parsed    = uint.TryParse(characters,                                                           System.Globalization.NumberStyles.Integer, null,     out uint subresult); result = new(subresult);        return parsed; }
      [GameMethod(AggressiveInlining)] public static            bool                                          TryParse                                                              (string?                      text,        System.IFormatProvider?           provider, out IndexFor<T>         result)                                                         { bool parsed    = uint.TryParse(text,                                                                 System.Globalization.NumberStyles.Integer, provider, out uint subresult); result = new(subresult);        return parsed; }
      [GameMethod(AggressiveInlining)] public static            bool                                          TryParse                                                              (in System.ReadOnlySpan<byte> bytes,       System.IFormatProvider?           provider, out IndexFor<T>         result)                                                         { bool parsed    = uint.TryParse(System.Runtime.InteropServices.MemoryMarshal.Cast<byte, char>(bytes), System.Globalization.NumberStyles.Integer, provider, out uint subresult); result = new(subresult);        return parsed; }
      [GameMethod(AggressiveInlining)] public static            bool                                          TryParse                                                              (in System.ReadOnlySpan<char> characters,  System.IFormatProvider?           provider, out IndexFor<T>         result)                                                         { bool parsed    = uint.TryParse(characters,                                                           System.Globalization.NumberStyles.Integer, provider, out uint subresult); result = new(subresult);        return parsed; }
      [GameMethod(AggressiveInlining)] public static            bool                                          TryParse                                                              (string?                      text,        System.Globalization.NumberStyles style,    System.IFormatProvider? provider, out IndexFor<T> result)                               { bool parsed    = long.TryParse(text,                                                                 style,                                     provider, out long subresult); result = new((uint) subresult); return parsed; }
      [GameMethod(AggressiveInlining)] public static            bool                                          TryParse                                                              (in System.ReadOnlySpan<byte> bytes,       System.Globalization.NumberStyles style,    System.IFormatProvider? provider, out IndexFor<T> result)                               { bool parsed    = uint.TryParse(System.Runtime.InteropServices.MemoryMarshal.Cast<byte, char>(bytes), style,                                     provider, out uint subresult); result = new(subresult);        return parsed; }
      [GameMethod(AggressiveInlining)] public static            bool                                          TryParse                                                              (in System.ReadOnlySpan<char> characters,  System.Globalization.NumberStyles style,    System.IFormatProvider? provider, out IndexFor<T> result)                               { bool parsed    = uint.TryParse(characters,                                                           style,                                     provider, out uint subresult); result = new(subresult);        return parsed; }
      [GameMethod(AggressiveInlining)] readonly int                                                           Game.Collections.IRefComparable<IndexFor<T>>.CompareTo        (ref IndexFor          <T>    index)                                                                                                                                           => this.value.CompareTo  (index.value);
      [GameMethod(AggressiveInlining)] readonly int                                                           Game.Collections.IRefReadOnlyComparable<IndexFor<T>>.CompareTo(in  IndexFor          <T>    index)                                                                                                                                           => this.value.CompareTo  (index.value);
      [GameMethod(AggressiveInlining)] readonly bool                                                          Game.Collections.IRefEquatable<IndexFor<T>>.Equals            (ref IndexFor          <T>    index)                                                                                                                                           => this.value.Equals     (index.value);
      [GameMethod(AggressiveInlining)] readonly bool                                                          Game.Collections.IRefReadOnlyEquatable<IndexFor<T>>.Equals    (in  IndexFor          <T>    index)                                                                                                                                           => this.value.Equals     (index.value);
      [GameMethod(AggressiveInlining)] readonly int                                                           System.IComparable.CompareTo                                          (object?                      index)                                                                                                                                           => this.value.CompareTo  (index);
      [GameMethod(AggressiveInlining)] readonly int                                                           System.IComparable<IndexFor<T>>.CompareTo                             (IndexFor<T>                  index)                                                                                                                                           => this.value.CompareTo  (index.value);
      [GameMethod(AggressiveInlining)] readonly System.TypeCode                                               System.IConvertible.GetTypeCode                                       ()                                                                                                                                                                             => this.value.GetTypeCode();
      [GameMethod(AggressiveInlining)] readonly bool                                                          System.IConvertible.ToBoolean                                         (System.IFormatProvider? provider)                                                                                                                                             => 0u != this.value ? true : false;
      [GameMethod(AggressiveInlining)] readonly byte                                                          System.IConvertible.ToByte                                            (System.IFormatProvider? provider)                                                                                                                                             => (byte) this.value;
      [GameMethod(AggressiveInlining)] readonly char                                                          System.IConvertible.ToChar                                            (System.IFormatProvider? provider)                                                                                                                                             => (char) this.value;
      [GameMethod(AggressiveInlining)] readonly System.DateTime                                               System.IConvertible.ToDateTime                                        (System.IFormatProvider? provider)                                                                                                                                             => new(this.value);
      [GameMethod(AggressiveInlining)] readonly decimal                                                       System.IConvertible.ToDecimal                                         (System.IFormatProvider? provider)                                                                                                                                             => (decimal) this.value;
      [GameMethod(AggressiveInlining)] readonly double                                                        System.IConvertible.ToDouble                                          (System.IFormatProvider? provider)                                                                                                                                             => (double)  this.value;
      [GameMethod(AggressiveInlining)] readonly short                                                         System.IConvertible.ToInt16                                           (System.IFormatProvider? provider)                                                                                                                                             => (short)   this.value;
      [GameMethod(AggressiveInlining)] readonly int                                                           System.IConvertible.ToInt32                                           (System.IFormatProvider? provider)                                                                                                                                             => (int)     this.value;
      [GameMethod(AggressiveInlining)] readonly long                                                          System.IConvertible.ToInt64                                           (System.IFormatProvider? provider)                                                                                                                                             => (long)    this.value;
      [GameMethod(AggressiveInlining)] readonly sbyte                                                         System.IConvertible.ToSByte                                           (System.IFormatProvider? provider)                                                                                                                                             => (sbyte)   this.value;
      [GameMethod(AggressiveInlining)] readonly float                                                         System.IConvertible.ToSingle                                          (System.IFormatProvider? provider)                                                                                                                                             => (float)   this.value;
      [GameMethod(AggressiveInlining)] readonly string                                                        System.IConvertible.ToString                                          (System.IFormatProvider? provider)                                                                                                                                             => this.ToString()!;
      [GameMethod(AggressiveInlining)] readonly object                                                        System.IConvertible.ToType                                            (System.Type             type, System.IFormatProvider? provider)                                                                                                               => System.Convert.ChangeType(this.value, type, provider);
      [GameMethod(AggressiveInlining)] readonly ushort                                                        System.IConvertible.ToUInt16                                          (System.IFormatProvider? provider)                                                                                                                                             => (ushort) this.value;
      [GameMethod(AggressiveInlining)] readonly uint                                                          System.IConvertible.ToUInt32                                          (System.IFormatProvider? provider)                                                                                                                                             => (uint)   this.value;
      [GameMethod(AggressiveInlining)] readonly ulong                                                         System.IConvertible.ToUInt64                                          (System.IFormatProvider? provider)                                                                                                                                             => (ulong)  this.value;
      [GameMethod(AggressiveInlining)] readonly bool                                                          System.IEquatable<IndexFor<T>>.Equals                                 (IndexFor<T>             index)                                                                                                                                                => this.Equals  (index);
      [GameMethod(AggressiveInlining)] readonly string                                                        System.IFormattable.ToString                                          (string?                 format, System.IFormatProvider? provider)                                                                                                             => this.ToString(format, provider);

      [GameMethod(AggressiveInlining)] public static bool        operator false(in IndexFor<T> index)                         => 0u == index.value;
      [GameMethod(AggressiveInlining)] public static bool        operator true (in IndexFor<T> index)                         => 0u != index.value;
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator +    (in IndexFor<T> index)                         => new((uint) +index.value);
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator -    (in IndexFor<T> index)                         => new((uint) -index.value);
      [GameMethod(AggressiveInlining)] public static bool        operator !    (in IndexFor<T> index)                         => 0u == index.value;
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator ~    (in IndexFor<T> index)                         => new((uint) ~index .value);
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator ++   (in IndexFor<T> index)                         => new(        index .value + 1u);
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator --   (in IndexFor<T> index)                         => new(        index .value - 1u);
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator +    (in IndexFor<T> indexA, in IndexFor<T> indexB) => new        (indexA.value +         indexB.value);
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator -    (in IndexFor<T> indexA, in IndexFor<T> indexB) => new        (indexA.value -         indexB.value);
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator *    (in IndexFor<T> indexA, in IndexFor<T> indexB) => new        (indexA.value *         indexB.value);
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator /    (in IndexFor<T> indexA, in IndexFor<T> indexB) => new        (indexA.value /         indexB.value);
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator %    (in IndexFor<T> indexA, in IndexFor<T> indexB) => new        (indexA.value %         indexB.value);
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator &    (in IndexFor<T> indexA, in IndexFor<T> indexB) => new((uint) (indexA.value &   (int) indexB.value));
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator |    (in IndexFor<T> indexA, in IndexFor<T> indexB) => new        (indexA.value |         indexB.value);
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator ^    (in IndexFor<T> indexA, in IndexFor<T> indexB) => new((uint) (indexA.value ^   (int) indexB.value));
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator <<   (in IndexFor<T> indexA, in IndexFor<T> indexB) => new        (indexA.value <<  (int) indexB.value);
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator >>   (in IndexFor<T> indexA, in IndexFor<T> indexB) => new        (indexA.value >>  (int) indexB.value);
      [GameMethod(AggressiveInlining)] public static IndexFor<T> operator >>>  (in IndexFor<T> indexA, in IndexFor<T> indexB) => new        (indexA.value >>> (int) indexB.value);
      [GameMethod(AggressiveInlining)] public static bool        operator ==   (in IndexFor<T> indexA, in IndexFor<T> indexB) =>             indexA.value ==        indexB.value;
      [GameMethod(AggressiveInlining)] public static bool        operator !=   (in IndexFor<T> indexA, in IndexFor<T> indexB) =>             indexA.value !=        indexB.value;
      [GameMethod(AggressiveInlining)] public static bool        operator <    (in IndexFor<T> indexA, in IndexFor<T> indexB) =>             indexA.value <         indexB.value;
      [GameMethod(AggressiveInlining)] public static bool        operator >    (in IndexFor<T> indexA, in IndexFor<T> indexB) =>             indexA.value >         indexB.value;
      [GameMethod(AggressiveInlining)] public static bool        operator <=   (in IndexFor<T> indexA, in IndexFor<T> indexB) =>             indexA.value <=        indexB.value;
      [GameMethod(AggressiveInlining)] public static bool        operator >=   (in IndexFor<T> indexA, in IndexFor<T> indexB) =>             indexA.value >=        indexB.value;

      [GameMethod(AggressiveInlining), GameResolution(0)] public static implicit operator bool       (in IndexFor<T> index) => 0u != index.value;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static implicit operator IndexFor<T>(uint           value) => new(value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static implicit operator uint       (in IndexFor<T> index) => index.value;
    }

    public interface InputInfo : Game.Collections.IRefEquatable<InputInfo> {
      public   UnityEngine.InputSystem.InputDevice? device { get; internal set; }
      public   double                               epoch  { get; internal set; }
      public   long                                 id     { get; internal set; }
      internal bool                                 polled { get;          set; }
      public   Game.Collections.DeviceState state  { get; internal set; }
    }

    public class InputStateCollection<T> : System.Collections.Generic.IReadOnlyCollection<T> {
      public readonly struct Enumerator : System.Collections.Generic.IEnumerator<T> {
        public readonly ref T                                                                                               Current => ref this.enumerator.Current.Current;
        public readonly Game.Collections.RefReadOnlyList<Game.Collections.RefList<T>.Enumerator>.Enumerator enumerator;
        readonly T                                                                                                          System.Collections.Generic.IEnumerator<T>.Current => this.Current;
        readonly object                                                                                                     System.Collections.IEnumerator.Current            => this.Current!;

        /* … */
        [GameConstructor]
        public Enumerator(InputStateCollection<T> enumerable) => (this.enumerator = new Game.Collections.RefReadOnlyList<Game.Collections.RefList<T>>(
          !enumerable.states.IsEmpty()
          ? enumerable.states
          : new System.Collections.ObjectModel.ReadOnlyCollection<Game.Collections.RefList<T>>(new[] {new Game.Collections.RefList<T>()})
        ).ConvertAll([GameMethod(AggressiveInlining)] (in Game.Collections.RefList<T> state) => state.GetEnumerator()).GetEnumerator()).MoveNext();

        /* … */
        [GameMethod(AggressiveInlining)] public readonly void Dispose                                () { for (this.enumerator.Reset(); this.enumerator.MoveNext(); ) { this.enumerator.Current.Dispose(); } this.enumerator.Dispose(); }
        [GameMethod(AggressiveInlining)] public readonly bool MoveNext                               () { while (!this.enumerator.Current.MoveNext()) { if (!this.enumerator.MoveNext()) return false; } return true; }
        [GameMethod(AggressiveInlining)] public readonly void Reset                                  () { for (this.enumerator.Reset(); this.enumerator.MoveNext(); ) { this.enumerator.Current.Reset(); } this.enumerator.Reset(); }
        [GameMethod(AggressiveInlining)] readonly bool        System.Collections.IEnumerator.MoveNext() => this.MoveNext();
        [GameMethod(AggressiveInlining)] readonly void        System.Collections.IEnumerator.Reset   () => this.Reset   ();
        [GameMethod(AggressiveInlining)] readonly void        System.IDisposable.Dispose             () => this.Dispose ();
      }

      /* … */
      public  uint                                                                                   Count { get { uint count = 0u; foreach (Game.Collections.RefList<T> state in states) { count += state.Count; } return count; } }
      private System.Collections.ObjectModel.ReadOnlyCollection<Game.Collections.RefList<T>> states;
      int                                                                                            System.Collections.Generic.IReadOnlyCollection<T>.Count => ((int) this.Count);

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)]
      public InputStateCollection(System.Collections.ObjectModel.ReadOnlyCollection<Game.Collections.RefList<T>> states) => this.states = states;

      /* … */
      [GameMethod(AggressiveInlining)] public          InputStateCollection<T>.Enumerator GetEnumerator                                          () => new(this);
      [GameMethod(AggressiveInlining)] public override string?                            ToString                                               () { string value = ""; for (uint index = Game.Collections.DeviceState.BEGIN; ; ++index) { value += $"{Game.Collections.DeviceState.GetDeviceState(index).ToString()!.Substring(12 /* ->> `"DeviceState.".Length` */)} {states[(int) index]}"; if (Game.Collections.DeviceState.END == index) break; value += ", "; } return value; }
      [GameMethod(AggressiveInlining)] System.Collections.Generic.IEnumerator<T>          System.Collections.Generic.IEnumerable<T>.GetEnumerator() => this.GetEnumerator();
      [GameMethod(AggressiveInlining)] System.Collections.IEnumerator                     System.Collections.IEnumerable.GetEnumerator           () => this.GetEnumerator();
    }

    public interface IRefComparable<T> : Game.Collections.IRefReadOnlyComparable<T> {
      public int CompareTo(ref T value);
    }

    public interface IRefComparer<T> : Game.Collections.IRefReadOnlyComparer<T>, System.Collections.Generic.IComparer<T>, System.Collections.IComparer {
      public int Compare(ref T a, ref T b);
    }

    public interface IRefEqualityComparer<T> : Game.Collections.IRefReadOnlyEqualityComparer<T>, System.Collections.Generic.IEqualityComparer<T>, System.Collections.IEqualityComparer {
      public bool Equals     (ref T a, ref T b);
      public int  GetHashCode(ref T value);
    }

    public interface IRefEquatable<T> : Game.Collections.IRefReadOnlyEquatable<T> {
      public bool Equals(ref T value);
    }

    public interface IRefReadOnlyComparable<T> : System.IComparable<T>, System.IComparable {
      public int CompareTo(in T value);
    }

    public interface IRefReadOnlyComparer<T> : System.Collections.Generic.IComparer<T>, System.Collections.IComparer {
      public int Compare(in T a, in T b);
    }

    public interface IRefReadOnlyEqualityComparer<T> : System.Collections.Generic.IEqualityComparer<T>, System.Collections.IEqualityComparer {
      public bool Equals     (in T a, in T b);
      public int  GetHashCode(in T value);
    }

    public interface IRefReadOnlyEquatable<T> : System.IEquatable<T> {
      public bool Equals(in T value);
    }

    public interface IShared : Game.Collections.IRefEquatable<IShared> {
      public abstract object? Value { get; }
    }

    public class Keyframe : System.Collections.Specialized.ListDictionary, System.Collections.Generic.IDictionary<string, object?>, System.Collections.Generic.IReadOnlyDictionary<string, object?>, System.Collections.IDictionary /* ->> Optimized for less than 10 properties using an internal singly-linked list; See `https://web.archive.org/web/20241209052731/https://learn.microsoft.com/en-us/dotnet/api/system.collections.specialized.listdictionary?view=net-9.0` */ {
      public readonly struct Enumerator : System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<string, object?>>, System.Collections.IDictionaryEnumerator {
        public  readonly System.Collections.Generic.KeyValuePair<string, object?> Current { get { System.Collections.DictionaryEntry element = this.enumerator.Entry; return new((string) element.Key, element.Value); } }
        private readonly System.Collections.IDictionaryEnumerator                 enumerator;
        System.Collections.Generic.KeyValuePair<string, object?>                  System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<string, object?>>.Current => this           .Current;
        System.Collections.DictionaryEntry                                        System.Collections.IDictionaryEnumerator.Entry                                                           => this.enumerator.Entry;
        readonly object                                                           System.Collections.IDictionaryEnumerator.Key                                                             => this.enumerator.Key;
        readonly object?                                                          System.Collections.IDictionaryEnumerator.Value                                                           => this.enumerator.Value;
        readonly object                                                           System.Collections.IEnumerator.Current                                                                   => this           .Current;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        internal Enumerator(Keyframe keyframe) => this.enumerator = ((System.Collections.Specialized.ListDictionary) keyframe).GetEnumerator();

        /* … */
        [GameMethod(AggressiveInlining)] public readonly void Dispose                                () { /* Do nothing… */ }
        [GameMethod(AggressiveInlining)] public readonly bool MoveNext                               () => this.enumerator.MoveNext();
        [GameMethod(AggressiveInlining)] public readonly void Reset                                  () => this.enumerator.Reset   ();
        [GameMethod(AggressiveInlining)] readonly bool        System.Collections.IEnumerator.MoveNext() => this           .MoveNext();
        [GameMethod(AggressiveInlining)] readonly void        System.Collections.IEnumerator.Reset   () => this           .Reset   ();
        [GameMethod(AggressiveInlining)] readonly void        System.IDisposable.Dispose             () => this           .Dispose ();
      }

      public sealed class KeyCollection : System.Collections.Generic.IEnumerable<string> {
        private readonly Keyframe keyframe;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        internal KeyCollection(Keyframe keyframe) => this.keyframe = keyframe;

        /* … */
        [GameMethod(AggressiveInlining)] public Keyframe.KeyEnumerator                GetEnumerator                                               () => new(keyframe);
        [GameMethod(AggressiveInlining)] System.Collections.Generic.IEnumerator<string> System.Collections.Generic.IEnumerable<string>.GetEnumerator() => this.GetEnumerator();
        [GameMethod(AggressiveInlining)] System.Collections.IEnumerator                 System.Collections.IEnumerable.GetEnumerator                () => this.GetEnumerator();
      }

      public readonly struct KeyEnumerator : System.Collections.Generic.IEnumerator<string> {
        public  readonly string                                   Current => (string) this.enumerator.Key;
        private readonly System.Collections.IDictionaryEnumerator enumerator;
        readonly string                                           System.Collections.Generic.IEnumerator<string>.Current => this.Current;
        readonly object                                           System.Collections.IEnumerator.Current                 => this.Current!;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        internal KeyEnumerator(Keyframe keyframe) => this.enumerator = ((System.Collections.Specialized.ListDictionary) keyframe).GetEnumerator();

        /* … */
        [GameMethod(AggressiveInlining)] public readonly void Dispose                                () { /* Do nothing… */ }
        [GameMethod(AggressiveInlining)] public readonly bool MoveNext                               () => this.enumerator.MoveNext();
        [GameMethod(AggressiveInlining)] public readonly void Reset                                  () => this.enumerator.Reset   ();
        [GameMethod(AggressiveInlining)] readonly bool        System.Collections.IEnumerator.MoveNext() => this           .MoveNext();
        [GameMethod(AggressiveInlining)] readonly void        System.Collections.IEnumerator.Reset   () => this           .Reset   ();
        [GameMethod(AggressiveInlining)] readonly void        System.IDisposable.Dispose             () => this           .Dispose ();
      }

      public sealed class ValueCollection : System.Collections.Generic.ICollection<object?> {
        private readonly Keyframe keyframe;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        internal ValueCollection(Keyframe keyframe) => this.keyframe = keyframe;

        /* … */
        [GameMethod(AggressiveInlining)] public Keyframe.ValueEnumerator        GetEnumerator                                                () => new(keyframe);
        [GameMethod(AggressiveInlining)] System.Collections.Generic.IEnumerator<object?> System.Collections.Generic.IEnumerable<object?>.GetEnumerator() => this.GetEnumerator();
        [GameMethod(AggressiveInlining)] System.Collections.IEnumerator                  System.Collections.IEnumerable.GetEnumerator                 () => this.GetEnumerator();
      }

      public readonly struct ValueEnumerator : System.Collections.Generic.IEnumerator<object?> {
        public  readonly object?                                  Current => this.enumerator.Value;
        private readonly System.Collections.IDictionaryEnumerator enumerator;
        readonly object?                                          System.Collections.Generic.IEnumerator<object?>.Current => this.Current;
        readonly object                                           System.Collections.IEnumerator.Current                  => this.Current!;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        internal ValueEnumerator(Keyframe keyframe) => this.enumerator = ((System.Collections.Specialized.ListDictionary) keyframe).GetEnumerator();

        /* … */
        [GameMethod(AggressiveInlining)] public readonly void Dispose                                () { /* Do nothing… */ }
        [GameMethod(AggressiveInlining)] public readonly bool MoveNext                               () => this.enumerator.MoveNext();
        [GameMethod(AggressiveInlining)] public readonly void Reset                                  () => this.enumerator.Reset   ();
        [GameMethod(AggressiveInlining)] readonly bool        System.Collections.IEnumerator.MoveNext() => this           .MoveNext();
        [GameMethod(AggressiveInlining)] readonly void        System.Collections.IEnumerator.Reset   () => this           .Reset   ();
        [GameMethod(AggressiveInlining)] readonly void        System.IDisposable.Dispose             () => this           .Dispose ();
      }

      /* … */
      protected     readonly System.Collections.Specialized.ListDictionary? Begin                                                                                                          =  null;
      public    new          uint                                           Count                                                                                                          => ((uint) base.Count);
      protected              System.Collections.Specialized.ListDictionary? End                                                                                                            { get => this.properties; private init {} }
      public                 bool                                           IsTimeframe                                                                                                    => this.Begin is not null;
      public                 string?                                        Name                                                                                                           =  null; // ->> Explicitly not `string.Empty`
      public                 System.Collections.Specialized.ListDictionary  Properties                                                                                                     => (System.Collections.Specialized.ListDictionary) this;
      int                                                                   System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string, object?>>.Count         => base.Count;
      bool                                                                  System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string, object?>>.IsReadOnly    => false; // ->> Property values are mutable
      System.Collections.Generic.ICollection<string>                        System.Collections.Generic.IDictionary<string, object?>.Keys                                                   => new Keyframe.KeyCollection  (base.Keys);
      System.Collections.Generic.ICollection<object?>                       System.Collections.Generic.IDictionary<string, object?>.Values                                                 => new Keyframe.ValueCollection(base);
      int                                                                   System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<string, object?>>.Count => base.Count;
      System.Collections.Generic.IEnumerable<string>                        System.Collections.Generic.IReadOnlyDictionary<string, object?>.Keys                                           => new Keyframe.KeyCollection  (base.Keys);
      System.Collections.Generic.IEnumerable<object?>                       System.Collections.Generic.IReadOnlyDictionary<string, object?>.Values                                         => new Keyframe.ValueCollection(base);
      int                                                                   System.Collections.ICollection.Count                                                                           => base.Count;
      bool                                                                  System.Collections.ICollection.IsSynchronized                                                                  => false;
      object                                                                System.Collections.ICollection.SyncRoot                                                                        => this;
      bool                                                                  System.Collections.IDictionary.IsFixedSize                                                                     => true;
      bool                                                                  System.Collections.IDictionary.IsReadOnly                                                                      => true;
      System.Collections.ICollection                                        System.Collections.IDictionary.Keys                                                                            => base.Keys;
      System.Collections.ICollection                                        System.Collections.IDictionary.Values                                                                          => base.Values;

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)]
      public Keyframe(string name, System.Collections.Generic.IReadOnlyDictionary<string, object?> properties) {
        this.name = name;

        foreach (System.Collections.Generic.KeyValuePair<string, object?> property in properties)
        this.properties.Add(property.Key, property.Value);
      }

      [GameConstructor, GameMethod(AggressiveInlining)]
      protected internal Keyframe(string name, System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) {
        this.begin = new();
        this.end   = new();
        this.name  = name;

        foreach (System.Collections.Generic.KeyValuePair<string, object?> property in begin) { if (end  .ContainsKey(property.Key)) this.begin.Add(property.Key, property.Value); }
        foreach (System.Collections.Generic.KeyValuePair<string, object?> property in end)   { if (begin.ContainsKey(property.Key)) this.end  .Add(property.Key, property.Value); }
      }

      /* … */
      [GameMethod(AggressiveInlining)] private new      void                                                                            Add                                                                                                           (string name, object? value)                                                           => throw new System.NotSupportedException("Keyframe can only modify existing properties, not add them");
      [GameMethod(AggressiveInlining)] private new      void                                                                            Clear                                                                                                         ()                                                                                     => throw new System.NotSupportedException("Keyframe can only modify existing properties, not remove them");
      [GameMethod(AggressiveInlining)] private new      void                                                                            Remove                                                                                                        (string name)                                                                          => throw new System.NotSupportedException("Keyframe can only modify existing properties, not remove them");
      [GameMethod(AggressiveInlining)] public  override string?                                                                         ToString() {
        uint index = this.Count;
        Shared<System.Text.StringBuilder>
        foreach (System.Collections.DictionaryEntry property in this)
          if (0u != --index) string += ", ";
        {
          value[index++] = $"{enumerator.Key}: " + (this.begin is null ? (enumerator.Value?.ToString() ?? string.Empty) : $"{this.begin![enumerator.Key]?.ToString() ?? string.Empty} → {this.end![enumerator.Key]?.ToString() ?? string.Empty}");
        }
        return $"[{string.Join(", ", value)}]";
      }
      [GameMethod(AggressiveInlining)] private          bool                                                                            TryGetProperty                                                                                                (string name, out object? value)                                                       { if (base.Contains(name)) { value = base[name]; return true; } value = null; return false; }
      [GameMethod(NoInlining)]         void                                                                                             System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string, object?>>.Add          (string name, object?     value)                                                       => this.Add     (name, value);
      [GameMethod(NoInlining)]         void                                                                                             System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string, object?>>.Clear        ()                                                                                     => this.Clear   ();
      [GameMethod(AggressiveInlining)] bool                                                                                             System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string, object?>>.Contains     (string                                                     name)                      => base.Contains(name);
      [GameMethod(AggressiveInlining)] bool                                                                                             System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string, object?>>.CopyTo       (System.Collections.Generic.KeyValuePair<string, object?>[] properties, int index)     { foreach (System.Collections.DictionaryEntry property in this) properties[index++] = new(property.Key, property.Value); }
      [GameMethod(NoInlining)]         bool                                                                                             System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<string, object?>>.Remove       (string                                                     name)                      => this.Remove        (name);
      [GameMethod(NoInlining)]         void                                                                                             System.Collections.Generic.IDictionary<string, object?>.Add                                                   (string                                                     name,       object? value) => this.Add           (name, value);
      [GameMethod(AggressiveInlining)] bool                                                                                             System.Collections.Generic.IDictionary<string, object?>.ContainsKey                                           (string                                                     name)                      => base.Contains      (name);
      [GameMethod(NoInlining)]         bool                                                                                             System.Collections.Generic.IDictionary<string, object?>.Remove                                                (string                                                     name)                      => this.Remove        (name);
      [GameMethod(AggressiveInlining)] bool                                                                                             System.Collections.Generic.IDictionary<string, object?>.TryGetValue                                           (string                                                     name, out object? value)   => this.TryGetProperty(name, out value);
      [GameMethod(AggressiveInlining)] System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<string, object?>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, object?>>.GetEnumerator()                                                                                     => new Keyframe.Enumerator(this);
      [GameMethod(AggressiveInlining)] bool                                                                                             System.Collections.Generic.IReadOnlyDictionary<string, object?>.ContainsKey                                   (string       name)                                                                    => base.Contains      (name);
      [GameMethod(AggressiveInlining)] bool                                                                                             System.Collections.Generic.IReadOnlyDictionary<string, object?>.TryGetValue                                   (string       name,  out object? value)                                                => this.TryGetProperty(name, out value);
      [GameMethod(AggressiveInlining)] void                                                                                             System.Collections.ICollection.CopyTo                                                                         (System.Array array, int         index)                                                => base.CopyTo        (array, index);
      [GameMethod(NoInlining)]         void                                                                                             System.Collections.IDictionary.Add                                                                            (object       name,  object?     value)                                                => this.Add           (name,  value);
      [GameMethod(NoInlining)]         void                                                                                             System.Collections.IDictionary.Clear                                                                          ()                                                                                     => this.Clear         ();
      [GameMethod(AggressiveInlining)] bool                                                                                             System.Collections.IDictionary.Contains                                                                       (object name)                                                                          => base.Contains      (name);
      [GameMethod(AggressiveInlining)] System.Collections.IDictionaryEnumerator                                                         System.Collections.IDictionary.GetEnumerator                                                                  ()                                                                                     => base.GetEnumerator ();
      [GameMethod(NoInlining)]         void                                                                                             System.Collections.IDictionary.Remove                                                                         (object name)                                                                          => this.Remove        (name);
      [GameMethod(AggressiveInlining)] System.Collections.IEnumerator                                                                   System.Collections.IEnumerable.GetEnumerator                                                                  ()                                                                                     => base.GetEnumerator ();

      public object? this                                                                [string key] { get => base[key]; set => base[key] = value; }
      object?        System.Collections.Generic.IDictionary<string, object?>.this        [string key] { get => base[key]; set => base[key] = value; }
      object?        System.Collections.Generic.IReadOnlyDictionary<string, object?>.this[string key] { get => base[key]; }
      object?        System.Collections.IDictionary.this                                 [object key] { get => base[key]; set => base[key] = value; }
    }

    public struct KeyInfo : Game.Collections.InputInfo, Game.Collections.IRefEquatable<KeyInfo> {
      public            (UnityEngine.KeyCode, UnityEngine.InputSystem.Key) codes  { get; internal set; } =  (UnityEngine.KeyCode.None, UnityEngine.InputSystem.Key.None);
      public            UnityEngine.InputSystem.InputDevice?               device { get; internal set; } =  null;
      public            double                                             epoch  { get; internal set; } =  UnityEngine.Time.realtimeSinceStartupAsDouble;
      public   readonly long                                               id                            => -1L;
      internal          bool                                               polled                        =  false;
      public   readonly bool                                               repeating                     => Util.Keys.RepeatDelay <= UnityEngine.Time.realtimeSinceStartupAsDouble - this.epoch;
      public            Game.Collections.DeviceState               state { get; internal set; }  =  Game.Collections.DeviceState.UNKNOWN;
      UnityEngine.InputSystem.InputDevice?                                 Game.Collections.InputInfo.device { get => this.device; set => this.device = value; }
      double                                                               Game.Collections.InputInfo.epoch  { get => this.epoch;  set => this.epoch  = value; }
      readonly long                                                        Game.Collections.InputInfo.id     { get => this.id;     set {} }
      bool                                                                 Game.Collections.InputInfo.polled { get => this.polled; set => this.polled = value; }
      Game.Collections.DeviceState                                 Game.Collections.InputInfo.state  { get => this.state;  set => this.state  = value; }

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)]
      public KeyInfo() {}

      /* … */
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals     (in KeyInfo                         key)   => key.codes == this.codes;
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals     (Game.Collections.InputInfo input) => input is KeyInfo key && this.Equals(key);
      [GameMethod(AggressiveInlining)] public override readonly bool    Equals     (object?                            value) => value is KeyInfo key && this.Equals(key);
      [GameMethod(AggressiveInlining)] public override readonly int     GetHashCode()                                         => System.HashCode.Combine(this.codes.Item1, this.codes.Item2);
      [GameMethod(AggressiveInlining)] public          readonly bool    IsModifier ()                                         => this.codes.Item2.IsModifierKey () || this.codes.Item1 switch { UnityEngine.KeyCode.LeftAlt or UnityEngine.KeyCode.LeftApple or UnityEngine.KeyCode.LeftCommand or UnityEngine.KeyCode.LeftControl or UnityEngine.KeyCode.LeftMeta or UnityEngine.KeyCode.LeftShift or UnityEngine.KeyCode.LeftWindows or UnityEngine.KeyCode.RightAlt or UnityEngine.KeyCode.RightApple or UnityEngine.KeyCode.RightCommand or UnityEngine.KeyCode.RightControl or UnityEngine.KeyCode.RightMeta or UnityEngine.KeyCode.RightShift or UnityEngine.KeyCode.RightWindows => true, _ => false };
      [GameMethod(AggressiveInlining)] public          readonly bool    IsTextual  ()                                         => this.codes.Item2.IsTextInputKey() || ((this.codes.Item1 >= UnityEngine.KeyCode.A && this.codes.Item1 <= UnityEngine.KeyCode.Z) || (this.codes.Item1 >= UnityEngine.KeyCode.Alpha0 && this.codes.Item1 <= UnityEngine.KeyCode.Alpha9) || (this.codes.Item1 >= UnityEngine.KeyCode.Keypad0 && this.codes.Item1 <= UnityEngine.KeyCode.Keypad9) || this.codes.Item1 switch { UnityEngine.KeyCode.BackQuote or UnityEngine.KeyCode.Backslash or UnityEngine.KeyCode.Comma or UnityEngine.KeyCode.Equals or UnityEngine.KeyCode.LeftBracket or UnityEngine.KeyCode.Minus or UnityEngine.KeyCode.Period or UnityEngine.KeyCode.RightBracket or UnityEngine.KeyCode.Semicolon or UnityEngine.KeyCode.Slash => true, _ => false });
      [GameMethod(AggressiveInlining)] public override readonly string? ToString   ()                                         => $"({(Game.Collections.DeviceState.BEGIN == this.state ? "↓" : Game.Collections.DeviceState.CURRENT == this.state ? "―" : Game.Collections.DeviceState.END == this.state ? "↑" : "…")}) ⌨️ [{this.codes.Item1}/{this.codes.Item2}]";

      [GameMethod(AggressiveInlining)]
      public static UnityEngine.InputSystem.Key Translate(UnityEngine.KeyCode code) {
        switch (code) {
          case UnityEngine.KeyCode.A             : return UnityEngine.InputSystem.Key.A;
          case UnityEngine.KeyCode.Alpha0        : return UnityEngine.InputSystem.Key.Digit0;
          case UnityEngine.KeyCode.Alpha1        : return UnityEngine.InputSystem.Key.Digit1;
          case UnityEngine.KeyCode.Alpha2        : return UnityEngine.InputSystem.Key.Digit2;
          case UnityEngine.KeyCode.Alpha3        : return UnityEngine.InputSystem.Key.Digit3;
          case UnityEngine.KeyCode.Alpha4        : return UnityEngine.InputSystem.Key.Digit4;
          case UnityEngine.KeyCode.Alpha5        : return UnityEngine.InputSystem.Key.Digit5;
          case UnityEngine.KeyCode.Alpha6        : return UnityEngine.InputSystem.Key.Digit6;
          case UnityEngine.KeyCode.Alpha7        : return UnityEngine.InputSystem.Key.Digit7;
          case UnityEngine.KeyCode.Alpha8        : return UnityEngine.InputSystem.Key.Digit8;
          case UnityEngine.KeyCode.Alpha9        : return UnityEngine.InputSystem.Key.Digit9;
          case UnityEngine.KeyCode.AltGr         : return UnityEngine.InputSystem.Key.AltGr;
          case UnityEngine.KeyCode.B             : return UnityEngine.InputSystem.Key.B;
          case UnityEngine.KeyCode.BackQuote     : return UnityEngine.InputSystem.Key.Backquote; // ->> `UnityEngine.InputSystem.Key.OEM3`
          case UnityEngine.KeyCode.Backslash     : return UnityEngine.InputSystem.Key.Backslash; // ->> `UnityEngine.InputSystem.Key.OEM5`
          case UnityEngine.KeyCode.Backspace     : return UnityEngine.InputSystem.Key.Backspace;
          case UnityEngine.KeyCode.C             : return UnityEngine.InputSystem.Key.C;
          case UnityEngine.KeyCode.CapsLock      : return UnityEngine.InputSystem.Key.CapsLock;
          case UnityEngine.KeyCode.Comma         : return UnityEngine.InputSystem.Key.Comma;
          case UnityEngine.KeyCode.D             : return UnityEngine.InputSystem.Key.D;
          case UnityEngine.KeyCode.Delete        : return UnityEngine.InputSystem.Key.Delete;
          case UnityEngine.KeyCode.DownArrow     : return UnityEngine.InputSystem.Key.DownArrow;
          case UnityEngine.KeyCode.E             : return UnityEngine.InputSystem.Key.E;
          case UnityEngine.KeyCode.End           : return UnityEngine.InputSystem.Key.End;
          case UnityEngine.KeyCode.Equals        : return UnityEngine.InputSystem.Key.Equals;
          case UnityEngine.KeyCode.Escape        : return UnityEngine.InputSystem.Key.Escape;
          case UnityEngine.KeyCode.F             : return UnityEngine.InputSystem.Key.F;
          case UnityEngine.KeyCode.F1            : return UnityEngine.InputSystem.Key.F1;
          case UnityEngine.KeyCode.F10           : return UnityEngine.InputSystem.Key.F10;
          case UnityEngine.KeyCode.F11           : return UnityEngine.InputSystem.Key.F11;
          case UnityEngine.KeyCode.F12           : return UnityEngine.InputSystem.Key.F12;
          case UnityEngine.KeyCode.F2            : return UnityEngine.InputSystem.Key.F2;
          case UnityEngine.KeyCode.F3            : return UnityEngine.InputSystem.Key.F3;
          case UnityEngine.KeyCode.F4            : return UnityEngine.InputSystem.Key.F4;
          case UnityEngine.KeyCode.F5            : return UnityEngine.InputSystem.Key.F5;
          case UnityEngine.KeyCode.F6            : return UnityEngine.InputSystem.Key.F6;
          case UnityEngine.KeyCode.F7            : return UnityEngine.InputSystem.Key.F7;
          case UnityEngine.KeyCode.F8            : return UnityEngine.InputSystem.Key.F8;
          case UnityEngine.KeyCode.F9            : return UnityEngine.InputSystem.Key.F9;
          case UnityEngine.KeyCode.G             : return UnityEngine.InputSystem.Key.G;
          case UnityEngine.KeyCode.H             : return UnityEngine.InputSystem.Key.H;
          case UnityEngine.KeyCode.Home          : return UnityEngine.InputSystem.Key.Home;
          case UnityEngine.KeyCode.I             : return UnityEngine.InputSystem.Key.I;
          case UnityEngine.KeyCode.Insert        : return UnityEngine.InputSystem.Key.Insert;
          case UnityEngine.KeyCode.J             : return UnityEngine.InputSystem.Key.J;
          case UnityEngine.KeyCode.K             : return UnityEngine.InputSystem.Key.K;
          case UnityEngine.KeyCode.Keypad0       : return UnityEngine.InputSystem.Key.Numpad0;
          case UnityEngine.KeyCode.Keypad1       : return UnityEngine.InputSystem.Key.Numpad1;
          case UnityEngine.KeyCode.Keypad2       : return UnityEngine.InputSystem.Key.Numpad2;
          case UnityEngine.KeyCode.Keypad3       : return UnityEngine.InputSystem.Key.Numpad3;
          case UnityEngine.KeyCode.Keypad4       : return UnityEngine.InputSystem.Key.Numpad4;
          case UnityEngine.KeyCode.Keypad5       : return UnityEngine.InputSystem.Key.Numpad5;
          case UnityEngine.KeyCode.Keypad6       : return UnityEngine.InputSystem.Key.Numpad6;
          case UnityEngine.KeyCode.Keypad7       : return UnityEngine.InputSystem.Key.Numpad7;
          case UnityEngine.KeyCode.Keypad8       : return UnityEngine.InputSystem.Key.Numpad8;
          case UnityEngine.KeyCode.Keypad9       : return UnityEngine.InputSystem.Key.Numpad9;
          case UnityEngine.KeyCode.KeypadDivide  : return UnityEngine.InputSystem.Key.NumpadDivide;
          case UnityEngine.KeyCode.KeypadEnter   : return UnityEngine.InputSystem.Key.NumpadEnter;
          case UnityEngine.KeyCode.KeypadEquals  : return UnityEngine.InputSystem.Key.NumpadEquals;
          case UnityEngine.KeyCode.KeypadMinus   : return UnityEngine.InputSystem.Key.NumpadMinus;
          case UnityEngine.KeyCode.KeypadMultiply: return UnityEngine.InputSystem.Key.NumpadMultiply;
          case UnityEngine.KeyCode.KeypadPeriod  : return UnityEngine.InputSystem.Key.NumpadPeriod;
          case UnityEngine.KeyCode.KeypadPlus    : return UnityEngine.InputSystem.Key.NumpadPlus;
          case UnityEngine.KeyCode.L             : return UnityEngine.InputSystem.Key.L;
          case UnityEngine.KeyCode.LeftAlt       : return UnityEngine.InputSystem.Key.LeftAlt;
          case UnityEngine.KeyCode.LeftArrow     : return UnityEngine.InputSystem.Key.LeftArrow;
          case UnityEngine.KeyCode.LeftBracket   : return UnityEngine.InputSystem.Key.LeftBracket; // ->> `UnityEngine.InputSystem.Key.OEM4`
          case UnityEngine.KeyCode.LeftControl   : return UnityEngine.InputSystem.Key.LeftCtrl;
          case UnityEngine.KeyCode.LeftMeta      : return UnityEngine.InputSystem.Key.LeftMeta; // ->> `UnityEngine.KeyCode.LeftApple` → `UnityEngine.InputSystem.Key.LeftApple`, `UnityEngine.KeyCode.LeftCommand` → `UnityEngine.InputSystem.Key.LeftCommand`,
          case UnityEngine.KeyCode.LeftShift     : return UnityEngine.InputSystem.Key.LeftShift;
          case UnityEngine.KeyCode.LeftWindows   : return UnityEngine.InputSystem.Key.LeftWindows;
          case UnityEngine.KeyCode.M             : return UnityEngine.InputSystem.Key.M;
          case UnityEngine.KeyCode.Menu          : return UnityEngine.InputSystem.Key.ContextMenu;
          case UnityEngine.KeyCode.Minus         : return UnityEngine.InputSystem.Key.Minus;
          case UnityEngine.KeyCode.N             : return UnityEngine.InputSystem.Key.N;
          case UnityEngine.KeyCode.None          : return UnityEngine.InputSystem.Key.None;
          case UnityEngine.KeyCode.Numlock       : return UnityEngine.InputSystem.Key.NumLock;
          case UnityEngine.KeyCode.O             : return UnityEngine.InputSystem.Key.O;
          case UnityEngine.KeyCode.P             : return UnityEngine.InputSystem.Key.P;
          case UnityEngine.KeyCode.PageDown      : return UnityEngine.InputSystem.Key.PageDown;
          case UnityEngine.KeyCode.PageUp        : return UnityEngine.InputSystem.Key.PageUp;
          case UnityEngine.KeyCode.Pause         : return UnityEngine.InputSystem.Key.Pause;
          case UnityEngine.KeyCode.Period        : return UnityEngine.InputSystem.Key.Period;
          case UnityEngine.KeyCode.Print         : return UnityEngine.InputSystem.Key.PrintScreen;
          case UnityEngine.KeyCode.Q             : return UnityEngine.InputSystem.Key.Q;
          case UnityEngine.KeyCode.Quote         : return UnityEngine.InputSystem.Key.Quote;
          case UnityEngine.KeyCode.R             : return UnityEngine.InputSystem.Key.R;
          case UnityEngine.KeyCode.Return        : return UnityEngine.InputSystem.Key.Enter;
          case UnityEngine.KeyCode.RightAlt      : return UnityEngine.InputSystem.Key.RightAlt;
          case UnityEngine.KeyCode.RightArrow    : return UnityEngine.InputSystem.Key.RightArrow;
          case UnityEngine.KeyCode.RightBracket  : return UnityEngine.InputSystem.Key.RightBracket;
          case UnityEngine.KeyCode.RightControl  : return UnityEngine.InputSystem.Key.RightCtrl;
          case UnityEngine.KeyCode.RightMeta     : return UnityEngine.InputSystem.Key.RightMeta; // ->> `UnityEngine.KeyCode.RightApple` → `UnityEngine.InputSystem.Key.RightApple`, `UnityEngine.KeyCode.RightCommand` → `UnityEngine.InputSystem.Key.RightCommand`
          case UnityEngine.KeyCode.RightShift    : return UnityEngine.InputSystem.Key.RightShift;
          case UnityEngine.KeyCode.RightWindows  : return UnityEngine.InputSystem.Key.RightWindows;
          case UnityEngine.KeyCode.S             : return UnityEngine.InputSystem.Key.S;
          case UnityEngine.KeyCode.ScrollLock    : return UnityEngine.InputSystem.Key.ScrollLock;
          case UnityEngine.KeyCode.Semicolon     : return UnityEngine.InputSystem.Key.Semicolon; // ->> `UnityEngine.InputSystem.Key.OEM1`
          case UnityEngine.KeyCode.Slash         : return UnityEngine.InputSystem.Key.Slash;     // ->> `UnityEngine.InputSystem.Key.OEM2`
          case UnityEngine.KeyCode.Space         : return UnityEngine.InputSystem.Key.Space;
          case UnityEngine.KeyCode.T             : return UnityEngine.InputSystem.Key.T;
          case UnityEngine.KeyCode.Tab           : return UnityEngine.InputSystem.Key.Tab;
          case UnityEngine.KeyCode.U             : return UnityEngine.InputSystem.Key.U;
          case UnityEngine.KeyCode.UpArrow       : return UnityEngine.InputSystem.Key.UpArrow;
          case UnityEngine.KeyCode.V             : return UnityEngine.InputSystem.Key.V;
          case UnityEngine.KeyCode.W             : return UnityEngine.InputSystem.Key.W;
          case UnityEngine.KeyCode.X             : return UnityEngine.InputSystem.Key.X;
          case UnityEngine.KeyCode.Y             : return UnityEngine.InputSystem.Key.Y;
          case UnityEngine.KeyCode.Z             : return UnityEngine.InputSystem.Key.Z;
        }

        try { return (UnityEngine.InputSystem.Key) System.Enum.Parse(typeof(UnityEngine.InputSystem.Key), code.ToString()); }
        catch (System.ArgumentException) {}

        return UnityEngine.InputSystem.Key.None;
      }

      [GameMethod(AggressiveInlining)]
      public static UnityEngine.KeyCode Translate(UnityEngine.InputSystem.Key code) {
        switch (code) {
          case UnityEngine.InputSystem.Key.A             : return UnityEngine.KeyCode.A;
          case UnityEngine.InputSystem.Key.B             : return UnityEngine.KeyCode.B;
          case UnityEngine.InputSystem.Key.Backquote     : return UnityEngine.KeyCode.BackQuote;
          case UnityEngine.InputSystem.Key.Backslash     : return UnityEngine.KeyCode.Backslash;
          case UnityEngine.InputSystem.Key.Backspace     : return UnityEngine.KeyCode.Backspace;
          case UnityEngine.InputSystem.Key.C             : return UnityEngine.KeyCode.C;
          case UnityEngine.InputSystem.Key.CapsLock      : return UnityEngine.KeyCode.CapsLock;
          case UnityEngine.InputSystem.Key.Comma         : return UnityEngine.KeyCode.Comma;
          case UnityEngine.InputSystem.Key.ContextMenu   : return UnityEngine.KeyCode.Menu;
          case UnityEngine.InputSystem.Key.D             : return UnityEngine.KeyCode.D;
          case UnityEngine.InputSystem.Key.Delete        : return UnityEngine.KeyCode.Delete;
          case UnityEngine.InputSystem.Key.Digit0        : return UnityEngine.KeyCode.Alpha0;
          case UnityEngine.InputSystem.Key.Digit1        : return UnityEngine.KeyCode.Alpha1;
          case UnityEngine.InputSystem.Key.Digit2        : return UnityEngine.KeyCode.Alpha2;
          case UnityEngine.InputSystem.Key.Digit3        : return UnityEngine.KeyCode.Alpha3;
          case UnityEngine.InputSystem.Key.Digit4        : return UnityEngine.KeyCode.Alpha4;
          case UnityEngine.InputSystem.Key.Digit5        : return UnityEngine.KeyCode.Alpha5;
          case UnityEngine.InputSystem.Key.Digit6        : return UnityEngine.KeyCode.Alpha6;
          case UnityEngine.InputSystem.Key.Digit7        : return UnityEngine.KeyCode.Alpha7;
          case UnityEngine.InputSystem.Key.Digit8        : return UnityEngine.KeyCode.Alpha8;
          case UnityEngine.InputSystem.Key.Digit9        : return UnityEngine.KeyCode.Alpha9;
          case UnityEngine.InputSystem.Key.DownArrow     : return UnityEngine.KeyCode.DownArrow;
          case UnityEngine.InputSystem.Key.E             : return UnityEngine.KeyCode.E;
          case UnityEngine.InputSystem.Key.End           : return UnityEngine.KeyCode.End;
          case UnityEngine.InputSystem.Key.Enter         : return UnityEngine.KeyCode.Return;
          case UnityEngine.InputSystem.Key.Equals        : return UnityEngine.KeyCode.Equals;
          case UnityEngine.InputSystem.Key.Escape        : return UnityEngine.KeyCode.Escape;
          case UnityEngine.InputSystem.Key.F             : return UnityEngine.KeyCode.F;
          case UnityEngine.InputSystem.Key.F1            : return UnityEngine.KeyCode.F1;
          case UnityEngine.InputSystem.Key.F10           : return UnityEngine.KeyCode.F10;
          case UnityEngine.InputSystem.Key.F11           : return UnityEngine.KeyCode.F11;
          case UnityEngine.InputSystem.Key.F12           : return UnityEngine.KeyCode.F12;
          case UnityEngine.InputSystem.Key.F2            : return UnityEngine.KeyCode.F2;
          case UnityEngine.InputSystem.Key.F3            : return UnityEngine.KeyCode.F3;
          case UnityEngine.InputSystem.Key.F4            : return UnityEngine.KeyCode.F4;
          case UnityEngine.InputSystem.Key.F5            : return UnityEngine.KeyCode.F5;
          case UnityEngine.InputSystem.Key.F6            : return UnityEngine.KeyCode.F6;
          case UnityEngine.InputSystem.Key.F7            : return UnityEngine.KeyCode.F7;
          case UnityEngine.InputSystem.Key.F8            : return UnityEngine.KeyCode.F8;
          case UnityEngine.InputSystem.Key.F9            : return UnityEngine.KeyCode.F9;
          case UnityEngine.InputSystem.Key.G             : return UnityEngine.KeyCode.G;
          case UnityEngine.InputSystem.Key.H             : return UnityEngine.KeyCode.H;
          case UnityEngine.InputSystem.Key.Home          : return UnityEngine.KeyCode.Home;
          case UnityEngine.InputSystem.Key.I             : return UnityEngine.KeyCode.I;
          case UnityEngine.InputSystem.Key.Insert        : return UnityEngine.KeyCode.Insert;
          case UnityEngine.InputSystem.Key.J             : return UnityEngine.KeyCode.J;
          case UnityEngine.InputSystem.Key.K             : return UnityEngine.KeyCode.K;
          case UnityEngine.InputSystem.Key.L             : return UnityEngine.KeyCode.L;
          case UnityEngine.InputSystem.Key.LeftAlt       : return UnityEngine.KeyCode.LeftAlt;
          case UnityEngine.InputSystem.Key.LeftArrow     : return UnityEngine.KeyCode.LeftArrow;
          case UnityEngine.InputSystem.Key.LeftBracket   : return UnityEngine.KeyCode.LeftBracket;
          case UnityEngine.InputSystem.Key.LeftMeta      : return UnityEngine.KeyCode.LeftMeta; // ->> `UnityEngine.InputSystem.Key.LeftApple` → `UnityEngine.KeyCode.LeftApple`, `UnityEngine.InputSystem.Key.LeftCommand` → `UnityEngine.KeyCode.LeftCommand`, `UnityEngine.InputSystem.Key.LeftWindows` → `UnityEngine.KeyCode.LeftWindows`
          case UnityEngine.InputSystem.Key.LeftCtrl      : return UnityEngine.KeyCode.LeftControl;
          case UnityEngine.InputSystem.Key.LeftShift     : return UnityEngine.KeyCode.LeftShift;
          case UnityEngine.InputSystem.Key.M             : return UnityEngine.KeyCode.M;
          case UnityEngine.InputSystem.Key.Minus         : return UnityEngine.KeyCode.Minus;
          case UnityEngine.InputSystem.Key.N             : return UnityEngine.KeyCode.N;
          case UnityEngine.InputSystem.Key.None          : return UnityEngine.KeyCode.None;
          case UnityEngine.InputSystem.Key.NumLock       : return UnityEngine.KeyCode.Numlock;
          case UnityEngine.InputSystem.Key.Numpad0       : return UnityEngine.KeyCode.Keypad0;
          case UnityEngine.InputSystem.Key.Numpad1       : return UnityEngine.KeyCode.Keypad1;
          case UnityEngine.InputSystem.Key.Numpad2       : return UnityEngine.KeyCode.Keypad2;
          case UnityEngine.InputSystem.Key.Numpad3       : return UnityEngine.KeyCode.Keypad3;
          case UnityEngine.InputSystem.Key.Numpad4       : return UnityEngine.KeyCode.Keypad4;
          case UnityEngine.InputSystem.Key.Numpad5       : return UnityEngine.KeyCode.Keypad5;
          case UnityEngine.InputSystem.Key.Numpad6       : return UnityEngine.KeyCode.Keypad6;
          case UnityEngine.InputSystem.Key.Numpad7       : return UnityEngine.KeyCode.Keypad7;
          case UnityEngine.InputSystem.Key.Numpad8       : return UnityEngine.KeyCode.Keypad8;
          case UnityEngine.InputSystem.Key.Numpad9       : return UnityEngine.KeyCode.Keypad9;
          case UnityEngine.InputSystem.Key.NumpadDivide  : return UnityEngine.KeyCode.KeypadDivide;
          case UnityEngine.InputSystem.Key.NumpadEnter   : return UnityEngine.KeyCode.KeypadEnter;
          case UnityEngine.InputSystem.Key.NumpadEquals  : return UnityEngine.KeyCode.KeypadEquals;
          case UnityEngine.InputSystem.Key.NumpadMinus   : return UnityEngine.KeyCode.KeypadMinus;
          case UnityEngine.InputSystem.Key.NumpadMultiply: return UnityEngine.KeyCode.KeypadMultiply;
          case UnityEngine.InputSystem.Key.NumpadPeriod  : return UnityEngine.KeyCode.KeypadPeriod;
          case UnityEngine.InputSystem.Key.NumpadPlus    : return UnityEngine.KeyCode.KeypadPlus;
          case UnityEngine.InputSystem.Key.O             : return UnityEngine.KeyCode.O;
          case UnityEngine.InputSystem.Key.OEM1          : return UnityEngine.KeyCode.Semicolon;
          case UnityEngine.InputSystem.Key.OEM2          : return UnityEngine.KeyCode.Slash;
          case UnityEngine.InputSystem.Key.OEM3          : return UnityEngine.KeyCode.BackQuote;
          case UnityEngine.InputSystem.Key.OEM4          : return UnityEngine.KeyCode.LeftBracket;
          case UnityEngine.InputSystem.Key.OEM5          : return UnityEngine.KeyCode.Backslash;
          case UnityEngine.InputSystem.Key.P             : return UnityEngine.KeyCode.P;
          case UnityEngine.InputSystem.Key.PageDown      : return UnityEngine.KeyCode.PageDown;
          case UnityEngine.InputSystem.Key.PageUp        : return UnityEngine.KeyCode.PageUp;
          case UnityEngine.InputSystem.Key.Pause         : return UnityEngine.KeyCode.Pause;
          case UnityEngine.InputSystem.Key.Period        : return UnityEngine.KeyCode.Period;
          case UnityEngine.InputSystem.Key.PrintScreen   : return UnityEngine.KeyCode.Print;
          case UnityEngine.InputSystem.Key.Q             : return UnityEngine.KeyCode.Q;
          case UnityEngine.InputSystem.Key.Quote         : return UnityEngine.KeyCode.Quote;
          case UnityEngine.InputSystem.Key.R             : return UnityEngine.KeyCode.R;
          case UnityEngine.InputSystem.Key.RightAlt      : return UnityEngine.KeyCode.RightAlt; // ->> `UnityEngine.KeyCode.AltGr`
          case UnityEngine.InputSystem.Key.RightArrow    : return UnityEngine.KeyCode.RightArrow;
          case UnityEngine.InputSystem.Key.RightBracket  : return UnityEngine.KeyCode.RightBracket;
          case UnityEngine.InputSystem.Key.RightCtrl     : return UnityEngine.KeyCode.RightControl;
          case UnityEngine.InputSystem.Key.RightMeta     : return UnityEngine.KeyCode.RightMeta; // ->> `UnityEngine.InputSystem.Key.RightApple` → `UnityEngine.KeyCode.RightApple`, `UnityEngine.InputSystem.Key.RightCommand` → `UnityEngine.KeyCode.RightCommand`, `UnityEngine.InputSystem.Key.RightWindows` → `UnityEngine.KeyCode.RightWindows`
          case UnityEngine.InputSystem.Key.RightShift    : return UnityEngine.KeyCode.RightShift;
          case UnityEngine.InputSystem.Key.S             : return UnityEngine.KeyCode.S;
          case UnityEngine.InputSystem.Key.ScrollLock    : return UnityEngine.KeyCode.ScrollLock;
          case UnityEngine.InputSystem.Key.Semicolon     : return UnityEngine.KeyCode.Semicolon;
          case UnityEngine.InputSystem.Key.Slash         : return UnityEngine.KeyCode.Slash;
          case UnityEngine.InputSystem.Key.Space         : return UnityEngine.KeyCode.Space;
          case UnityEngine.InputSystem.Key.T             : return UnityEngine.KeyCode.T;
          case UnityEngine.InputSystem.Key.Tab           : return UnityEngine.KeyCode.Tab;
          case UnityEngine.InputSystem.Key.U             : return UnityEngine.KeyCode.U;
          case UnityEngine.InputSystem.Key.UpArrow       : return UnityEngine.KeyCode.UpArrow;
          case UnityEngine.InputSystem.Key.V             : return UnityEngine.KeyCode.V;
          case UnityEngine.InputSystem.Key.W             : return UnityEngine.KeyCode.W;
          case UnityEngine.InputSystem.Key.X             : return UnityEngine.KeyCode.X;
          case UnityEngine.InputSystem.Key.Y             : return UnityEngine.KeyCode.Y;
          case UnityEngine.InputSystem.Key.Z             : return UnityEngine.KeyCode.Z;
        }

        try { return (UnityEngine.KeyCode) System.Enum.Parse(typeof(UnityEngine.KeyCode), code.ToString()); }
        catch (System.ArgumentException) {}

        return UnityEngine.KeyCode.None;
      }

      [GameMethod(AggressiveInlining)] readonly bool Game.Collections.IRefEquatable<KeyInfo>.Equals                                   (ref KeyInfo                            key)   => this.Equals(in key);
      [GameMethod(AggressiveInlining)] readonly bool Game.Collections.IRefEquatable<Game.Collections.InputInfo>.Equals        (ref Game.Collections.InputInfo input) => this.Equals(input);
      [GameMethod(AggressiveInlining)] readonly bool Game.Collections.IRefReadOnlyEquatable<KeyInfo>.Equals                           (in  KeyInfo                            key)   => this.Equals(in key);
      [GameMethod(AggressiveInlining)] readonly bool Game.Collections.IRefReadOnlyEquatable<Game.Collections.InputInfo>.Equals(in  Game.Collections.InputInfo input) => this.Equals(input);
      [GameMethod(AggressiveInlining)] readonly bool System.IEquatable<KeyInfo>.Equals                                                        (KeyInfo                                key)   => this.Equals(key);
      [GameMethod(AggressiveInlining)] readonly bool System.IEquatable<Game.Collections.InputInfo>.Equals                             (Game.Collections.InputInfo     input) => this.Equals(input);
    }

    public readonly struct LazyMono<T> : /* System.DynamicObject, */ Game.Collections.IMono, Game.Collections.IRefEquatable<LazyMono<T>> /* ->> Based on `System.Lazy<T>`; See `https://web.archive.org/web/20241119171227/https://learn.microsoft.com/en-us/dotnet/api/system.lazy-1?view=net-9.0` */ {
      private sealed class Lazy {
        public bool hasValue = false;
        public T    value    = default!;
      }

      public  readonly ref readonly bool HasValue                                { get { this.Ensure(); return ref this.lazy.hasValue; } }
      public  readonly System.Func<T>    Init { get; internal init; }            = [GameMethod(AggressiveInlining)] static () => default!;
      private readonly LazyMono<T>.Lazy  lazy                                    = new();
      public  readonly ref T             Value                                   { get { this.Ensure(); return ref this.lazy.value; } }
      readonly bool                      Game.Collections.IMono.HasValue => this.HasValue;
      readonly object?                   Game.Collections.IMono.Value    => this.HasValue ? this.Value : null;

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)] public  LazyMono(System.Func<T> initializer) => this.Init = initializer;
      [GameConstructor, GameMethod(AggressiveInlining)] private LazyMono(in T           value)       { this.lazy.hasValue = true; this.lazy.value = value; }

      /* … */
      [GameMethod(AggressiveInlining)] private          readonly void    Ensure                                                                                 ()                                             { if (!this.lazy.hasValue) { T value = this.Init(); if (null != value) { this.lazy.hasValue = true; this.lazy.value = value; } } }
      [GameMethod(AggressiveInlining)] public           readonly bool    Equals                                                                                 (in T                                value)    {  this.Ensure();                    return this.lazy.hasValue ? Game.Collections.RefReadOnlyEqualityComparer<T>.Default.Equals(in this.lazy.value!, in value) : null == value; }
      [GameMethod(AggressiveInlining)] public           readonly bool    Equals                                                                                 (in LazyMono<T>                      lazyMono) {  this.Ensure(); lazyMono.Ensure(); return this.lazy.hasValue ? lazyMono.lazy.hasValue && Game.Collections.RefReadOnlyEqualityComparer<T>.Default.Equals(in this.lazy.value!, in lazyMono.lazy.value!) : !lazyMono.lazy.hasValue; }
      [GameMethod(AggressiveInlining)] public           readonly bool    Equals                                                                                 (Game.Collections.IMono      mono)     {  this.Ensure();                    return this.lazy.hasValue ? mono         .HasValue && this.lazy.value!.Equals(mono.Value!)                                                                                  : !mono        .HasValue; }
      [GameMethod(AggressiveInlining)] public           readonly bool    Equals                                                                                 (in Game.Collections.Mono<T> mono)     {  this.Ensure();                    return this.lazy.hasValue ? mono         .HasValue && Game.Collections.RefReadOnlyEqualityComparer<T>.Default.Equals(in this.lazy.value!, in mono.Value!)           : !mono        .HasValue; }
      [GameMethod(AggressiveInlining)] public  override readonly bool    Equals                                                                                 (object?                             value)    {  this.Ensure();                    return null == value || value is null ? !this.lazy.hasValue : value switch { T subvalue => this.Equals(subvalue), LazyMono<T> lazyMono => this.Equals(lazyMono), Game.Collections.Mono<T> mono => this.Equals(mono), Game.Collections.IMono mono => this.Equals(mono), _ => this.lazy.hasValue && this.lazy.value!.Equals(value) }; }
      [GameMethod(AggressiveInlining)] public  override readonly int     GetHashCode                                                                            ()                                             {  this.Ensure();                    return this.lazy.hasValue ? this.lazy.value!.GetHashCode() : base.GetHashCode(); }
      [GameMethod(AggressiveInlining)] public           readonly T       GetValueOrDefault                                                                      ()                                             => this.GetValueOrDefault(default!);
      [GameMethod(AggressiveInlining)] public           readonly T       GetValueOrDefault                                                                      (in T fallback)                                {  this.Ensure(); return this.lazy.hasValue ? this.lazy.value             : fallback; }
      [GameMethod(AggressiveInlining)] public  override readonly string? ToString                                                                               ()                                             {  this.Ensure(); return this.lazy.hasValue ? this.lazy.value!.ToString() : string.Empty; }
      [GameMethod(AggressiveInlining)] readonly bool                     Game.Collections.IRefEquatable<LazyMono<T>>.Equals                             (ref LazyMono<T>                    lazyMono)  => this.Equals(in lazyMono);
      [GameMethod(AggressiveInlining)] readonly bool                     Game.Collections.IRefEquatable<Game.Collections.IMono>.Equals          (ref Game.Collections.IMono mono)      => this.Equals(mono);
      [GameMethod(AggressiveInlining)] readonly bool                     Game.Collections.IRefReadOnlyEquatable<LazyMono<T>>.Equals                     (in  LazyMono<T>                    lazyMono)  => this.Equals(in lazyMono);
      [GameMethod(AggressiveInlining)] readonly bool                     Game.Collections.IRefReadOnlyEquatable<Game.Collections.IMono>.Equals  (in  Game.Collections.IMono mono)      => this.Equals(mono);
      [GameMethod(AggressiveInlining)] readonly bool                     System.IEquatable<LazyMono<T>>.Equals                                                  (LazyMono<T>                        lazyMono)  => this.Equals(lazyMono);
      [GameMethod(AggressiveInlining)] readonly bool                     System.IEquatable<Game.Collections.IMono>.Equals                               (Game.Collections.IMono     mono)      => this.Equals(mono);

      [GameMethod(AggressiveInlining)] public static bool        operator false(in LazyMono<T>                      lazyMono)                                                 {  lazyMono.Ensure(); return !lazyMono.lazy.hasValue; }
      [GameMethod(AggressiveInlining)] public static bool        operator true (in LazyMono<T>                      lazyMono)                                                 {  lazyMono.Ensure(); return  lazyMono.lazy.hasValue; }
      [GameMethod(AggressiveInlining)] public static bool        operator !    (in LazyMono<T>                      lazyMono)                                                 {  lazyMono.Ensure(); return !lazyMono.lazy.hasValue; }
      [GameMethod(AggressiveInlining)] public static LazyMono<T> operator +    (in LazyMono<T>                      lazyMono,  in T                                value)     => lazyMono.lazy.hasValue || null == value ? lazyMono : new(value);
      [GameMethod(AggressiveInlining)] public static bool        operator ==   (in T                                value,     in LazyMono<T>                      lazyMono)  {  lazyMono.Ensure(); return lazyMono.lazy.hasValue ? value is not null && Game.Collections.RefReadOnlyEqualityComparer<T>.Default.Equals(in value, in lazyMono.lazy.value!) : null == value; }
      [GameMethod(AggressiveInlining)] public static bool        operator ==   (Game.Collections.IMono      mono,      in LazyMono<T>                      lazyMono)  =>  mono     .Equals(lazyMono.Value);
      [GameMethod(AggressiveInlining)] public static bool        operator ==   (in Game.Collections.Mono<T> mono,      in LazyMono<T>                      lazyMono)  =>  mono     .Equals(lazyMono.Value);
      [GameMethod(AggressiveInlining)] public static bool        operator ==   (in LazyMono                     <T> lazyMono,  in T                                value)     =>  lazyMono .Equals(in value);
      [GameMethod(AggressiveInlining)] public static bool        operator ==   (in LazyMono                     <T> lazyMono,  Game.Collections.IMono      mono)      =>  lazyMono .Equals(mono);
      [GameMethod(AggressiveInlining)] public static bool        operator ==   (in LazyMono                     <T> lazyMono,  in Game.Collections.Mono<T> mono)      =>  lazyMono .Equals(in mono);
      [GameMethod(AggressiveInlining)] public static bool        operator ==   (in LazyMono                     <T> lazyMonoA, in LazyMono                     <T> lazyMonoB) =>  lazyMonoA.Equals(in lazyMonoB);
      [GameMethod(AggressiveInlining)] public static bool        operator !=   (in T                                value,     in LazyMono<T>                      lazyMono)  => !(value == lazyMono);
      [GameMethod(AggressiveInlining)] public static bool        operator !=   (Game.Collections.IMono      mono,      in LazyMono<T>                      lazyMono)  => !mono     .Equals(lazyMono.Value);
      [GameMethod(AggressiveInlining)] public static bool        operator !=   (in Game.Collections.Mono<T> mono,      in LazyMono<T>                      lazyMono)  => !mono     .Equals(lazyMono.Value);
      [GameMethod(AggressiveInlining)] public static bool        operator !=   (in LazyMono                     <T> lazyMono,  in T                                value)     => !lazyMono .Equals(in value);
      [GameMethod(AggressiveInlining)] public static bool        operator !=   (in LazyMono                     <T> lazyMono,  Game.Collections.IMono      mono)      => !lazyMono .Equals(mono);
      [GameMethod(AggressiveInlining)] public static bool        operator !=   (in LazyMono                     <T> lazyMono,  in Game.Collections.Mono<T> mono)      => !lazyMono .Equals(in mono);
      [GameMethod(AggressiveInlining)] public static bool        operator !=   (in LazyMono                     <T> lazyMonoA, in LazyMono                     <T> lazyMonoB) => !lazyMonoA.Equals(in lazyMonoB);

      [GameMethod(AggressiveInlining)] public static explicit operator T                               (in LazyMono<T> lazyMono) => lazyMono.GetValueOrDefault();
      [GameMethod(AggressiveInlining)] public static implicit operator LazyMono<T>                     (in T           value)    => new(value);
      [GameMethod(AggressiveInlining)] public static implicit operator Game.Collections.Mono<T>(in LazyMono<T> lazyMono) => new Game.Collections.Mono<T>() + lazyMono.Value;
    }

    internal struct LoadInfo : Game.Collections.IRefEquatable<LoadInfo> {
      internal object?                                                              cached  = null;
      internal Game.Collections.EventHandler<Game.Events.LoadEvent> events  = new();
      internal object?                                                              payload = null;

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)]
      public LoadInfo() {}

      /* … */
      [GameMethod(AggressiveInlining)] public          readonly bool Equals                                                         (in  LoadInfo load)  => load.events == this.events;
      [GameMethod(AggressiveInlining)] public override readonly bool Equals                                                         (object?      value) => value is LoadInfo load && this.Equals(load);
      [GameMethod(AggressiveInlining)] public override readonly int  GetHashCode                                                    ()                   => this.events.GetHashCode();
      [GameMethod(AggressiveInlining)] readonly bool                 Game.Collections.IRefEquatable<LoadInfo>.Equals        (ref LoadInfo load)  => this.Equals(in load);
      [GameMethod(AggressiveInlining)] readonly bool                 Game.Collections.IRefReadOnlyEquatable<LoadInfo>.Equals(in  LoadInfo load)  => this.Equals(in load);
      [GameMethod(AggressiveInlining)] readonly bool                 System.IEquatable<LoadInfo>.Equals                             (LoadInfo     load)  => this.Equals(load);
    }

    public /* readonly */ struct Mono<T> : /* System.DynamicObject, */ Game.Collections.IMono, Game.Collections.IRefEquatable<Mono<T>> /* ->> Based on `System.Nullable<T>` */ {
      public  readonly       bool HasValue                                =  false;
      public  /* readonly */ T    Value                                   =  default!;
      readonly bool               Game.Collections.IMono.HasValue => this.HasValue;
      readonly object?            Game.Collections.IMono.Value    => this.HasValue ? this.Value : null;

      /* … */
      [GameMethod(AggressiveInlining)] public  Mono()           {}
      [GameMethod(AggressiveInlining)] private Mono(in T value) { this.HasValue = true; this.Value = value; }

      /* … */
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                               (in T                           value)    => this.HasValue ? Game.Collections.RefReadOnlyEqualityComparer<T>.Default.Equals(in this.Value!, in value) : null == value;
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                               (Game.Collections.IMono mono)     => this.HasValue ? mono.HasValue && this.Value!.Equals(mono.Value!)                                                                        : !mono.HasValue;
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                               (in Mono<T>                     mono)     => this.HasValue ? mono.HasValue && Game.Collections.RefReadOnlyEqualityComparer<T>.Default.Equals(in this.Value!, in mono.Value!) : !mono.HasValue;
      [GameMethod(AggressiveInlining)] public override readonly bool    Equals                                                                               (object?                        value)    => null == value || value is null ? !this.HasValue : value switch { T subvalue => this.Equals(subvalue), Mono<T> mono => this.Equals(mono), Game.Collections.IMono mono => this.Equals(mono), _ => this.HasValue && this.Value!.Equals(value) };
      [GameMethod(AggressiveInlining)] public override readonly int     GetHashCode                                                                          ()                                        => this.HasValue ? this.Value!.GetHashCode() : base.GetHashCode();
      [GameMethod(AggressiveInlining)] public          readonly T       GetValueOrDefault                                                                    ()                                        => this.GetValueOrDefault(default!);
      [GameMethod(AggressiveInlining)] public          readonly T       GetValueOrDefault                                                                    (in T fallback)                           => this.HasValue ? this.Value             : fallback;
      [GameMethod(AggressiveInlining)] public override readonly string? ToString                                                                             ()                                        => this.HasValue ? this.Value!.ToString() : string.Empty;
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefEquatable<Mono<T>>.Equals                               (ref Mono<T>                        mono) => this.Equals(in mono);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefEquatable<Game.Collections.IMono>.Equals        (ref Game.Collections.IMono mono) => this.Equals(mono);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefReadOnlyEquatable<Mono<T>>.Equals                       (in  Mono<T>                        mono) => this.Equals(in mono);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefReadOnlyEquatable<Game.Collections.IMono>.Equals(in  Game.Collections.IMono mono) => this.Equals(mono);
      [GameMethod(AggressiveInlining)] readonly bool                    System.IEquatable<Mono<T>>.Equals                                                    (Mono<T>                            mono) => this.Equals(mono);
      [GameMethod(AggressiveInlining)] readonly bool                    System.IEquatable<Game.Collections.IMono>.Equals                             (Game.Collections.IMono     mono) => this.Equals(mono);

      [GameMethod(AggressiveInlining)] public static bool    operator false(in Mono<T>                     mono)                                        => !mono .HasValue;
      [GameMethod(AggressiveInlining)] public static bool    operator true (in Mono<T>                     mono)                                        =>  mono .HasValue;
      [GameMethod(AggressiveInlining)] public static bool    operator !    (in Mono<T>                     mono)                                        => !mono .HasValue;
      [GameMethod(AggressiveInlining)] public static Mono<T> operator +    (in Mono<T>                     mono,  in T                           value) =>  mono .HasValue || null == value ? mono : new(value);
      [GameMethod(AggressiveInlining)] public static bool    operator ==   (in T                           value, in Mono<T>                     mono)  =>  mono .HasValue ? value is not null && Game.Collections.RefReadOnlyEqualityComparer<T>.Default.Equals(in value, in mono.Value!) : null == value;
      [GameMethod(AggressiveInlining)] public static bool    operator ==   (Game.Collections.IMono monoA, in Mono<T>                     monoB) =>  monoA.Equals(monoB);
      [GameMethod(AggressiveInlining)] public static bool    operator ==   (in Mono<T>                     mono,  in T                           value) =>  mono .Equals(in value);
      [GameMethod(AggressiveInlining)] public static bool    operator ==   (in Mono<T>                     monoA, Game.Collections.IMono monoB) =>  monoA.Equals(monoB);
      [GameMethod(AggressiveInlining)] public static bool    operator ==   (in Mono<T>                     monoA, in Mono<T>                     monoB) =>  monoA.Equals(in monoB);
      [GameMethod(AggressiveInlining)] public static bool    operator !=   (in T                           value, in Mono<T>                     mono)  => !(value == mono);
      [GameMethod(AggressiveInlining)] public static bool    operator !=   (Game.Collections.IMono monoA, in Mono<T>                     monoB) => !monoA.Equals(monoB);
      [GameMethod(AggressiveInlining)] public static bool    operator !=   (in Mono<T>                     mono,  in T                           value) => !mono .Equals(in value);
      [GameMethod(AggressiveInlining)] public static bool    operator !=   (in Mono<T>                     monoA, Game.Collections.IMono monoB) => !monoA.Equals(monoB);
      [GameMethod(AggressiveInlining)] public static bool    operator !=   (in Mono<T>                     monoA, in Mono<T>                     monoB) => !monoA.Equals(in monoB);

      [GameMethod(AggressiveInlining)] public static explicit operator T      (in Mono<T> mono)  => mono.GetValueOrDefault();
      [GameMethod(AggressiveInlining)] public static implicit operator Mono<T>(in T       value) => new(value);
    }

    public struct PointedInfo : Game.Collections.IRefEquatable<PointedInfo> {
      private static readonly Game.Collections.RefList<Game.Collections.PointerInfo> DefaultPointersList = new(2u);

      public            double                                                                         epoch   { get; internal set; } =  UnityEngine.Time.realtimeSinceStartupAsDouble;
      public            UnityEngine.UI.Graphic                                                         graphic { get; internal set; } =  null!;
      public   readonly Game.Collections.RefReadOnlyList<Game.Collections.PointerInfo> pointers                       => (Game.Collections.RefReadOnlyList<Game.Collections.PointerInfo>) this.pointersList;
      internal          Game.Collections.RefList        <Game.Collections.PointerInfo> pointersList                   =  PointedInfo.DefaultPointersList;
      public   readonly Game.Collections.DeviceState                                           pointerState { get { Game.Collections.DeviceState state = Game.Collections.DeviceState.UNKNOWN; foreach (ref readonly Game.Collections.PointerInfo pointer in this.pointersList) { state = pointer.state < state ? pointer.state : state; } return state; } }
      public            Game.Collections.DeviceState                                           state        { get; internal set; } = Game.Collections.DeviceState.UNKNOWN;

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)]
      public PointedInfo() {}

      /* … */
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                            (in PointedInfo pointed)  { PointedInfo subpointed = pointed; return subpointed.graphic == this.graphic && subpointed.pointersList.Count == this.pointersList.Count && subpointed.state == this.state && (subpointed.pointersList == this.pointersList || this.pointersList.TrueForAll((in Game.Collections.PointerInfo pointer) => subpointed.pointersList.Exists((Game.RefReadOnlyPredicate<Game.Collections.PointerInfo>) pointer.Equals))); }
      [GameMethod(AggressiveInlining)] public override readonly bool    Equals                                                            (object?        value)    => value is PointedInfo pointed && this.Equals(pointed);
      [GameMethod(AggressiveInlining)] public override readonly int     GetHashCode                                                       ()                        => System.HashCode.Combine(this.graphic, this.pointersList, this.state);
      [GameMethod(AggressiveInlining)] public          readonly bool    IsClicking                                                        ()                        { uint count = this.pointersList.Count; for (uint index = count; 0u != index--; ) { ref readonly Game.Collections.PointerInfo pointer = ref this.pointersList[index]; if (Util.Pointers.IsId(pointer.id)) { --count; continue; } if (!pointer.IsClicking()) return false; } return 0u != count; }
      [GameMethod(AggressiveInlining)] public          readonly bool    IsPointing                                                        ()                        { uint count = this.pointersList.Count; for (uint index = count; 0u != index--; ) { ref readonly Game.Collections.PointerInfo pointer = ref this.pointersList[index];                                                            if ( pointer.IsPointing()) return true; }  return false; }
      [GameMethod(AggressiveInlining)] public override readonly string? ToString                                                          ()                        => $"({(Game.Collections.DeviceState.BEGIN == this.state ? "↓" : Game.Collections.DeviceState.CURRENT == this.state ? "―" : Game.Collections.DeviceState.END == this.state ? "↑" : "…")}) {(this.IsClicking() ? "🖱️" : this.IsPointing() ? "👆" : "🖐️")} [{this.graphic}]";
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefEquatable<PointedInfo>.Equals        (ref PointedInfo pointed) => this.Equals(in pointed);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefReadOnlyEquatable<PointedInfo>.Equals(in  PointedInfo pointed) => this.Equals(in pointed);
      [GameMethod(AggressiveInlining)] readonly bool                    System.IEquatable<PointedInfo>.Equals                             (PointedInfo     pointed) => this.Equals(pointed);
    }

    public struct PointerInfo : Game.Collections.InputInfo, Game.Collections.IRefEquatable<PointerInfo> {
      public   readonly UnityEngine.Vector2                  delta                                   => this.position - this.origin;
      public            UnityEngine.InputSystem.InputDevice? device   { get; internal set; }         =  null;
      public            double                               epoch    { get; internal set; }         =  UnityEngine.Time.realtimeSinceStartupAsDouble;
      public            long                                 id       { get; internal set; }         =  Util.Pointers.MakeId();
      public            bool                                 inverted { get; internal set; }         =  false;
      public            UnityEngine.Vector2                  origin   { get; internal set; }         =  UnityEngine.Vector2.zero;
      internal          bool                                 polled                                  =  false;
      public            UnityEngine.Vector2                  position         { get; internal set; } =  UnityEngine.Vector2.zero;
      public            UnityEngine.Vector2                  positionPrevious { get; internal set; } =  UnityEngine.Vector2.zero; // ->> Unique `::position` previous `UnityEngine.MonoBehaviour::Update()` frame
      public            UnityEngine.Vector2                  positionRecent   { get; internal set; } =  UnityEngine.Vector2.zero; // ->> Either `::position` or `::positionPrevious`
      public            float                                pressure         { get; internal set; } =  0.0f;
      public            float                                previousX { get => this.positionPrevious.x; set => this.positionPrevious = new(value, this.positionPrevious.y); }
      public            float                                previousY { get => this.positionPrevious.y; set => this.positionPrevious = new(this.positionPrevious.x, value); }
      public            UnityEngine.Vector2                  radius { get; internal set; } = UnityEngine.Vector2.zero;
      public            float                                recentX { get => this.positionRecent.x; set => this.positionRecent = new(value, this.positionRecent.y); }
      public            float                                recentY { get => this.positionRecent.y; set => this.positionRecent = new(this.positionRecent.x, value); }
      public            uint                                 sequenced { get; internal set; } = 0u;
      public            Game.Collections.DeviceState state     { get; internal set; } = Game.Collections.DeviceState.UNKNOWN;
      public            float                                x { get => this.position.x; set => this.position = new(value, this.position.y); }
      public            float                                y { get => this.position.y; set => this.position = new(this.position.x, value); }
      UnityEngine.InputSystem.InputDevice?                   Game.Collections.InputInfo.device { get => this.device; set => this.device = value; }
      double                                                 Game.Collections.InputInfo.epoch  { get => this.epoch;  set => this.epoch  = value; }
      long                                                   Game.Collections.InputInfo.id     { get => this.id;     set => this.id     = value; }
      bool                                                   Game.Collections.InputInfo.polled { get => this.polled; set => this.polled = value; }
      Game.Collections.DeviceState                   Game.Collections.InputInfo.state  { get => this.state;  set => this.state  = value; }

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)]
      public PointerInfo() {}

      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                   (in PointerInfo                     pointer)     => pointer.origin == this.origin && pointer.position == this.position;
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                   (Game.Collections.InputInfo input)       => input is PointerInfo pointer && this.Equals(pointer);
      [GameMethod(AggressiveInlining)] public override readonly bool    Equals                                                                                   (object?                            value)       => value is PointerInfo pointer && this.Equals(pointer);
      [GameMethod(AggressiveInlining)] public override readonly int     GetHashCode                                                                              ()                                               => System.HashCode.Combine(this.id, this.origin.x, this.origin.y, this.position.x, this.position.y);
      [GameMethod(AggressiveInlining)] public          readonly bool    IsClicking                                                                               ()                                               => this.IsPointing() && Game.Collections.DeviceState.END == this.state;
      [GameMethod(AggressiveInlining)] public          readonly bool    IsDragging                                                                               ()                                               => this.position == this.origin;
      [GameMethod(AggressiveInlining)] public          readonly bool    IsMoving                                                                                 ()                                               => this.position != this.positionRecent;
      [GameMethod(AggressiveInlining)] public          readonly bool    IsPointing                                                                               ()                                               => this.id != Util.Pointers.MakeId();
      [GameMethod(AggressiveInlining)] public override readonly string? ToString                                                                                 ()                                               => $"({(Game.Collections.DeviceState.BEGIN == this.state ? "↓" : Game.Collections.DeviceState.CURRENT == this.state ? "―" : Game.Collections.DeviceState.END == this.state ? "↑" : "…")}) {(Util.Pointers.IsId(this.id) ? "…" : Util.Pointers.IsMouseId(this.id) ? "🖱️" : Util.Pointers.IsPenId(this.id) ? "🖊️" : Util.Pointers.IsEnhancedTouchId(this.id) ? "🧤" : Util.Pointers.IsTouchId(this.id) ? "👆" : "…")} [{this.origin.x.ToString("0.##")} → {this.position.x.ToString("0.##")}, {this.origin.y.ToString("0.##")} → {this.position.y.ToString("0.##")}]";
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefEquatable<PointerInfo>.Equals                               (ref PointerInfo                        pointer) => this.Equals(in pointer);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefEquatable<Game.Collections.InputInfo>.Equals        (ref Game.Collections.InputInfo input)   => this.Equals(input);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefReadOnlyEquatable<PointerInfo>.Equals                       (in  PointerInfo                        pointer) => this.Equals(in pointer);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefReadOnlyEquatable<Game.Collections.InputInfo>.Equals(in  Game.Collections.InputInfo input)   => this.Equals(input);
      [GameMethod(AggressiveInlining)] readonly bool                    System.IEquatable<PointerInfo>.Equals                                                    (PointerInfo                            pointer) => this.Equals(pointer);
      [GameMethod(AggressiveInlining)] readonly bool                    System.IEquatable<Game.Collections.InputInfo>.Equals                             (Game.Collections.InputInfo     input)   => this.Equals(input);
    }

    public readonly struct Proxy<T> {
      public T Value;
      // operator +();
    }
    public class ProxyObject<T> : System.Dynamic.DynamicObject {
      private readonly Game.Referrer<T> Referrer;
      public           ref T            Value { [GameMethod(AggressiveInlining)] get => ref this.Referrer(); }

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)]
      public Proxy(Game.Referrer<T> referrer) : base() => this.Referrer = referrer;

      /* … */
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, byte              valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, decimal           valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, double            valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, float             valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, int               valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, long              valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, nint              valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, nuint             valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, sbyte             valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, short             valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, string            valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, uint              valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, ulong             valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, ushort            valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, in System.IntPtr  valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(in byte valueA, in System.UIntPtr valueB, out object? value) { value = valueA + valueB; return true; }
      [GameMethod(AggressiveInlining)] public static bool Add(object? valueA, object?           valueB, out object? value) {
        if (valueA is not null) {
          System.Reflection.MethodInfo[] methods = valueA.GetType().GetMethods(System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
          System.Type type = valueB?.GetType() ?? typeof(object?);
          methods.ConvertAll([GameMethod(AggressiveInlining)] static (method) => {
            System.Reflection.ParameterInfo[] parameters = method.GetParameters();
            if (method.Name == "op_Addition" && parameters.Length == 2) {
              (System.Type typeA)
              Util.Array.At(parameters, 0u).ParameterType.IsByRef ? Util.Array.At(parameters, 0u).ParameterType.GetElementType() : Util.Array.At(parameters, 0u).ParameterType

              if (typeof(T) == Util.Array.At(parameters, 0u).ParameterType && typeof(T) == Util.Array.At(parameters, 1u).ParameterType) return 4u;
              if (typeof(T) == Util.Array.At(parameters, 0u).ParameterType) return 4u;
              SAME    SAME
              SAME    SIMILAR
              SIMILAR SAME
              SIMILAR SIMILAR

              typeof(T) == Util.Array.At(parameters, 0u).ParameterType
              Util.Array.At(parameters, 0u).ParameterType.IsAssignableFrom(typeof(T))
              // if ()
              // typeof(Game.Collections.IRefComparable<T>).IsAssignableFrom(typeof(T))

              // if (valueB is null)
              // typeof(object?)

              return 1u;
            }

            return 0u;
          });

          valueA.GetType().GetMethods("op_Addition", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static, new[] {
            valueA.GetType(),
            valueB.GetType() ?? typeof(object?)
          })
        }
        System.Reflection.MethodInfo
        valueB
        additionMethod.Name == "op_Addition"
        value = null;
        return false;
      }

      [GameMethod(AggressiveInlining)]
      public virtual bool TryBinaryOperation(System.Dynamic.BinaryOperationBinder binder, object operand, out object? value) {
        if (value is null)                            ;
        if (value is bool    boolean)                 ;
        if (value is byte    bits && recursive)       ;
        if (value is decimal numberA)                 ;
        if (value is double  numberB)                 ;
        if (value is float   numberC)                 ;
        if (value is int  or nint or sbyte or short)  ;
        if (value is long)                            ;
        if (value is nuint or uint or ushort) ;
        if (value is ulong)                           ;
        if (value is System.DateTime)                 ;
        if (value is System.Enum)                     ;
        if (value is System.Exception)                ;
        if (value is System.Index   subindex)         ;
        if (value is System.IntPtr  pointerA)         ;
        if (value is System.Range   range)            ;
        if (value is System.Type    type)             ;
        if (value is System.UIntPtr pointerB)         ;
        if (value is System.Uri     uri)              ;
        if (value is System.Runtime.CompilerServices.ITuple) {}
        if (value is System.Collections.IEnumerable) {}
        if (value is string) {}
        switch (binder.Operation) {
          case System.Linq.Expressions.ExpressionType.Add:                return operand is byte bits ? Proxy<T>.Add(in this.Value, bits, out value) : Proxy<T>.Add(ref this.Value, operand, out value);
          case System.Linq.Expressions.ExpressionType.AddAssign:          return false; break; // a += b
          case System.Linq.Expressions.ExpressionType.And:                return false; break; // a & b
          case System.Linq.Expressions.ExpressionType.AndAssign:          return false; break; // a &= b
          case System.Linq.Expressions.ExpressionType.Divide:             return false; break; // a / b
          case System.Linq.Expressions.ExpressionType.DivideAssign:       return false; break; // a /= b
          case System.Linq.Expressions.ExpressionType.ExclusiveOr:        return false; break; // a ^ b
          case System.Linq.Expressions.ExpressionType.ExclusiveOrAssign:  return false; break; // a ^= b
          case System.Linq.Expressions.ExpressionType.GreaterThan:        return false; break; // a > b
          case System.Linq.Expressions.ExpressionType.GreaterThanOrEqual: return false; break; // a >= b
          case System.Linq.Expressions.ExpressionType.LeftShift:          return false; break; // a << b
          case System.Linq.Expressions.ExpressionType.LeftShiftAssign:    return false; break; // a <<= b
          case System.Linq.Expressions.ExpressionType.LessThan:           return false; break; // a < b
          case System.Linq.Expressions.ExpressionType.LessThanOrEqual:    return false; break; // a <= b
          case System.Linq.Expressions.ExpressionType.Modulo:             return false; break; // a % b
          case System.Linq.Expressions.ExpressionType.ModuloAssign:       return false; break; // a %= b
          case System.Linq.Expressions.ExpressionType.Multiply:           return false; break; // a * b
          case System.Linq.Expressions.ExpressionType.MultiplyAssign:     return false; break; // a *= b
          case System.Linq.Expressions.ExpressionType.NotEqual:           return false; break; // a != b
          case System.Linq.Expressions.ExpressionType.Or:                 return false; break; // a | b
          case System.Linq.Expressions.ExpressionType.OrAssign:           return false; break; // a |= b
          case System.Linq.Expressions.ExpressionType.Power:              return false; break; // a ^ b
          case System.Linq.Expressions.ExpressionType.RightShift:         return false; break; // a >> b
          case System.Linq.Expressions.ExpressionType.RightShiftAssign:   return false; break; // a >>= b
          case System.Linq.Expressions.ExpressionType.Subtract:           return false; break; // a - b
          case System.Linq.Expressions.ExpressionType.SubtractAssign:     return false; break; // a -= b
        }

        return false;
      }

      [GameMethod(AggressiveInlining)]
      public static implicit operator T(in Proxy<T> proxy) => proxy.referrer();
    }

    public /* sealed */ class RefComparer<T> : Game.Collections.RefReadOnlyComparer<T>, Game.Collections.IRefComparer<T> {
      private readonly struct Sentinel : Game.Collections.IRefComparable<Sentinel> {
        int Game.Collections.IRefComparable<Sentinel>.CompareTo        (ref Sentinel value) => default;
        int Game.Collections.IRefReadOnlyComparable<Sentinel>.CompareTo(in  Sentinel value) => default;
        int System.IComparable.CompareTo                                       (object?      value) => default;
        int System.IComparable<Sentinel>.CompareTo                             (Sentinel     value) => default;
      }

      /* … */
      private static readonly Game.RefComparison<T> CompareValue = (Game.RefComparison<T>) (
        typeof(Game.Collections.IRefComparable        <T>).IsAssignableFrom(typeof(T)) ? ((Game.RefComparison<RefComparer<T>.Sentinel>) RefComparer<RefComparer<T>.Sentinel>.RefComparableCompare)        .Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.RefComparison<T>)) :
        typeof(Game.Collections.IRefReadOnlyComparable<T>).IsAssignableFrom(typeof(T)) ? ((Game.RefComparison<RefComparer<T>.Sentinel>) RefComparer<RefComparer<T>.Sentinel>.RefReadOnlyComparableCompare).Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.RefComparison<T>)) :
        typeof(System.IComparable                             <T>).IsAssignableFrom(typeof(T)) ? ((Game.RefComparison<RefComparer<T>.Sentinel>) RefComparer<RefComparer<T>.Sentinel>.ComparableCompare)           .Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.RefComparison<T>)) :
        typeof(System.IComparable)                                .IsAssignableFrom(typeof(T)) ? ((Game.RefComparison<RefComparer<T>.Sentinel>) RefComparer<RefComparer<T>.Sentinel>.ComparableCompare2)          .Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.RefComparison<T>)) :
        (Game.RefComparison<T>) RefComparer<T>.ObjectCompare<T>
      );
      protected        new readonly Game.RefComparison<T> comparison       = RefComparer<T>.CompareValue;
      public    static new          RefComparer               <T> Default { get; } = new();

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)] public    RefComparer()                                                 : base()           {}
      [GameConstructor, GameMethod(AggressiveInlining)] protected RefComparer(Game.RefComparison        <T> comparison) : base()           => this.comparison = comparison;
      [GameConstructor, GameMethod(AggressiveInlining)] protected RefComparer(Game.RefReadOnlyComparison<T> comparison) : base(comparison) {}

      /* … */
      [GameMethod(AggressiveInlining)] private          static int            ComparableCompare <U>                                   (ref U                                 a, ref U b) where U : System.IComparable<U>                                => a .CompareTo(b);
      [GameMethod(AggressiveInlining)] private          static int            ComparableCompare2<U>                                   (ref U                                 a, ref U b) where U : System.IComparable                                   => a!.CompareTo(b);
      [GameMethod(AggressiveInlining)] public  virtual         int            Compare                                                 (ref T                                 a, ref T b)                                                                { if (RefComparer<T>.CompareValue == this.comparison) { if (Game.Collections.RefEqualityComparer<T>.Default.Equals(ref a, ref b)) return 0; if (a is null) return b is null ? 0 : -1; if (b is null) return a is null ? 0 : +1; } return this.comparison(ref a, ref b); }
      [GameMethod(AggressiveInlining)] public  override        int            Compare                                                 (T                                     a, T     b)                                                                => this.Compare(ref a, ref b);
      [GameMethod(AggressiveInlining)] public           static RefComparer<T> Create                                                  (Game.RefComparison        <T> comparison)                                                                => new(comparison);
      [GameMethod(AggressiveInlining)] public  new      static RefComparer<T> Create                                                  (Game.RefReadOnlyComparison<T> comparison)                                                                => new(comparison);
      [GameMethod(AggressiveInlining)] private          static int            ObjectCompare               <U>                         (ref U                                 a, ref U   b)                                                              => System.Collections.Comparer.Default.Compare(a, b);
      [GameMethod(AggressiveInlining)] private          static int            RefComparableCompare        <U>                         (ref U                                 a, ref U   b) where U : Game.Collections.IRefComparable        <U> => a.CompareTo(ref b);
      [GameMethod(AggressiveInlining)] private          static int            RefReadOnlyComparableCompare<U>                         (ref U                                 a, ref U   b) where U : Game.Collections.IRefReadOnlyComparable<U> => a.CompareTo(in  b);
      [GameMethod(NoInlining)]         private                 int            RefReadOnlyCompare                                      (in  T                                 a, in  T   b)                                                              { if (RefComparer<T>.CompareValue != this.comparison) throw new System.NotSupportedException("Reference comparer can not compare as modifiable references"); return base.Compare(in a, in b); }
      [GameMethod(AggressiveInlining)] int                                    Game.Collections.IRefComparer<T>.Compare        (ref T                                 a, ref T   b)                                                              => this.Compare           (ref a, ref b);
      [GameMethod(AggressiveInlining)] int                                    Game.Collections.IRefReadOnlyComparer<T>.Compare(in  T                                 a, in  T   b)                                                              => this.RefReadOnlyCompare(in  a, in  b);
      [GameMethod(AggressiveInlining)] int                                    System.Collections.Generic.IComparer<T>.Compare         (T?                                    a, T?      b)                                                              { T aa = (T) a!, bb = (T) b!; return this.Compare(ref aa, ref bb); }
      [GameMethod(AggressiveInlining)] int                                    System.Collections.IComparer.Compare                    (object?                               a, object? b)                                                              { T aa = (T) a!, bb = (T) b!; return this.Compare(ref aa, ref bb); }
    }

    [System.Serializable]
    public class RefDictionary<TKey, TValue> : Game.Collections.RefReadOnlyDictionary<TKey, TValue>, Game.Collections.IRefEquatable<RefDictionary<TKey, TValue>>, System.Collections.Generic.ICollection<Game.Collections.RefKeyValuePair<TKey, TValue>>, System.Collections.Generic.IDictionary<TKey, TValue>, System.Collections.ICollection, System.Collections.IDictionary {
      public new readonly struct AlternateLookup<TAlternateKey> {
        public readonly RefDictionary<TKey, TValue> Dictionary;

        /* … */
        [GameMethod(AggressiveInlining)]
        internal AlternateLookup(RefDictionary<TKey, TValue> dictionary) => this.Dictionary = dictionary;

        /* … */
        [GameMethod(AggressiveInlining)] public readonly bool ContainsKey(in TAlternateKey key)                                         => false;
        [GameMethod(AggressiveInlining)] public readonly bool Remove     (in TAlternateKey key)                                         => false;
        [GameMethod(AggressiveInlining)] public readonly bool Remove     (in TAlternateKey key, out TKey   actualKey, out TValue value) { actualKey = default!; value = default!; return false; }
        [GameMethod(AggressiveInlining)] public readonly bool TryAdd     (in TAlternateKey key, in TValue  value)                       => false;
        [GameMethod(AggressiveInlining)] public readonly bool TryGetValue(in TAlternateKey key, out TValue value)                       {                       value = default!; return false; }
        [GameMethod(AggressiveInlining)] public readonly bool TryGetValue(in TAlternateKey key, out TKey   actualKey, out TValue value) { actualKey = default!; value = default!; return false; }

        public readonly ref TValue this[in TAlternateKey key] => ref Util.Reference<TValue>.Null;
      }

      public new readonly struct Enumerator : System.Collections.Generic.IEnumerator<Game.Collections.RefKeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerator<Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IDictionaryEnumerator {
        public  readonly Game.Collections.RefKeyValuePair<TKey, TValue>                  Current                                                                                                        => new(this.enumerator.Current);
        private readonly Game.Collections.RefReadOnlyDictionary<TKey, TValue>.Enumerator enumerator                                                                                                     =  default;
        readonly Game.Collections.RefKeyValuePair        <TKey, TValue>                  System.Collections.Generic.IEnumerator<Game.Collections.RefKeyValuePair<TKey, TValue>>.Current         => this           .Current;
        readonly Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>                  System.Collections.Generic.IEnumerator<Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>>.Current => this.enumerator.Current;
        readonly System.Collections.Generic.KeyValuePair         <TKey, TValue>                  System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Current          => ((System.Collections.Generic.KeyValuePair<TKey, TValue>) this.Current);
        readonly System.Collections.DictionaryEntry                                              System.Collections.IDictionaryEnumerator.Entry                                                                 => ((this.enumerator as System.Collections.IDictionaryEnumerator)!.Entry);
        readonly object                                                                          System.Collections.IDictionaryEnumerator.Key                                                                   => ((this.enumerator as System.Collections.IDictionaryEnumerator)!.Key);
        readonly object?                                                                         System.Collections.IDictionaryEnumerator.Value                                                                 => ((this.enumerator as System.Collections.IDictionaryEnumerator)!.Value);
        readonly object                                                                          System.Collections.IEnumerator.Current                                                                         => this.Current;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        public Enumerator(RefDictionary<TKey, TValue> dictionary) => this.enumerator = ((Game.Collections.RefReadOnlyDictionary<TKey, TValue>) dictionary).GetEnumerator();

        /* … */
        [GameMethod(AggressiveInlining)] public readonly void Dispose                                () => this.enumerator.Dispose ();
        [GameMethod(AggressiveInlining)] public readonly bool MoveNext                               () => this.enumerator.MoveNext();
        [GameMethod(AggressiveInlining)] public readonly void Reset                                  () => this.enumerator.Reset   ();
        [GameMethod(AggressiveInlining)] readonly bool        System.Collections.IEnumerator.MoveNext() => this           .MoveNext();
        [GameMethod(AggressiveInlining)] readonly void        System.Collections.IEnumerator.Reset   () => this           .Reset   ();
        [GameMethod(AggressiveInlining)] readonly void        System.IDisposable.Dispose             () => this           .Dispose ();

        [GameMethod(AggressiveInlining)]
        public static implicit operator Game.Collections.RefReadOnlyDictionary<TKey, TValue>.Enumerator(in Enumerator enumerator) => enumerator.enumerator;
      }

      public new /* sealed */ class KeyCollection : Game.Collections.RefReadOnlyDictionary<TKey, TValue>.KeyCollection, System.Collections.Generic.ICollection<TKey>, System.Collections.Generic.IReadOnlyCollection<TKey>, System.Collections.ICollection {
        public new readonly struct Enumerator : System.Collections.Generic.IEnumerator<TKey> {
          public  readonly ref readonly TKey                      Current                                              => ref this.enumerator.Current.Key;
          private readonly RefDictionary<TKey, TValue>.Enumerator enumerator                                           =  default;
          readonly TKey                                           System.Collections.Generic.IEnumerator<TKey>.Current => this.Current;
          readonly object                                         System.Collections.IEnumerator.Current               => this.Current!;

          /* … */
          [GameConstructor, GameMethod(AggressiveInlining)]
          internal Enumerator(in RefDictionary<TKey, TValue>.Enumerator enumerator) => this.enumerator = enumerator;

          /* … */
          [GameMethod(AggressiveInlining)] public readonly void Dispose                                () => this.enumerator.Dispose ();
          [GameMethod(AggressiveInlining)] public readonly bool MoveNext                               () => this.enumerator.MoveNext();
          [GameMethod(AggressiveInlining)] public readonly void Reset                                  () => this.enumerator.Reset   ();
          [GameMethod(AggressiveInlining)] readonly bool        System.Collections.IEnumerator.MoveNext() => this           .MoveNext();
          [GameMethod(AggressiveInlining)] readonly void        System.Collections.IEnumerator.Reset   () => this           .Reset   ();
          [GameMethod(AggressiveInlining)] readonly void        System.IDisposable.Dispose             () => this           .Dispose ();

          [GameMethod(AggressiveInlining)]
          public static implicit operator Game.Collections.RefReadOnlyDictionary<TKey, TValue>.KeyCollection.Enumerator(in Enumerator enumerator) => new((Game.Collections.RefReadOnlyDictionary<TKey, TValue>.Enumerator) enumerator.enumerator);
        }

        /* … */
        private RefDictionary<TKey, TValue> dictionary                                                 =  default!;
        bool                                System.Collections.Generic.ICollection<TKey>.IsReadOnly    => true;
        int                                 System.Collections.Generic.ICollection<TKey>.Count         => ((int) base.Count);
        int                                 System.Collections.Generic.IReadOnlyCollection<TKey>.Count => ((int) base.Count);
        int                                 System.Collections.ICollection.Count                       => ((int) base.Count);
        bool                                System.Collections.ICollection.IsSynchronized              => false;
        object                              System.Collections.ICollection.SyncRoot                    => this;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        public KeyCollection(RefDictionary<TKey, TValue> dictionary) : base((Game.Collections.RefReadOnlyDictionary<TKey, TValue>) dictionary) => this.dictionary = dictionary;

        /* … */
        [GameMethod(AggressiveInlining)] public new KeyCollection.Enumerator          GetEnumerator                                             ()                              => new(this.dictionary.GetEnumerator());
        [GameMethod(NoInlining)]         void                                         System.Collections.Generic.ICollection<TKey>.Add          (TKey element)                  => throw new System.NotSupportedException("Dictionary key collection is read-only");
        [GameMethod(NoInlining)]         void                                         System.Collections.Generic.ICollection<TKey>.Clear        ()                              => throw new System.NotSupportedException("Dictionary key collection is read-only");
        [GameMethod(AggressiveInlining)] bool                                         System.Collections.Generic.ICollection<TKey>.Contains     (TKey   element)                => base.Contains(in element);
        [GameMethod(AggressiveInlining)] void                                         System.Collections.Generic.ICollection<TKey>.CopyTo       (TKey[] array, int index)       => base.CopyTo  (array, (uint) index);
        [GameMethod(NoInlining)]         bool                                         System.Collections.Generic.ICollection<TKey>.Remove       (TKey   element)                => throw new System.NotSupportedException("Dictionary key collection is read-only");
        [GameMethod(AggressiveInlining)] System.Collections.Generic.IEnumerator<TKey> System.Collections.Generic.IEnumerable<TKey>.GetEnumerator()                              => this.GetEnumerator();
        [GameMethod(AggressiveInlining)] void                                         System.Collections.ICollection.CopyTo                     (System.Array array, int index) { foreach (ref readonly TKey element in this) array.SetValue(element, index++); }
        [GameMethod(AggressiveInlining)] System.Collections.IEnumerator               System.Collections.IEnumerable.GetEnumerator              ()                              => this.GetEnumerator();
      }

      public new /* sealed */ class ValueCollection : Game.Collections.RefReadOnlyDictionary<TKey, TValue>.ValueCollection, System.Collections.Generic.ICollection<TValue>, System.Collections.Generic.IReadOnlyCollection<TValue>, System.Collections.ICollection {
        public new readonly struct Enumerator : System.Collections.Generic.IEnumerator<TValue> {
          public  readonly ref TValue                             Current                                                => ref this.enumerator.Current.Value;
          private readonly RefDictionary<TKey, TValue>.Enumerator enumerator                                             =  default;
          readonly TValue                                         System.Collections.Generic.IEnumerator<TValue>.Current => this.Current;
          readonly object                                         System.Collections.IEnumerator.Current                 => this.Current!;

          /* … */
          [GameConstructor, GameMethod(AggressiveInlining)]
          internal Enumerator(in RefDictionary<TKey, TValue>.Enumerator enumerator) => this.enumerator = enumerator;

          /* … */
          [GameMethod(AggressiveInlining)] public readonly void Dispose                                () => this.enumerator.Dispose ();
          [GameMethod(AggressiveInlining)] public readonly bool MoveNext                               () => this.enumerator.MoveNext();
          [GameMethod(AggressiveInlining)] public readonly void Reset                                  () => this.enumerator.Reset   ();
          [GameMethod(AggressiveInlining)] readonly bool        System.Collections.IEnumerator.MoveNext() => this           .MoveNext();
          [GameMethod(AggressiveInlining)] readonly void        System.Collections.IEnumerator.Reset   () => this           .Reset   ();
          [GameMethod(AggressiveInlining)] readonly void        System.IDisposable.Dispose             () => this           .Dispose ();

          [GameMethod(AggressiveInlining)]
          public static implicit operator Game.Collections.RefReadOnlyDictionary<TKey, TValue>.ValueCollection.Enumerator(in Enumerator enumerator) => new((Game.Collections.RefReadOnlyDictionary<TKey, TValue>.Enumerator) enumerator.enumerator);
        }

        /* … */
        private RefDictionary<TKey, TValue> dictionary                                                   =  default!;
        bool                                System.Collections.Generic.ICollection<TValue>.IsReadOnly    => true;
        int                                 System.Collections.Generic.ICollection<TValue>.Count         => ((int) base.Count);
        int                                 System.Collections.Generic.IReadOnlyCollection<TValue>.Count => ((int) base.Count);
        int                                 System.Collections.ICollection.Count                         => ((int) base.Count);
        bool                                System.Collections.ICollection.IsSynchronized                => false;
        object                              System.Collections.ICollection.SyncRoot                      => this;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        public ValueCollection(RefDictionary<TKey, TValue> dictionary) : base((Game.Collections.RefReadOnlyDictionary<TKey, TValue>) dictionary) => this.dictionary = dictionary;

        /* … */
        [GameMethod(AggressiveInlining)] public new ValueCollection.Enumerator          GetEnumerator                                               ()                              => new(this.dictionary.GetEnumerator());
        [GameMethod(NoInlining)]         void                                           System.Collections.Generic.ICollection<TValue>.Add          (TValue element)                => throw new System.NotSupportedException("Dictionary value collection is read-only");
        [GameMethod(NoInlining)]         void                                           System.Collections.Generic.ICollection<TValue>.Clear        ()                              => throw new System.NotSupportedException("Dictionary value collection is read-only");
        [GameMethod(AggressiveInlining)] bool                                           System.Collections.Generic.ICollection<TValue>.Contains     (TValue   element)              { foreach (ref readonly TValue _ in this) { if (Game.Collections.RefReadOnlyEqualityComparer<TValue>.Default.Equals(in _, element)) return true; } return false; }
        [GameMethod(AggressiveInlining)] void                                           System.Collections.Generic.ICollection<TValue>.CopyTo       (TValue[] array, int index)     => base.CopyTo(array, (uint) index);
        [GameMethod(NoInlining)]         bool                                           System.Collections.Generic.ICollection<TValue>.Remove       (TValue   element)              => throw new System.NotSupportedException("Dictionary value collection is read-only");
        [GameMethod(AggressiveInlining)] System.Collections.Generic.IEnumerator<TValue> System.Collections.Generic.IEnumerable<TValue>.GetEnumerator()                              => this.GetEnumerator();
        [GameMethod(AggressiveInlining)] void                                           System.Collections.ICollection.CopyTo                       (System.Array array, int index) { foreach (ref readonly TValue element in this) array.SetValue(element, index++); }
        [GameMethod(AggressiveInlining)] System.Collections.IEnumerator                 System.Collections.IEnumerable.GetEnumerator                ()                              => this.GetEnumerator();
      }

      /* … */
      [UnityEngine.HideInInspector]                             public  new          RefDictionary<TKey, TValue>.KeyCollection   Keys   => new(this);
      [UnityEngine.HideInInspector, UnityEngine.SerializeField] private new readonly Game.Collections.RefList<TKey>      keys   =  new();
      [UnityEngine.HideInInspector]                             public  new          RefDictionary<TKey, TValue>.ValueCollection Values => new(this);
      [UnityEngine.HideInInspector, UnityEngine.SerializeField] private new readonly Game.Collections.RefList<TValue>    values =  new();
      bool                                                                                                                       System.Collections.Generic.ICollection<Game.Collections.RefKeyValuePair<TKey, TValue>>.IsReadOnly => false;
      int                                                                                                                        System.Collections.Generic.ICollection<Game.Collections.RefKeyValuePair<TKey, TValue>>.Count      => ((int) base.Count);
      bool                                                                                                                       System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.IsReadOnly  => false;
      int                                                                                                                        System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Count       => ((int) base.Count);
      System.Collections.Generic.ICollection<TKey>                                                                               System.Collections.Generic.IDictionary<TKey, TValue>.Keys                                                 => this.Keys;
      System.Collections.Generic.ICollection<TValue>                                                                             System.Collections.Generic.IDictionary<TKey, TValue>.Values                                               => this.Values;
      int                                                                                                                        System.Collections.ICollection.Count                                                                      => ((int) base.Count);
      bool                                                                                                                       System.Collections.ICollection.IsSynchronized                                                             => false;
      object                                                                                                                     System.Collections.ICollection.SyncRoot                                                                   => this;
      bool                                                                                                                       System.Collections.IDictionary.IsFixedSize                                                                => false;
      bool                                                                                                                       System.Collections.IDictionary.IsReadOnly                                                                 => false;
      System.Collections.ICollection                                                                                             System.Collections.IDictionary.Keys                                                                       => this.Keys;
      System.Collections.ICollection                                                                                             System.Collections.IDictionary.Values                                                                     => this.Values;

      /* … ->> Availability of `System.Runtime.InteropServices.CollectionMarshal.GetValueRefOrNullRef(…)` would replace `RefDictionary<T…>`’s entire purpose */
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RefDictionary()                                                                                                                                                                                                       : this(0u,                                Game.Collections.RefReadOnlyEqualityComparer<TKey>.Default) {}
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RefDictionary(uint                                                                                                                  capacity)                                                                         : this(capacity,                          Game.Collections.RefReadOnlyEqualityComparer<TKey>.Default) {}
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RefDictionary(Game.Collections.IRefReadOnlyEqualityComparer<TKey>                                                           comparer)                                                                         : this(2u,                                comparer)                                                           {}
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RefDictionary(Game.Collections.RefReadOnlyDictionary       <TKey, TValue>                                                   dictionary)                                                                       : this(dictionary,                        dictionary.Comparer)                                                {}
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public RefDictionary(RefDictionary                                        <TKey, TValue>                                                   dictionary)                                                                       : this(dictionary,                        dictionary.Comparer)                                                {}
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public RefDictionary(System.Collections.Generic.IEnumerable               <Game.Collections.RefKeyValuePair<TKey, TValue>>         enumerable)                                                                       : this(enumerable,                        Game.Collections.RefReadOnlyEqualityComparer<TKey>.Default) {}
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RefDictionary(System.Collections.Generic.IEnumerable               <Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>> enumerable)                                                                       : this(enumerable,                        Game.Collections.RefReadOnlyEqualityComparer<TKey>.Default) {}
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RefDictionary(System.Collections.Generic.IEnumerable               <System.Collections.Generic.KeyValuePair<TKey, TValue>>          enumerable)                                                                       : this(enumerable,                        Game.Collections.RefReadOnlyEqualityComparer<TKey>.Default) {}
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RefDictionary(Game.Collections.RefReadOnlyDictionary       <TKey, TValue>                                                   dictionary, Game.Collections.IRefReadOnlyEqualityComparer<TKey> comparer) : this(dictionary.Count,                  comparer)                                                           { this.AddRange((System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>>) dictionary); }
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public RefDictionary(RefDictionary                                        <TKey, TValue>                                                   dictionary, Game.Collections.IRefReadOnlyEqualityComparer<TKey> comparer) : this(dictionary.Count,                  comparer)                                                           { this.AddRange((System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<TKey, TValue>>)         dictionary); }
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public RefDictionary(System.Collections.Generic.IEnumerable               <Game.Collections.RefKeyValuePair<TKey, TValue>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<TKey> comparer) : this(Util.Enumerable.Count(enumerable), comparer)                                                           { this.AddRange(enumerable); }
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RefDictionary(System.Collections.Generic.IEnumerable               <Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>> enumerable, Game.Collections.IRefReadOnlyEqualityComparer<TKey> comparer) : this(Util.Enumerable.Count(enumerable), comparer)                                                           { this.AddRange(enumerable); }
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RefDictionary(System.Collections.Generic.IEnumerable               <System.Collections.Generic.KeyValuePair<TKey, TValue>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<TKey> comparer) : this(Util.Enumerable.Count(enumerable), comparer)                                                           { this.AddRange(enumerable); }
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RefDictionary(uint                                                                                                                  capacity,   Game.Collections.IRefReadOnlyEqualityComparer<TKey> comparer) : base()                                                                                                      { this.Comparer = comparer; base.values = (Game.Collections.RefReadOnlyList<TValue>) this.values; base.keys = (Game.Collections.RefReadOnlyList<TKey>) this.keys; this.EnsureCapacity(capacity); }

      /* … */
      [GameMethod(AggressiveInlining), GameResolution(2)] public     void                                                                                           Add                                                                                                         (in Game.Collections.RefKeyValuePair        <TKey, TValue>                                      element)              => this.Add(in element.Key, in element.Value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public     void                                                                                           Add                                                                                                         (in Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>                                      element)              => this.Add(in element.Key, in element.Value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public     void                                                                                           Add                                                                                                         (in System.Collections.Generic.KeyValuePair         <TKey, TValue>                                      element)              => this.Add(element.Key,    element.Value);
      [GameMethod(NoInlining),         GameResolution(0)] public     void                                                                                           Add                                                                                                         (in TKey                                                                                                key, in TValue value) { if (key is null) { throw new System.ArgumentNullException("Dictionary element with null key can not be added"); } if (base.GetValue(in key) != -1) { throw new System.ArgumentException($"Dictionary element with the same key has already been added. Key: `{key.ToString()}`"); } this.keys.Add(in key); this.values.Add(in value); }
      [GameMethod(AggressiveInlining), GameResolution(2)] public     ref TValue                                                                                     Append                                                                                                      (in Game.Collections.RefKeyValuePair        <TKey, TValue>                                      element)              => ref this.TryAppend(in element.Key, in element.Value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public     ref TValue                                                                                     Append                                                                                                      (in Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>                                      element)              => ref this.TryAppend(in element.Key, in element.Value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public     ref TValue                                                                                     Append                                                                                                      (in System.Collections.Generic.KeyValuePair         <TKey, TValue>                                      element)              { (TKey key, TValue value)[] pair = new[] {(element.Key, element.Value)}; return ref this.TryAppend(in Util.Reference<(TKey key, TValue)>.Only(pair).key, in Util.Reference<(TKey, TValue value)>.Only(pair).value); }
      [GameMethod(NoInlining),         GameResolution(0)] public     ref TValue                                                                                     Append                                                                                                      (in TKey                                                                                                key, in TValue value) { int index = base.GetValue(in key); if (index != -1) { return ref base.values.GetValue((uint) index); } if (key is null) { throw new System.ArgumentNullException("Dictionary element with null key can not be added"); } this.keys.Add(in key); return ref this.values.Append(in value); }
      [GameMethod(AggressiveInlining), GameResolution(2)] public     void                                                                                           AddRange                                                                                                    (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<TKey, TValue>>         enumerable)           { foreach (Game.Collections.RefKeyValuePair        <TKey, TValue> element in enumerable) this.Add(in element); }
      [GameMethod(AggressiveInlining), GameResolution(1)] public     void                                                                                           AddRange                                                                                                    (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>> enumerable)           { foreach (Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue> element in enumerable) this.Add(in element); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public     void                                                                                           AddRange                                                                                                    (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>          enumerable)           { foreach (System.Collections.Generic.KeyValuePair         <TKey, TValue> element in enumerable) this.Add(element); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public new RefDictionary<TKey, TValue>                                                                    AsCopy                                                                                                      ()                                                                                                                            => new(this);
      [GameMethod(AggressiveInlining), GameResolution(0)] public     void                                                                                           Clear                                                                                                       ()                                                                                                                            { this.keys.Clear(); this.values.Clear(); }
      [GameMethod(AggressiveInlining), GameResolution(2)] public     bool                                                                                           Contains                                                                                                    (in Game.Collections.RefKeyValuePair        <TKey, TValue>   element)                                                 { int index = base.GetValue(in element.Key); return index != -1 && Game.Collections.RefReadOnlyEqualityComparer<TValue>.Default.Equals(in base.values[(uint) index], in element.Value); }
      [GameMethod(AggressiveInlining), GameResolution(1)] public new bool                                                                                           Contains                                                                                                    (in Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>   element)                                                 => base.Contains(in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] public new bool                                                                                           Contains                                                                                                    (in System.Collections.Generic.KeyValuePair         <TKey, TValue>   element)                                                 => base.Contains(in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] public     void                                                                                           CopyTo                                                                                                      (Game.Collections.RefKeyValuePair           <TKey, TValue>[] array, uint index)                                       { for (uint subindex = 0u; subindex != base.Count; ++subindex) array[index++] = new(in base.keys[subindex], in base.values[subindex]); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public new void                                                                                           CopyTo                                                                                                      (Game.Collections.RefReadOnlyKeyValuePair   <TKey, TValue>[] array, uint index)                                       => base.CopyTo(array, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public new void                                                                                           CopyTo                                                                                                      (System.Collections.Generic.KeyValuePair            <TKey, TValue>[] array, uint index)                                       => base.CopyTo(array, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public     void                                                                                           EnsureCapacity                                                                                              (uint                                                                capacity)                                                { this.keys.EnsureCapacity(capacity); this.values.EnsureCapacity(capacity); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public     bool                                                                                           Equals                                                                                                      (in RefDictionary<TKey, TValue>                                      dictionary)                                              => object.ReferenceEquals(this, dictionary);
      [GameMethod(AggressiveInlining), GameResolution(0)] public new RefDictionary<TKey, TValue>.AlternateLookup<TAlternateKey>                                     GetAlternateLookup<TAlternateKey>                                                                           ()                                                                                                                            => new(this);
      [GameMethod(AggressiveInlining), GameResolution(0)] public new RefDictionary<TKey, TValue>.Enumerator                                                         GetEnumerator                                                                                               ()                                                                                                                            => new(this);
      [GameMethod(AggressiveInlining), GameResolution(2)] public new Game.Collections.RefKeyValuePair<TKey, TValue>                                         Random                                                                                                      ()                                                                                                                            => new(base.Random());
      [GameMethod(AggressiveInlining), GameResolution(2)] public     bool                                                                                           Remove                                                                                                      (in Game.Collections.RefKeyValuePair        <TKey, TValue> element)                                                   { int index = base.GetValue(in element.Key); if (index != -1 && Game.Collections.RefEqualityComparer<TValue>.Default.Equals(in this.values[(uint) index], in element.Value)) { this.keys.RemoveAt((uint) index); this.values.RemoveAt((uint) index); return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public     bool                                                                                           Remove                                                                                                      (in Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue> element)                                                   { int index = base.GetValue(in element.Key); if (index != -1 && Game.Collections.RefEqualityComparer<TValue>.Default.Equals(in this.values[(uint) index], in element.Value)) { this.keys.RemoveAt((uint) index); this.values.RemoveAt((uint) index); return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public     bool                                                                                           Remove                                                                                                      (in System.Collections.Generic.KeyValuePair         <TKey, TValue> element)                                                   { int index = base.GetValue(element.Key);    if (index != -1 && Game.Collections.RefEqualityComparer<TValue>.Default.Equals(in this.values[(uint) index], element.Value))    { this.keys.RemoveAt((uint) index); this.values.RemoveAt((uint) index); return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public     bool                                                                                           Remove                                                                                                      (in TKey                                                           key)                                                       { int index = base.GetValue(in key);         if (index != -1)                                                                                                                        { this.keys.RemoveAt((uint) index); this.values.RemoveAt((uint) index); return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public     void                                                                                           TrimExcess                                                                                                  ()                                                                                                                            { this.keys.TrimExcess();         this.values.TrimExcess(); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public     void                                                                                           TrimExcess                                                                                                  (uint                                                                                  capacity)                              { this.keys.TrimExcess(capacity); this.values.TrimExcess(capacity); }
      [GameMethod(AggressiveInlining), GameResolution(2)] public     bool                                                                                           TryAdd                                                                                                      (in Game.Collections.RefKeyValuePair        <TKey, TValue>                     element)                               => this.TryAdd(in element.Key, in element.Value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public     bool                                                                                           TryAdd                                                                                                      (in Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>                     element)                               => this.TryAdd(in element.Key, in element.Value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public     bool                                                                                           TryAdd                                                                                                      (in System.Collections.Generic.KeyValuePair         <TKey, TValue>                     element)                               => this.TryAdd(element.Key,    element.Value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public     bool                                                                                           TryAdd                                                                                                      (in TKey                                                                               key, in TValue value)                  { if (base.GetValue(in key) == -1) { this.Add(in key, in value); return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(2)] public     ref TValue                                                                                     TryAppend                                                                                                   (in Game.Collections.RefKeyValuePair        <TKey, TValue>                     element)                               => ref this.TryAppend(in element.Key, in element.Value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public     ref TValue                                                                                     TryAppend                                                                                                   (in Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>                     element)                               => ref this.TryAppend(in element.Key, in element.Value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public     ref TValue                                                                                     TryAppend                                                                                                   (in System.Collections.Generic.KeyValuePair         <TKey, TValue>                     element)                               { (TKey key, TValue value)[] pair = new[] {(element.Key, element.Value)}; return ref this.TryAppend(in Util.Reference<(TKey key, TValue)>.Only(pair).key, in Util.Reference<(TKey, TValue value)>.Only(pair).value); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public     ref TValue                                                                                     TryAppend                                                                                                   (in TKey                                                                               key, in TValue value)                  { return ref (key is not null ? ref this.Append(in key, in value) : ref base.Null); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public     bool                                                                                           TryGetAlternateLookup<TAlternateKey>                                                                        (out RefDictionary                       <TKey, TValue>.AlternateLookup<TAlternateKey> lookup)                                { lookup = this.GetAlternateLookup<TAlternateKey>(); return false; }
      [GameMethod(AggressiveInlining), GameResolution(0)]            bool                                                                                           Game.Collections.IRefEquatable<RefDictionary<TKey, TValue>>.Equals                                  (ref RefDictionary                       <TKey, TValue>                                dictionary)                            => this.Equals       (in dictionary);
      [GameMethod(AggressiveInlining), GameResolution(0)]            bool                                                                                           Game.Collections.IRefReadOnlyEquatable<RefDictionary<TKey, TValue>>.Equals                          (in  RefDictionary                       <TKey, TValue>                                dictionary)                            => this.Equals       (in dictionary);
      [GameMethod(AggressiveInlining), GameResolution(0)]            void                                                                                           System.Collections.Generic.ICollection<Game.Collections.RefKeyValuePair<TKey, TValue>>.Add          (Game.Collections.RefKeyValuePair<TKey, TValue>                                element)                               => this.Add          (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)]            void                                                                                           System.Collections.Generic.ICollection<Game.Collections.RefKeyValuePair<TKey, TValue>>.Clear        ()                                                                                                                            => this.Clear        ();
      [GameMethod(AggressiveInlining), GameResolution(0)]            bool                                                                                           System.Collections.Generic.ICollection<Game.Collections.RefKeyValuePair<TKey, TValue>>.Contains     (Game.Collections.RefKeyValuePair<TKey, TValue>   element)                                                            => this.Contains     (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)]            void                                                                                           System.Collections.Generic.ICollection<Game.Collections.RefKeyValuePair<TKey, TValue>>.CopyTo       (Game.Collections.RefKeyValuePair<TKey, TValue>[] array, int index)                                                   => this.CopyTo       (array, (uint) index);
      [GameMethod(AggressiveInlining), GameResolution(0)]            bool                                                                                           System.Collections.Generic.ICollection<Game.Collections.RefKeyValuePair<TKey, TValue>>.Remove       (Game.Collections.RefKeyValuePair<TKey, TValue>   element)                                                            => this.Remove       (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)]            void                                                                                           System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Add           (System.Collections.Generic.KeyValuePair <TKey, TValue>   element)                                                            => this.Add          (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)]            void                                                                                           System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Clear         ()                                                                                                                            => this.Clear        ();
      [GameMethod(AggressiveInlining), GameResolution(0)]            bool                                                                                           System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Contains      (System.Collections.Generic.KeyValuePair<TKey, TValue>   element)                                                             => this.Contains     (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)]            void                                                                                           System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.CopyTo        (System.Collections.Generic.KeyValuePair<TKey, TValue>[] array, int index)                                                    => this.CopyTo       (array, (uint) index);
      [GameMethod(AggressiveInlining), GameResolution(0)]            bool                                                                                           System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Remove        (System.Collections.Generic.KeyValuePair<TKey, TValue>   element)                                                             => this.Remove       (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)]            void                                                                                           System.Collections.Generic.IDictionary<TKey, TValue>.Add                                                    (TKey                                                    key, TValue value)                                                   => this.Add          (in key, in value);
      [GameMethod(AggressiveInlining), GameResolution(0)]            bool                                                                                           System.Collections.Generic.IDictionary<TKey, TValue>.ContainsKey                                            (TKey                                                    key)                                                                 => this.ContainsKey  (in key);
      [GameMethod(AggressiveInlining), GameResolution(0)]            bool                                                                                           System.Collections.Generic.IDictionary<TKey, TValue>.Remove                                                 (TKey                                                    key)                                                                 => this.Remove       (in key);
      [GameMethod(AggressiveInlining), GameResolution(0)]            bool                                                                                           System.Collections.Generic.IDictionary<TKey, TValue>.TryGetValue                                            (TKey                                                    key, out TValue value)                                               => this.TryGetValue  (in key, out value);
      [GameMethod(AggressiveInlining), GameResolution(0)]            System.Collections.Generic.IEnumerator<Game.Collections.RefKeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<TKey, TValue>>.GetEnumerator()                                                                                                                            => this.GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)]            System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>  System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>.GetEnumerator ()                                                                                                                            => this.GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)]            void                                                                                           System.Collections.ICollection.CopyTo                                                                       (System.Array array, int     index)                                                                                           { foreach (Game.Collections.RefKeyValuePair<TKey, TValue> element in this) array.SetValue(element, index++); }
      [GameMethod(AggressiveInlining), GameResolution(0)]            void                                                                                           System.Collections.IDictionary.Add                                                                          (object       key,   object? value)                                                                                           => this.Add          ((TKey) key, (TValue) value!);
      [GameMethod(AggressiveInlining), GameResolution(0)]            void                                                                                           System.Collections.IDictionary.Clear                                                                        ()                                                                                                                            => this.Clear        ();
      [GameMethod(AggressiveInlining), GameResolution(0)]            bool                                                                                           System.Collections.IDictionary.Contains                                                                     (object key)                                                                                                                  => this.ContainsKey  ((TKey) key);
      [GameMethod(AggressiveInlining), GameResolution(0)]            System.Collections.IDictionaryEnumerator                                                       System.Collections.IDictionary.GetEnumerator                                                                ()                                                                                                                            => this.GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)]            void                                                                                           System.Collections.IDictionary.Remove                                                                       (object key)                                                                                                                  => this.Remove       ((TKey) key);
      [GameMethod(AggressiveInlining), GameResolution(0)]            System.Collections.IEnumerator                                                                 System.Collections.IEnumerable.GetEnumerator                                                                ()                                                                                                                            => this.GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)]            bool                                                                                           System.IEquatable<RefDictionary<TKey, TValue>>.Equals                                                       (RefDictionary<TKey, TValue> dictionary)                                                                                      => this.Equals       (dictionary);

      public new ref TValue this                                                     [in TKey key] { get { int index = base.GetValue(in key);     if (index != -1) { return ref this.values[(uint) index]; } if (key is null) { throw new System.ArgumentNullException("Dictionary can not get element with null key"); } this.keys.Add(in key); return ref this.values.Append(in Util.Reference<TValue>.Only(new TValue[] {default!})); } }
      TValue                System.Collections.Generic.IDictionary<TKey, TValue>.this[TKey    key] { get { int index = base.GetValue(in key);     if (index != -1) { return     this.values[(uint) index]; } if (key is null) { throw new System.ArgumentNullException("Dictionary can not get element with null key"); } throw new System.Collections.Generic.KeyNotFoundException($"Dictionary does not contain key. Key `{key.ToString()}`"); } set { int index = base.GetValue(in key);     if (index != -1) { this.values[(uint) index] = value;                    return; } if (key is null) { throw new System.ArgumentNullException("Dictionary can not set element with null key"); } this.keys.Add(in key);     this.values.Add(value); } }
      object?               System.Collections.IDictionary.this                      [object  key] { get { int index = base.GetValue((TKey) key); if (index != -1) { return     this.values[(uint) index]; } if (key is null) { throw new System.ArgumentNullException("Dictionary can not get element with null key"); } throw new System.Collections.Generic.KeyNotFoundException($"Dictionary does not contain key. Key `{key.ToString()}`"); } set { int index = base.GetValue((TKey) key); if (index != -1) { this.values[(uint) index] = (TValue) (object) value!; return; } if (key is null) { throw new System.ArgumentNullException("Dictionary can not set element with null key"); } this.keys.Add((TKey) key); this.values.Add((TValue) (object) value!); } }
    }
      [System.Serializable] public class AnimationCurveDictionary : Game.Collections.RefDictionary<string, UnityEngine.AnimationCurve> { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public AnimationCurveDictionary() : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public AnimationCurveDictionary(uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public AnimationCurveDictionary(Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public AnimationCurveDictionary(Game.Collections.RefReadOnlyDictionary<string, UnityEngine.AnimationCurve> dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public AnimationCurveDictionary(Game.Collections.RefDictionary<string, UnityEngine.AnimationCurve> dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public AnimationCurveDictionary(System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.AnimationCurve>> enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public AnimationCurveDictionary(System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.AnimationCurve>> enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public AnimationCurveDictionary(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.AnimationCurve>> enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public AnimationCurveDictionary(uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public AnimationCurveDictionary(Game.Collections.RefReadOnlyDictionary<string, UnityEngine.AnimationCurve> dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public AnimationCurveDictionary(Game.Collections.RefDictionary<string, UnityEngine.AnimationCurve> dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public AnimationCurveDictionary(System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.AnimationCurve>> enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public AnimationCurveDictionary(System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.AnimationCurve>> enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public AnimationCurveDictionary(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.AnimationCurve>> enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class BooleanDictionary        : Game.Collections.RefDictionary<string, System     .Boolean>        { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BooleanDictionary       () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BooleanDictionary       (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BooleanDictionary       (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BooleanDictionary       (Game.Collections.RefReadOnlyDictionary<string, System     .Boolean>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public BooleanDictionary       (Game.Collections.RefDictionary<string, System     .Boolean>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public BooleanDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .Boolean>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BooleanDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Boolean>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BooleanDictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Boolean>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BooleanDictionary       (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BooleanDictionary       (Game.Collections.RefReadOnlyDictionary<string, System     .Boolean>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public BooleanDictionary       (Game.Collections.RefDictionary<string, System     .Boolean>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public BooleanDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .Boolean>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BooleanDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Boolean>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BooleanDictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Boolean>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class BoundsDictionary         : Game.Collections.RefDictionary<string, UnityEngine.Bounds>         { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsDictionary        () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsDictionary        (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsDictionary        (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BoundsDictionary        (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Bounds>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public BoundsDictionary        (Game.Collections.RefDictionary<string, UnityEngine.Bounds>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public BoundsDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Bounds>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BoundsDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Bounds>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsDictionary        (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Bounds>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsDictionary        (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BoundsDictionary        (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Bounds>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public BoundsDictionary        (Game.Collections.RefDictionary<string, UnityEngine.Bounds>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public BoundsDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Bounds>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BoundsDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Bounds>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsDictionary        (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Bounds>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class BoundsIntDictionary      : Game.Collections.RefDictionary<string, UnityEngine.BoundsInt>      { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsIntDictionary     () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsIntDictionary     (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsIntDictionary     (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BoundsIntDictionary     (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.BoundsInt>      dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public BoundsIntDictionary     (Game.Collections.RefDictionary<string, UnityEngine.BoundsInt>      dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public BoundsIntDictionary     (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.BoundsInt>>      enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BoundsIntDictionary     (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.BoundsInt>>      enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsIntDictionary     (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.BoundsInt>>      enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsIntDictionary     (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BoundsIntDictionary     (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.BoundsInt>      dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public BoundsIntDictionary     (Game.Collections.RefDictionary<string, UnityEngine.BoundsInt>      dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public BoundsIntDictionary     (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.BoundsInt>>      enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BoundsIntDictionary     (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.BoundsInt>>      enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsIntDictionary     (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.BoundsInt>>      enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class CanvasRendererDictionary : Game.Collections.RefDictionary<string, UnityEngine.CanvasRenderer> { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public CanvasRendererDictionary() : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public CanvasRendererDictionary(uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public CanvasRendererDictionary(Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public CanvasRendererDictionary(Game.Collections.RefReadOnlyDictionary<string, UnityEngine.CanvasRenderer> dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public CanvasRendererDictionary(Game.Collections.RefDictionary<string, UnityEngine.CanvasRenderer> dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public CanvasRendererDictionary(System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.CanvasRenderer>> enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public CanvasRendererDictionary(System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.CanvasRenderer>> enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public CanvasRendererDictionary(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.CanvasRenderer>> enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public CanvasRendererDictionary(uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public CanvasRendererDictionary(Game.Collections.RefReadOnlyDictionary<string, UnityEngine.CanvasRenderer> dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public CanvasRendererDictionary(Game.Collections.RefDictionary<string, UnityEngine.CanvasRenderer> dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public CanvasRendererDictionary(System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.CanvasRenderer>> enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public CanvasRendererDictionary(System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.CanvasRenderer>> enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public CanvasRendererDictionary(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.CanvasRenderer>> enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class ColorDictionary          : Game.Collections.RefDictionary<string, UnityEngine.Color>          { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ColorDictionary         () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ColorDictionary         (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ColorDictionary         (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public ColorDictionary         (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Color>          dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public ColorDictionary         (Game.Collections.RefDictionary<string, UnityEngine.Color>          dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public ColorDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Color>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public ColorDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Color>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ColorDictionary         (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Color>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ColorDictionary         (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public ColorDictionary         (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Color>          dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public ColorDictionary         (Game.Collections.RefDictionary<string, UnityEngine.Color>          dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public ColorDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Color>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public ColorDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Color>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ColorDictionary         (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Color>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class Dictionary<T>            : Game.Collections.RefDictionary<string, T>                          { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Dictionary              () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Dictionary              (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Dictionary              (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Dictionary              (Game.Collections.RefReadOnlyDictionary<string, T>                          dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Dictionary              (Game.Collections.RefDictionary<string, T>                          dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Dictionary              (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, T>>                          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Dictionary              (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, T>>                          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Dictionary              (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, T>>                          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Dictionary              (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Dictionary              (Game.Collections.RefReadOnlyDictionary<string, T>                          dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Dictionary              (Game.Collections.RefDictionary<string, T>                          dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Dictionary              (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, T>>                          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Dictionary              (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, T>>                          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Dictionary              (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, T>>                          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class DoubleDictionary         : Game.Collections.RefDictionary<string, System     .Double>         { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public DoubleDictionary        () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public DoubleDictionary        (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public DoubleDictionary        (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public DoubleDictionary        (Game.Collections.RefReadOnlyDictionary<string, System     .Double>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public DoubleDictionary        (Game.Collections.RefDictionary<string, System     .Double>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public DoubleDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .Double>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public DoubleDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Double>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public DoubleDictionary        (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Double>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public DoubleDictionary        (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public DoubleDictionary        (Game.Collections.RefReadOnlyDictionary<string, System     .Double>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public DoubleDictionary        (Game.Collections.RefDictionary<string, System     .Double>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public DoubleDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .Double>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public DoubleDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Double>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public DoubleDictionary        (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Double>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class FloatDictionary          : Game.Collections.RefDictionary<string, System     .Single>         { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public FloatDictionary         () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public FloatDictionary         (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public FloatDictionary         (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public FloatDictionary         (Game.Collections.RefReadOnlyDictionary<string, System     .Single>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public FloatDictionary         (Game.Collections.RefDictionary<string, System     .Single>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public FloatDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .Single>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public FloatDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Single>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public FloatDictionary         (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Single>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public FloatDictionary         (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public FloatDictionary         (Game.Collections.RefReadOnlyDictionary<string, System     .Single>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public FloatDictionary         (Game.Collections.RefDictionary<string, System     .Single>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public FloatDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .Single>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public FloatDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Single>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public FloatDictionary         (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Single>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class GameObjectDictionary     : Game.Collections.RefDictionary<string, UnityEngine.GameObject>     { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GameObjectDictionary    () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GameObjectDictionary    (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GameObjectDictionary    (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public GameObjectDictionary    (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.GameObject>     dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public GameObjectDictionary    (Game.Collections.RefDictionary<string, UnityEngine.GameObject>     dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public GameObjectDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.GameObject>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public GameObjectDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.GameObject>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GameObjectDictionary    (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.GameObject>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GameObjectDictionary    (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public GameObjectDictionary    (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.GameObject>     dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public GameObjectDictionary    (Game.Collections.RefDictionary<string, UnityEngine.GameObject>     dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public GameObjectDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.GameObject>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public GameObjectDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.GameObject>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GameObjectDictionary    (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.GameObject>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class GradientDictionary       : Game.Collections.RefDictionary<string, UnityEngine.Gradient>       { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GradientDictionary      () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GradientDictionary      (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GradientDictionary      (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public GradientDictionary      (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Gradient>       dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public GradientDictionary      (Game.Collections.RefDictionary<string, UnityEngine.Gradient>       dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public GradientDictionary      (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Gradient>>       enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public GradientDictionary      (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Gradient>>       enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GradientDictionary      (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Gradient>>       enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GradientDictionary      (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public GradientDictionary      (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Gradient>       dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public GradientDictionary      (Game.Collections.RefDictionary<string, UnityEngine.Gradient>       dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public GradientDictionary      (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Gradient>>       enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public GradientDictionary      (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Gradient>>       enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GradientDictionary      (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Gradient>>       enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class IntDictionary            : Game.Collections.RefDictionary<string, System     .Int32>          { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public IntDictionary           () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public IntDictionary           (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public IntDictionary           (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public IntDictionary           (Game.Collections.RefReadOnlyDictionary<string, System     .Int32>          dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public IntDictionary           (Game.Collections.RefDictionary<string, System     .Int32>          dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public IntDictionary           (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .Int32>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public IntDictionary           (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Int32>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public IntDictionary           (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Int32>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public IntDictionary           (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public IntDictionary           (Game.Collections.RefReadOnlyDictionary<string, System     .Int32>          dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public IntDictionary           (Game.Collections.RefDictionary<string, System     .Int32>          dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public IntDictionary           (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .Int32>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public IntDictionary           (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Int32>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public IntDictionary           (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Int32>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class LongDictionary           : Game.Collections.RefDictionary<string, System     .Int64>          { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public LongDictionary          () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public LongDictionary          (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public LongDictionary          (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public LongDictionary          (Game.Collections.RefReadOnlyDictionary<string, System     .Int64>          dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public LongDictionary          (Game.Collections.RefDictionary<string, System     .Int64>          dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public LongDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .Int64>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public LongDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Int64>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public LongDictionary          (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Int64>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public LongDictionary          (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public LongDictionary          (Game.Collections.RefReadOnlyDictionary<string, System     .Int64>          dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public LongDictionary          (Game.Collections.RefDictionary<string, System     .Int64>          dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public LongDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .Int64>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public LongDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Int64>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public LongDictionary          (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Int64>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class RectDictionary           : Game.Collections.RefDictionary<string, UnityEngine.Rect>           { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectDictionary          () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectDictionary          (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectDictionary          (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RectDictionary          (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Rect>           dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public RectDictionary          (Game.Collections.RefDictionary<string, UnityEngine.Rect>           dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public RectDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Rect>>           enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RectDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Rect>>           enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectDictionary          (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Rect>>           enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectDictionary          (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RectDictionary          (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Rect>           dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public RectDictionary          (Game.Collections.RefDictionary<string, UnityEngine.Rect>           dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public RectDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Rect>>           enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RectDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Rect>>           enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectDictionary          (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Rect>>           enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class RectIntDictionary        : Game.Collections.RefDictionary<string, UnityEngine.RectInt>        { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectIntDictionary       () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectIntDictionary       (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectIntDictionary       (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RectIntDictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.RectInt>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public RectIntDictionary       (Game.Collections.RefDictionary<string, UnityEngine.RectInt>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public RectIntDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.RectInt>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RectIntDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.RectInt>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectIntDictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.RectInt>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectIntDictionary       (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RectIntDictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.RectInt>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public RectIntDictionary       (Game.Collections.RefDictionary<string, UnityEngine.RectInt>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public RectIntDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.RectInt>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RectIntDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.RectInt>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectIntDictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.RectInt>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class StringDictionary         : Game.Collections.RefDictionary<string, System     .String>         { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public StringDictionary        () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public StringDictionary        (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public StringDictionary        (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public StringDictionary        (Game.Collections.RefReadOnlyDictionary<string, System     .String>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public StringDictionary        (Game.Collections.RefDictionary<string, System     .String>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public StringDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .String>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public StringDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .String>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public StringDictionary        (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .String>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public StringDictionary        (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public StringDictionary        (Game.Collections.RefReadOnlyDictionary<string, System     .String>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public StringDictionary        (Game.Collections.RefDictionary<string, System     .String>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public StringDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .String>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public StringDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .String>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public StringDictionary        (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .String>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class UIntDictionary           : Game.Collections.RefDictionary<string, System     .UInt32>         { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public UIntDictionary          () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public UIntDictionary          (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public UIntDictionary          (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public UIntDictionary          (Game.Collections.RefReadOnlyDictionary<string, System     .UInt32>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public UIntDictionary          (Game.Collections.RefDictionary<string, System     .UInt32>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public UIntDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .UInt32>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public UIntDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .UInt32>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public UIntDictionary          (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .UInt32>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public UIntDictionary          (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public UIntDictionary          (Game.Collections.RefReadOnlyDictionary<string, System     .UInt32>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public UIntDictionary          (Game.Collections.RefDictionary<string, System     .UInt32>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public UIntDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .UInt32>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public UIntDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .UInt32>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public UIntDictionary          (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .UInt32>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class ULongDictionary          : Game.Collections.RefDictionary<string, System     .UInt64>         { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ULongDictionary         () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ULongDictionary         (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ULongDictionary         (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public ULongDictionary         (Game.Collections.RefReadOnlyDictionary<string, System     .UInt64>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public ULongDictionary         (Game.Collections.RefDictionary<string, System     .UInt64>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public ULongDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .UInt64>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public ULongDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .UInt64>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ULongDictionary         (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .UInt64>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ULongDictionary         (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public ULongDictionary         (Game.Collections.RefReadOnlyDictionary<string, System     .UInt64>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public ULongDictionary         (Game.Collections.RefDictionary<string, System     .UInt64>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public ULongDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, System     .UInt64>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public ULongDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .UInt64>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ULongDictionary         (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .UInt64>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class Vector2Dictionary        : Game.Collections.RefDictionary<string, UnityEngine.Vector2>        { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2Dictionary       () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2Dictionary       (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2Dictionary       (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector2Dictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector2>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector2Dictionary       (Game.Collections.RefDictionary<string, UnityEngine.Vector2>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector2Dictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Vector2>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector2Dictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector2>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2Dictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector2>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2Dictionary       (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector2Dictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector2>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector2Dictionary       (Game.Collections.RefDictionary<string, UnityEngine.Vector2>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector2Dictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Vector2>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector2Dictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector2>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2Dictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector2>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class Vector2IntDictionary     : Game.Collections.RefDictionary<string, UnityEngine.Vector2Int>     { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2IntDictionary    () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2IntDictionary    (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2IntDictionary    (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector2IntDictionary    (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector2Int>     dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector2IntDictionary    (Game.Collections.RefDictionary<string, UnityEngine.Vector2Int>     dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector2IntDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Vector2Int>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector2IntDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector2Int>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2IntDictionary    (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector2Int>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2IntDictionary    (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector2IntDictionary    (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector2Int>     dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector2IntDictionary    (Game.Collections.RefDictionary<string, UnityEngine.Vector2Int>     dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector2IntDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Vector2Int>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector2IntDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector2Int>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2IntDictionary    (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector2Int>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class Vector3Dictionary        : Game.Collections.RefDictionary<string, UnityEngine.Vector3>        { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3Dictionary       () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3Dictionary       (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3Dictionary       (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector3Dictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector3>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector3Dictionary       (Game.Collections.RefDictionary<string, UnityEngine.Vector3>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector3Dictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Vector3>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector3Dictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector3>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3Dictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector3>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3Dictionary       (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector3Dictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector3>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector3Dictionary       (Game.Collections.RefDictionary<string, UnityEngine.Vector3>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector3Dictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Vector3>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector3Dictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector3>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3Dictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector3>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class Vector3IntDictionary     : Game.Collections.RefDictionary<string, UnityEngine.Vector3Int>     { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3IntDictionary    () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3IntDictionary    (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3IntDictionary    (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector3IntDictionary    (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector3Int>     dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector3IntDictionary    (Game.Collections.RefDictionary<string, UnityEngine.Vector3Int>     dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector3IntDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Vector3Int>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector3IntDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector3Int>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3IntDictionary    (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector3Int>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3IntDictionary    (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector3IntDictionary    (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector3Int>     dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector3IntDictionary    (Game.Collections.RefDictionary<string, UnityEngine.Vector3Int>     dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector3IntDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Vector3Int>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector3IntDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector3Int>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3IntDictionary    (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector3Int>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class Vector4Dictionary        : Game.Collections.RefDictionary<string, UnityEngine.Vector4>        { [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector4Dictionary       () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector4Dictionary       (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector4Dictionary       (Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector4Dictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector4>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector4Dictionary       (Game.Collections.RefDictionary<string, UnityEngine.Vector4>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector4Dictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Vector4>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector4Dictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector4>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector4Dictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector4>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector4Dictionary       (uint capacity, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(capacity, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector4Dictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector4>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector4Dictionary       (Game.Collections.RefDictionary<string, UnityEngine.Vector4>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(2)] public Vector4Dictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<string, UnityEngine.Vector4>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector4Dictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector4>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector4Dictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector4>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }

    public /* sealed */ class RefEqualityComparer<T> : Game.Collections.RefReadOnlyEqualityComparer<T>, Game.Collections.IRefEqualityComparer<T> {
      private readonly struct Sentinel : Game.Collections.IRefEquatable<Sentinel> {
        bool Game.Collections.IRefEquatable<Sentinel>.Equals        (ref Sentinel value) => default;
        bool Game.Collections.IRefReadOnlyEquatable<Sentinel>.Equals(in  Sentinel value) => default;
        bool System.IEquatable<Sentinel>.Equals                             (Sentinel     value) => default;
      }

      /* … */
      private static readonly Game.RefHasher            <T> GetHashCodeValue = [GameMethod(AggressiveInlining)] static (ref T value) => System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(value);
      private static readonly Game.RefEqualityComparison<T> EqualsValue      = (Game.RefEqualityComparison<T>) (
        typeof(Game.Collections.IRefEquatable        <T>).IsAssignableFrom(typeof(T)) ? ((Game.RefEqualityComparison<RefEqualityComparer<T>.Sentinel>) RefEqualityComparer<RefEqualityComparer<T>.Sentinel>.RefEquatableEquals)        .Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.RefEqualityComparison<T>)) :
        typeof(Game.Collections.IRefReadOnlyEquatable<T>).IsAssignableFrom(typeof(T)) ? ((Game.RefEqualityComparison<RefEqualityComparer<T>.Sentinel>) RefEqualityComparer<RefEqualityComparer<T>.Sentinel>.RefReadOnlyEquatableEquals).Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.RefEqualityComparison<T>)) :
        typeof(System.IEquatable                             <T>).IsAssignableFrom(typeof(T)) ? ((Game.RefEqualityComparison<RefEqualityComparer<T>.Sentinel>) RefEqualityComparer<RefEqualityComparer<T>.Sentinel>.EquatableEquals)           .Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.RefEqualityComparison<T>)) :
        (Game.RefEqualityComparison<T>) RefEqualityComparer<T>.ObjectEquals<T>
      );
      protected        new readonly Game.RefEqualityComparison<T> comparison       = RefEqualityComparer<T>.EqualsValue;
      protected        new readonly Game.RefHasher            <T> hasher           = RefEqualityComparer<T>.GetHashCodeValue;
      public    static new         RefEqualityComparer                <T> Default { get; } = new();

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public    RefEqualityComparer()                                                                                                    : base()                   {}
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] protected RefEqualityComparer(Game.RefEqualityComparison        <T> comparison, Game.RefHasher        <T>? hasher) : base()                   { this.hasher = hasher ?? this.hasher; this.comparison = comparison; }
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] protected RefEqualityComparer(Game.RefEqualityComparison        <T> comparison, Game.RefReadOnlyHasher<T>? hasher) : base()                   { base.hasher = hasher ?? base.hasher; this.comparison = comparison; }
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] protected RefEqualityComparer(Game.RefReadOnlyEqualityComparison<T> comparison, Game.RefHasher        <T>? hasher) : base(comparison, null)   { this.hasher = hasher ?? this.hasher; }
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] protected RefEqualityComparer(Game.RefReadOnlyEqualityComparison<T> comparison, Game.RefReadOnlyHasher<T>? hasher) : base(comparison, hasher) {}

      /* … */
      [GameMethod(AggressiveInlining), GameResolution(1)] public           static RefEqualityComparer<T> Create                                                              (Game.RefEqualityComparison        <T> comparison, Game.RefHasher        <T>? hasher = null)                    => new(comparison, hasher);
      [GameMethod(AggressiveInlining), GameResolution(0)] public           static RefEqualityComparer<T> Create                                                              (Game.RefEqualityComparison        <T> comparison, Game.RefReadOnlyHasher<T>? hasher = null)                    => new(comparison, hasher);
      [GameMethod(AggressiveInlining), GameResolution(1)] public           static RefEqualityComparer<T> Create                                                              (Game.RefReadOnlyEqualityComparison<T> comparison, Game.RefHasher        <T>? hasher = null)                    => new(comparison, hasher);
      [GameMethod(AggressiveInlining), GameResolution(0)] public  new      static RefEqualityComparer<T> Create                                                              (Game.RefReadOnlyEqualityComparison<T> comparison, Game.RefReadOnlyHasher<T>? hasher = null)                    => new(comparison, hasher);
      [GameMethod(AggressiveInlining), GameResolution(0)] public  virtual         bool                   Equals                                                              (ref T                                         a,          ref T                              b)                                => RefEqualityComparer<T>.EqualsValue == this.comparison && a is null ? b is null : this.comparison(ref a, ref b);
      [GameMethod(AggressiveInlining), GameResolution(0)] public  override        bool                   Equals                                                              (T                                             a,          T                                  b)                                => this.Equals(ref a!, ref b!);
      [GameMethod(AggressiveInlining), GameResolution(0)] private          static bool                   EquatableEquals<U>                                                  (ref U                                         a,          ref U                              b) where U : System.IEquatable<U> => a.Equals(b);
      [GameMethod(AggressiveInlining), GameResolution(0)] public  virtual         int                    GetHashCode                                                         (ref T                                         value)                                                                           => RefEqualityComparer<T>.GetHashCodeValue == this.hasher && value is null ? 0 : this.hasher(ref value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public  override        int                    GetHashCode                                                         (T                                             value)                                                                           => this.GetHashCode(ref value!);
      [GameMethod(AggressiveInlining), GameResolution(0)] private          static bool                   ObjectEquals      <U>                                               (ref U                                         a, ref U b)                                                                      => a!.Equals(b);
      [GameMethod(AggressiveInlining), GameResolution(0)] private          static bool                   RefEquatableEquals<U>                                               (ref U                                         a, ref U b) where U : Game.Collections.IRefEquatable<U>                  => a .Equals(ref b);
      [GameMethod(NoInlining),         GameResolution(0)] private                 bool                   RefReadOnlyEquals                                                   (in  T                                         a, in  T b)                                                                      { if (RefEqualityComparer<T>.EqualsValue != this.comparison) throw new System.NotSupportedException("Reference equality comparer can not compare as modifiable references"); return base.Equals(in a, in b); }
      [GameMethod(AggressiveInlining), GameResolution(0)] private          static bool                   RefReadOnlyEquatableEquals<U>                                       (ref U                                         a, ref U b) where U : Game.Collections.IRefReadOnlyEquatable<U>          => a.Equals(in b);
      [GameMethod(NoInlining),         GameResolution(0)] private                 int                    RefReadOnlyGetHashCode                                              (in  T                                         value)                                                                           { if (RefEqualityComparer<T>.GetHashCodeValue != this.hasher) throw new System.NotSupportedException("Reference equality comparer can not get hash code as modifiable references"); return base.GetHashCode(in value); }
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                           Game.Collections.IRefEqualityComparer<T>.Equals             (ref T                                         a, ref T b)                                                                      => this.Equals                (ref a, ref b);
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                            Game.Collections.IRefEqualityComparer<T>.GetHashCode        (ref T                                         value)                                                                           => this.GetHashCode           (ref value);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                           Game.Collections.IRefReadOnlyEqualityComparer<T>.Equals     (in  T                                         a, in T b)                                                                       => this.RefReadOnlyEquals     (in  a, in b);
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                            Game.Collections.IRefReadOnlyEqualityComparer<T>.GetHashCode(in  T                                         value)                                                                           => this.RefReadOnlyGetHashCode(in  value);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                           System.Collections.Generic.IEqualityComparer<T>.Equals              (T?                                            a, T? b)                                                                         { T aa = (T) a!, bb = (T) b!; return this.Equals     (ref aa, ref bb); }
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                            System.Collections.Generic.IEqualityComparer<T>.GetHashCode         (T                                             value)                                                                           { T subvalue = (T) value!;    return this.GetHashCode(ref subvalue); }
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                           System.Collections.IEqualityComparer.Equals                         (object?                                       a, object? b)                                                                    { T aa = (T) a!, bb = (T) b!; return this.Equals     (ref aa, ref bb); }
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                            System.Collections.IEqualityComparer.GetHashCode                    (object                                        value)                                                                           { T subvalue = (T) value!;    return this.GetHashCode(ref subvalue); }
    }

    public readonly struct RefKeyValuePair<TKey, TValue> : Game.Collections.IKeyValuePair /* ->> See `Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>` */ {
      public  readonly ref readonly TKey                                                       Key                                          => ref this.pair.key;
      private          readonly Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue> pair                                         =  default;
      public  readonly ref TValue                                                              Value                                        => ref this.pair.value;
      readonly object                                                                          Game.Collections.IKeyValuePair.Key   => this.Key!;
      readonly object?                                                                         Game.Collections.IKeyValuePair.Value => this.Value;

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)] internal RefKeyValuePair(in Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue> pair)                 => this.pair = pair;
      [GameConstructor, GameMethod(AggressiveInlining)] public   RefKeyValuePair(in TKey                                                           key, in TValue value) => this.pair = new(in key, in value);

      /* … */
      [GameMethod(AggressiveInlining)] public          readonly void    Deconstruct(out TKey key, out TValue value) => this.pair.Deconstruct(out key, out value);
      [GameMethod(AggressiveInlining)] public override readonly string? ToString   ()                               => this.pair.ToString();

      [GameMethod(AggressiveInlining), GameResolution(1)] public static implicit operator Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>(in RefKeyValuePair<TKey, TValue> pair) => pair.pair;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static implicit operator System.Collections.Generic.KeyValuePair         <TKey, TValue>(in RefKeyValuePair<TKey, TValue> pair) => (System.Collections.Generic.KeyValuePair<TKey, TValue>) pair.pair;
      #if !NET7_0_OR_GREATER
        [GameMethod(AggressiveInlining)] public static implicit operator System.ValueTuple<TKey, TValue>(in RefKeyValuePair<TKey, TValue> pair) => (pair.Key, pair.Value);
      #endif
    }

    [System.Serializable]
    public class RefList<T> : Game.Collections.RefReadOnlyList<T>, Game.Collections.IRefEquatable<RefList<T>>, System.Collections.Generic.IList<T>, System.Collections.ICollection, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.ICloneable {
      public new readonly struct Enumerator : System.Collections.Generic.IEnumerator<T> {
        public readonly ref T                                                  Current => ref this.enumerator.list.GetValue((uint) this.enumerator.index.value);
        public readonly Game.Collections.RefReadOnlyList<T>.Enumerator enumerator;
        readonly T                                                             System.Collections.Generic.IEnumerator<T>.Current => this.Current;
        readonly object                                                        System.Collections.IEnumerator.Current            => this.Current!;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        public Enumerator(RefList<T> list) => this.enumerator = new(list);

        /* … */
        [GameMethod(AggressiveInlining)] public readonly void Dispose                                () => this.enumerator.Dispose ();
        [GameMethod(AggressiveInlining)] public readonly bool MoveNext                               () => this.enumerator.MoveNext();
        [GameMethod(AggressiveInlining)] public readonly void Reset                                  () => this.enumerator.Reset   ();
        [GameMethod(AggressiveInlining)] readonly bool        System.Collections.IEnumerator.MoveNext() => this           .MoveNext();
        [GameMethod(AggressiveInlining)] readonly void        System.Collections.IEnumerator.Reset   () => this           .Reset   ();
        [GameMethod(AggressiveInlining)] readonly void        System.IDisposable.Dispose             () => this           .Dispose ();
      }

      /* … */
      [UnityEngine.HideInInspector]                             public  new uint Capacity                                             { get => this.capacity; set => this.EnsureCapacity(value); }
      [UnityEngine.HideInInspector, UnityEngine.SerializeField] private     uint capacity                                             =  0u;
      int                                                                        System.Collections.Generic.ICollection<T>.Count      => ((int) base.Count);
      bool                                                                       System.Collections.Generic.ICollection<T>.IsReadOnly => false;
      int                                                                        System.Collections.ICollection.Count                 => ((int) base.Count);
      bool                                                                       System.Collections.ICollection.IsSynchronized        => false;
      object                                                                     System.Collections.ICollection.SyncRoot              => this;
      bool                                                                       System.Collections.IList.IsFixedSize                 => false;
      bool                                                                       System.Collections.IList.IsReadOnly                  => false;

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)] public    RefList()                                                       : base()                                            {}
      [GameConstructor, GameMethod(AggressiveInlining)] public    RefList(uint                                        capacity)   : base(capacity = RefList<T>.GetCapacity(capacity)) => this.capacity = capacity;
      [GameConstructor, GameMethod(AggressiveInlining)] public    RefList(Game.Collections.RefReadOnlyList<T> list)       : this(list.Items, 0u, list.Count)                  {}
      [GameConstructor, GameMethod(AggressiveInlining)] public    RefList(RefList                                 <T> list)       : this(list.Items, 0u, list.Count)                  {}
      [GameConstructor, GameMethod(AggressiveInlining)] public    RefList(System.Collections.Generic.ICollection  <T> collection) : base()                                            { if (!collection.IsEmpty()) collection.CopyTo(base.Items = new T[this.capacity = RefList<T>.GetCapacity(base.Count = (uint) collection.Count)], 0); }
      [GameConstructor, GameMethod(AggressiveInlining)] public    RefList(System.Collections.Generic.IEnumerable  <T> enumerable) : base()                                            { if (!enumerable.IsEmpty()) { base.Items = new T[this.capacity = RefList<T>.GetCapacity(base.Count = Util.Enumerable.Count(enumerable))]; base.CopyFrom(enumerable.GetEnumerator()); } }
      [GameConstructor, GameMethod(AggressiveInlining)] public    RefList(in System.Memory                        <T> memory)     : this(memory.Span)                                 {}
      [GameConstructor, GameMethod(AggressiveInlining)] public    RefList(in System.ReadOnlyMemory                <T> memory)     : this(memory.Span)                                 {}
      [GameConstructor, GameMethod(AggressiveInlining)] public    RefList(in System.ReadOnlySpan                  <T> span)       : base()                                            { if (!span.IsEmpty()) span.CopyTo(new System.Span<T>(base.Items = new T[this.capacity = RefList<T>.GetCapacity(base.Count = (uint) span.Length)])); }
      [GameConstructor, GameMethod(AggressiveInlining)] public    RefList(in System.Span                          <T> span)       : this((System.ReadOnlySpan<T>) span)               {}
      [GameConstructor, GameMethod(AggressiveInlining)] public    RefList(in Util.Array<T>.Copyable                   copyable)   : base()                                            { if (!copyable.IsEmpty()) copyable.CopyTo(base.Items = new T[this.capacity = RefList<T>.GetCapacity(base.Count = copyable.Count)], 0); }
      [GameConstructor, GameMethod(AggressiveInlining)] protected RefList(T[]                                         array, uint index, uint length)                                 => Util.Array<T>.Copy(array, index, base.Items = Util.Array<T>.Create(this.capacity = RefList<T>.GetCapacity(base.Count = length)), 0u, length);

      /* … */
      [GameMethod(AggressiveInlining), GameResolution(0)] public           void                  Add            (in T                                      element)                                                                                          => this.Insert     (base.Count, in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] public           ref T                 Append         (in T                                      element)                                                                                          {  this.Insert     (base.Count, in element); return ref base.GetValue(base.Count - 1u); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public           void                  AddRange       (System.Collections.Generic.ICollection<T> collection)                                                                                       => this.InsertRange(base.Count, collection);
      [GameMethod(AggressiveInlining), GameResolution(0)] public           void                  AddRange       (System.Collections.Generic.IEnumerable<T> enumerable)                                                                                       => this.InsertRange(base.Count, enumerable);
      [GameMethod(AggressiveInlining), GameResolution(0)] public           void                  AddRange       (in System.Memory                      <T> memory)                                                                                           => this.InsertRange(base.Count, in memory);
      [GameMethod(AggressiveInlining), GameResolution(0)] public           void                  AddRange       (in System.ReadOnlyMemory              <T> memory)                                                                                           => this.InsertRange(base.Count, in memory);
      [GameMethod(AggressiveInlining), GameResolution(0)] public           void                  AddRange       (in System.ReadOnlySpan                <T> span)                                                                                             => this.InsertRange(base.Count, in span);
      [GameMethod(AggressiveInlining), GameResolution(0)] public           void                  AddRange       (in System.Span                        <T> span)                                                                                             => this.InsertRange(base.Count, in span);
      [GameMethod(AggressiveInlining), GameResolution(0)] public           void                  AddRange       (in Util.Array<T>.Copyable                 copyable)                                                                                         => this.InsertRange(base.Count, in copyable);
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    RefList<T>            AsCopy         ()                                                                                                                                           => new(this);
      [GameMethod(AggressiveInlining), GameResolution(0)] public           void                  Clear          ()                                                                                                                                           => base.Count = 0u;
      [GameMethod(AggressiveInlining), GameResolution(2)] public           RefList<U>            ConvertAll<U>  (Game.RefConverter        <T, U> converter)                                                                                          { RefList<U> list = new(base.Count); for (; list.Count != base.Count; ++list.Count) { list.SetValue(converter(ref base.GetValue(list.Count)), list.Count); } return list; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public    new    RefList<U>            ConvertAll<U>  (Game.RefReadOnlyConverter<T, U> converter)                                                                                          => this.ConvertAll([GameMethod(AggressiveInlining)] (ref T element) => converter(in element));
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    RefList<U>            ConvertAll<U>  (System.Converter                 <T, U> converter)                                                                                          => this.ConvertAll([GameMethod(AggressiveInlining)] (ref T element) => converter(element));
      [GameMethod(AggressiveInlining), GameResolution(0)] public           uint                  EnsureCapacity (uint                                    capacity, bool precise = false)                                                                     { if (capacity > this.capacity) { T[] list = base.Items; Util.Array<T>.Copy(list, 0u, base.Items = Util.Array<T>.Create(this.capacity = !precise ? RefList<T>.GetCapacity(capacity) : capacity), 0u, base.Count); } return this.capacity; }
      [GameMethod(AggressiveInlining), GameResolution(0)] private          void                  EnsureRange    (uint                                    index,    uint length)                                                                              { if (this.capacity < base.Count + length) this.EnsureCapacity(base.Count + length); if (index < base.Count) { Util.Array<T>.Copy(base.Items, index, base.Items, index + length, base.Count - index); base.Count += length; } else /* if (index > this.Count) */ (length, base.Count) = (length - System.Math.Min(length, index - base.Count), base.Count + length); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public           bool                  Equals         (in RefList                       <T>    list)                                                                                               => object.ReferenceEquals(list, this);
      [GameMethod(AggressiveInlining), GameResolution(2)] public           bool                  Exists         (Game.RefPredicate        <T>    predicate)                                                                                          { for (uint index = 0u; index != this.Count; ++index) { if (predicate(ref base.GetValue(index))) return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public    new    bool                  Exists         (Game.RefReadOnlyPredicate<T>    predicate)                                                                                          => base      .Exists(predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    bool                  Exists         (System.Predicate                 <T>    predicate)                                                                                          => base      .Exists(predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public           void                  Fill           (in T                                    element)                                                                                            => base.Items.Fill  (in element);
      [GameMethod(AggressiveInlining), GameResolution(2)] public           ref T                 Find           (Game.RefPredicate        <T>    predicate)                                                                                          { for (uint index = 0u; index != base.Count; ++index) { ref T element = ref base.GetValue(index); if (predicate(ref element)) return ref element; } return ref base.Null; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public    new    ref T                 Find           (Game.RefReadOnlyPredicate<T>    predicate)                                                                                          { for (uint index = 0u; index != base.Count; ++index) { ref T element = ref base.GetValue(index); if (predicate(in  element)) return ref element; } return ref base.Null; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    ref T                 Find           (System.Predicate                 <T>    predicate)                                                                                          => ref this.Find([GameMethod(AggressiveInlining)] (in T element) => predicate(element));
      [GameMethod(AggressiveInlining), GameResolution(2)] public           RefList<T>            FindAll        (Game.RefPredicate        <T>    predicate)                                                                                          { RefList<T> list = new(base.Count); for (uint index = 0u; index != base.Count; ++index) { ref T element = ref base.GetValue(index); if (predicate(ref element)) list.SetValue(in element, list.Count++); } list.TrimExcess(); return list; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public    new    RefList<T>            FindAll        (Game.RefReadOnlyPredicate<T>    predicate)                                                                                          => this.FindAll  ([GameMethod(AggressiveInlining)] (ref T element) => predicate(in element));
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    RefList<T>            FindAll        (System.Predicate                 <T>    predicate)                                                                                          => this.FindAll  ([GameMethod(AggressiveInlining)] (ref T element) => predicate(element));
      [GameMethod(AggressiveInlining), GameResolution(2)] public           int                   FindIndex      (Game.RefPredicate        <T>    predicate)                                                                                          => this.FindIndex(0u, base.Count, predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public    new    int                   FindIndex      (Game.RefReadOnlyPredicate<T>    predicate)                                                                                          => base.FindIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    int                   FindIndex      (System.Predicate                 <T>    predicate)                                                                                          => base.FindIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public           int                   FindIndex      (uint                                    index, Game.RefPredicate        <T> predicate)                                              { for (; index < base.Count; ++index) { if (predicate(ref base.GetValue(index))) return (int) index; } return -1; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public    new    int                   FindIndex      (uint                                    index, Game.RefReadOnlyPredicate<T> predicate)                                              => base.FindIndex(index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    int                   FindIndex      (uint                                    index, System.Predicate                 <T> predicate)                                              => base.FindIndex(index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public           int                   FindIndex      (uint                                    index, uint                                 length, Game.RefPredicate        <T> predicate) { for (uint end = System.Math.Min(base.Count, index + length); index < end; ++index) { if (predicate(ref base.GetValue(index))) return (int) index; } return -1; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public    new    int                   FindIndex      (uint                                    index, uint                                 length, Game.RefReadOnlyPredicate<T> predicate) => base.FindIndex(index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    int                   FindIndex      (uint                                    index, uint                                 length, System.Predicate                 <T> predicate) => base.FindIndex(index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public           ref T                 FindLast       (Game.RefPredicate        <T>    predicate)                                                                                          { for (uint index = base.Count; 0u != index--; ) { ref T element = ref base.GetValue(index); if (predicate(ref element)) return ref element; } return ref base.Null; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public    new    ref T                 FindLast       (Game.RefReadOnlyPredicate<T>    predicate)                                                                                          { for (uint index = base.Count; 0u != index--; ) { ref T element = ref base.GetValue(index); if (predicate(in  element)) return ref element; } return ref base.Null; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    ref T                 FindLast       (System.Predicate                 <T>    predicate)                                                                                          => ref this.FindLast     ([GameMethod(AggressiveInlining)] (in T element) => predicate(element));
      [GameMethod(AggressiveInlining), GameResolution(2)] public           int                   FindLastIndex  (Game.RefPredicate        <T>    predicate)                                                                                          =>     this.FindLastIndex(0u, base.Count, predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public    new    int                   FindLastIndex  (Game.RefReadOnlyPredicate<T>    predicate)                                                                                          =>     base.FindLastIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    int                   FindLastIndex  (System.Predicate                 <T>    predicate)                                                                                          =>     base.FindLastIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public           int                   FindLastIndex  (uint                                    index, Game.RefPredicate        <T> predicate)                                              { for (uint end = base.Count; end-- > index; ) { if (predicate(ref base.GetValue(end))) return (int) end; } return -1; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public    new    int                   FindLastIndex  (uint                                    index, Game.RefReadOnlyPredicate<T> predicate)                                              => base.FindLastIndex(index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    int                   FindLastIndex  (uint                                    index, System.Predicate                 <T> predicate)                                              => base.FindLastIndex(index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public           int                   FindLastIndex  (uint                                    index, uint                                 length, Game.RefPredicate        <T> predicate) { for (uint end = System.Math.Min(base.Count, index + length); end-- > index; ) { if (predicate(ref base.GetValue(end))) return (int) end; } return -1; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public    new    int                   FindLastIndex  (uint                                    index, uint                                 length, Game.RefReadOnlyPredicate<T> predicate) => base.FindLastIndex(index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    int                   FindLastIndex  (uint                                    index, uint                                 length, System.Predicate                 <T> predicate) => base.FindLastIndex(index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public           void                  ForEach        (Game.RefAction        <T>       action)                                                                                             { for (uint index = 0u; index != base.Count; ++index) action(ref base.GetValue(index)); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    void                  ForEach        (Game.RefReadOnlyAction<T>       action)                                                                                             => base.ForEach(action);
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    void                  ForEach        (System.Action                 <T>       action)                                                                                             => base.ForEach(action);
      [GameMethod(AggressiveInlining), GameResolution(0)] protected static uint                  GetCapacity    (uint                                    count)                                                                                              { if (0u != count) { count = System.Math.Max(count, 4u) - 1u; count |= count >>> 1; count |= count >>> 2; count |= count >>> 4; count |= count >>> 8; count |= count >>> 16; return count + 1u; } return 0u; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    RefList<T>.Enumerator GetEnumerator  ()                                                                                                                                           => new(this);
      [GameMethod(AggressiveInlining), GameResolution(0)] public    new    RefList<T>            GetRange       (uint index, uint length)                                                                                                                    => new(base.Items, index, length);

      [GameResolution(0)]
      private void HeapSort(uint begin, uint end, Game.RefComparison<T> comparison) /* ->> See `https://web.archive.org/web/20170509032649/http://www.cdn.geeksforgeeks.org/heap-sort/` */ {
        [GameMethod(AggressiveInlining)]
        static void Build(RefList<T> list, uint end, uint index, Game.RefComparison<T> comparison) {
          uint largest = index;
          uint left    = (index * 2u) + 1u;
          uint right   = (index * 2u) + 2u;

          // …
          largest = end > left  && comparison(ref list.GetValue(largest), ref list.GetValue(left))  < 0 ? left  : largest;
          largest = end > right && comparison(ref list.GetValue(largest), ref list.GetValue(right)) < 0 ? right : largest;

          if (index != largest) {
            (list.GetValue(index), list.GetValue(largest)) = (list.GetValue(largest), list.GetValue(index));
            Build(list, end, largest, comparison);
          }
        }

        for (uint index = begin + ((end - begin) >>> 1); begin != index--; )
        Build(this, end, index, comparison);

        for (uint index = end; begin != index--; ) {
          (base.GetValue(begin), base.GetValue(index)) = (base.GetValue(index), base.GetValue(begin));
          Build(this, index, begin, comparison);
        }
      }

      [GameMethod(AggressiveInlining), GameResolution(0)]
      public void Insert(uint index, in T element) {
        if (this.capacity == base.Count)
        this.EnsureCapacity(base.Count + 1u);

        if (index <= base.Count) {
          Util.Array<T>.Copy(base.Items, index, base.Items, index + 1u, base.Count - index);
          base.SetValue(in element, index);
        }

        ++base.Count;
      }

      [GameResolution(0)]
      private void InsertionSort(uint begin, uint end, Game.RefComparison<T> comparison) /* ->> See `https://web.archive.org/web/20240629152053/https://www.geeksforgeeks.org/insertion-sort-algorithm/` */ {
        for (uint index = begin + 1u; end != index; ++index) {
          T   element  = base.GetValue(index);
          int subindex = ((int) index) - 1;

          // …
          for (; subindex >= 0 && comparison(ref base.GetValue((uint) subindex), ref element) > 0; --subindex)
            base.SetValue(in base.GetValue((uint) subindex + 0u), (uint) subindex + 1u);

          base.SetValue(in element, (uint) ++subindex);
        }
      }

      [GameMethod(AggressiveInlining), GameResolution(0)] public void InsertRange(uint index, System.Collections.Generic.ICollection<T> collection) {                                                 this.EnsureRange(index, (uint) collection.Count); collection.CopyTo  (base.Items, (int) index); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public void InsertRange(uint index, System.Collections.Generic.IEnumerable<T> enumerable) { uint count = Util.Enumerable.Count(enumerable); this.EnsureRange(index, count);                   base      .CopyFrom(enumerable.GetEnumerator(), index, count); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public void InsertRange(uint index, in System.Memory                      <T> memory)     => this.InsertRange(index, memory.Span);
      [GameMethod(AggressiveInlining), GameResolution(0)] public void InsertRange(uint index, in System.ReadOnlyMemory              <T> memory)     => this.InsertRange(index, memory.Span);
      [GameMethod(AggressiveInlining), GameResolution(0)] public void InsertRange(uint index, in System.ReadOnlySpan                <T> span)       {  this.EnsureRange(index, (uint) span.Length); span.CopyTo(new System.Span<T>(base.Items, (int) index, (int) base.Count)); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public void InsertRange(uint index, in System.Span                        <T> span)       => this.InsertRange(index, (System.ReadOnlySpan<T>) span);
      [GameMethod(AggressiveInlining), GameResolution(0)] public void InsertRange(uint index, in Util.Array<T>.Copyable                 copyable)   {  this.EnsureRange(index, copyable.Count); copyable.CopyTo(base.Items, (int) index); }

      [GameMethod(AggressiveInlining), GameResolution(0)]
      public ref T Prepend(in T element) {
        this.Insert(0u, in element);
        return ref base.GetValue(0u);
      }

      [GameResolution(0)]
      private void QuickSort(uint begin, uint end, Game.RefComparison<T> comparison) /* ->> See `https://web.archive.org/web/20240629152053/https://www.geeksforgeeks.org/quick-sort-algorithm/` */ {
        [GameMethod(AggressiveInlining)]
        static uint Partition(RefList<T> list, uint begin, uint end, Game.RefComparison<T> comparison) {
          int   index = ((int) begin) - 1;
          ref T pivot = ref list.GetValue(end);

          // …
          for (uint subindex = begin; end > subindex; ++subindex)
          if (comparison(ref list.GetValue(subindex), ref pivot) < 0) {
            ++index;
            (list.GetValue((uint) index), list.GetValue(subindex)) = (list.GetValue(subindex), list.GetValue((uint) index));
          }

          ++index;
          (list.GetValue((uint) index), list.GetValue(end)) = (list.GetValue(end), list.GetValue((uint) index));

          return (uint) index;
        }

        // …
        if (begin < end) {
          uint index = Partition(this, begin, end, comparison);

          this.QuickSort(begin,      index - 1u, comparison);
          this.QuickSort(index + 1u, end,        comparison);
        }
      }

      [GameMethod(AggressiveInlining), GameResolution(0)] public  new ref T      Random                                                           ()                                                                                                                                   => ref (!base.IsEmpty() ? ref base.GetValue(Util.RandomUInt(base.Count)) : ref base.Null);
      [GameMethod(AggressiveInlining), GameResolution(0)] public      bool       Remove                                                           (in T                                 element)                                                                                       { int index = base.IndexOf(in element); if (index != -1) { this.RemoveAt((uint) index); return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public      uint       RemoveAll                                                        (Game.RefPredicate        <T> predicate)                                                                                     { T[] array = (T[]) base.Items.Clone(); uint length = 0u; for (uint index = 0u; index != base.Count; ++index) { ref T element = ref base.GetValue(index); if (!predicate(ref element)) array[length++] = element; } length = base.Count - length; base.Count -= length; base.Items = array; return length; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public      uint       RemoveAll                                                        (Game.RefReadOnlyPredicate<T> predicate)                                                                                     => this.RemoveAll([GameMethod(AggressiveInlining)] (ref T element) => predicate(in element));
      [GameMethod(AggressiveInlining), GameResolution(0)] public      uint       RemoveAll                                                        (System.Predicate                 <T> predicate)                                                                                     => this.RemoveAll([GameMethod(AggressiveInlining)] (ref T element) => predicate   (element));
      [GameMethod(AggressiveInlining), GameResolution(0)] public      void       RemoveAt                                                         (uint                                 index)                                                                                         { if (index < base.Count)                                                                     { Util.Array<T>.Copy(base.Items, index + 1u,     base.Items, index, base.Count - index - 1u);     base.Count -= 1u; } }
      [GameMethod(AggressiveInlining), GameResolution(0)] public      void       RemoveRange                                                      (uint                                 index, uint length)                                                                            { if (index < base.Count) { length = base.Count < index + length ? base.Count - index : length; Util.Array<T>.Copy(base.Items, index + length, base.Items, index, base.Count - index - length); base.Count -= length; } }
      [GameMethod(AggressiveInlining), GameResolution(0)] public      void       Reverse                                                          ()                                                                                                                                   => this      .Reverse(0u,          base.Count);
      [GameMethod(AggressiveInlining), GameResolution(0)] public      void       Reverse                                                          (uint index, uint length)                                                                                                            => base.Items.Reverse((int) index, (int) length);
      [GameMethod(AggressiveInlining), GameResolution(0)] public  new RefList<T> Slice                                                            (uint index, uint length)                                                                                                            => new(base.Items, index, length);
      [GameMethod(AggressiveInlining), GameResolution(0)] public  new void       Sort                                                             ()                                                                                                                                   => this.Sort(0u,    base.Count,                                  (Game.RefComparison        <T>) Game.Collections.RefComparer<T>.Default.Compare);
      [GameMethod(AggressiveInlining), GameResolution(6)] public      void       Sort                                                             (Game.Collections.IRefComparer        <T>? comparer)                                                                         => this.Sort(0u,    base.Count,                                  (Game.RefComparison        <T>) (comparer is not null ? comparer.Compare : Game.Collections.RefComparer        <T>.Default.Compare));
      [GameMethod(AggressiveInlining), GameResolution(5)] public  new void       Sort                                                             (Game.Collections.IRefReadOnlyComparer<T>? comparer)                                                                         => this.Sort(0u,    base.Count,                                  (Game.RefReadOnlyComparison<T>) (comparer is not null ? comparer.Compare : Game.Collections.RefReadOnlyComparer<T>.Default.Compare));
      [GameMethod(AggressiveInlining), GameResolution(3)] public      void       Sort                                                             (Game.RefComparison                   <T>? comparison)                                                                       => this.Sort(0u,    base.Count,                                  comparison ??                                                                                               Game.Collections.RefComparer<T>.Default.Compare);
      [GameMethod(AggressiveInlining), GameResolution(2)] public  new void       Sort                                                             (Game.RefReadOnlyComparison           <T>? comparison)                                                                       => this.Sort(0u,    base.Count,                                  comparison is not null ? ([GameMethod(AggressiveInlining)] (ref T a, ref T b) => comparison(in a, in b)) : Game.Collections.RefComparer<T>.Default.Compare);
      [GameMethod(AggressiveInlining), GameResolution(4)] public  new void       Sort                                                             (System.Collections.Generic.IComparer         <T>? comparer)                                                                         => this.Sort(0u,    base.Count,                                  comparer   is not null ? comparer.Compare                                                                 : System.Collections.Generic.Comparer <T>.Default.Compare);
      [GameMethod(AggressiveInlining), GameResolution(1)] public  new void       Sort                                                             (System.Comparison                            <T>? comparison)                                                                       => this.Sort(0u,    base.Count,                                  comparison is not null ? ([GameMethod(AggressiveInlining)] (ref T a, ref T b) => comparison(a, b))       : Game.Collections.RefComparer<T>.Default.Compare);
      [GameMethod(AggressiveInlining), GameResolution(3)] public      void       Sort                                                             (uint                                              index, uint length, Game.Collections.IRefComparer        <T>? comparer)   => this.Sort(index, System.Math.Min(base.Count, index + length), (Game.RefComparison<T>) (comparer is not null ? comparer.Compare                                                                       : Game.Collections.RefComparer<T>.Default.Compare));
      [GameMethod(AggressiveInlining), GameResolution(1)] public  new void       Sort                                                             (uint                                              index, uint length, Game.Collections.IRefReadOnlyComparer<T>? comparer)   => this.Sort(index, System.Math.Min(base.Count, index + length), (Game.RefComparison<T>) (comparer is not null ? ([GameMethod(AggressiveInlining)] (ref T a, ref T b) => comparer.Compare(in a, in b)) : Game.Collections.RefComparer<T>.Default.Compare));
      [GameMethod(AggressiveInlining), GameResolution(2)] private     void       Sort                                                             (uint                                              begin, uint end,    Game.RefComparison                   <T>  comparison) { if (base.Count <= 1u) return; if (base.Count <= 16u) this.InsertionSort(begin, end, comparison); else if (base.Count > System.Math.Log((double) base.Count) * 2.0) this.HeapSort(begin, end, comparison); else this.QuickSort(begin, end - 1u, comparison); }
      [GameMethod(AggressiveInlining), GameResolution(1)] private     void       Sort                                                             (uint                                              begin, uint end,    Game.RefReadOnlyComparison           <T>  comparison) => this.Sort      (begin, end,                                         ([GameMethod(AggressiveInlining)] (ref T a, ref T b) => comparison(in a, in b)));
      [GameMethod(AggressiveInlining), GameResolution(0)] public  new void       Sort                                                             (uint                                              index, uint length, System.Collections.Generic.IComparer         <T>? comparer)   => this.Sort      (index, System.Math.Min(base.Count, index + length), comparer is not null ? ([GameMethod(AggressiveInlining)] (ref T a, ref T b) => comparer.Compare(a, b)) : Game.Collections.RefComparer<T>.Default.Compare);
      [GameMethod(AggressiveInlining), GameResolution(0)] private     void       Sort                                                             (uint                                              begin, uint end,    System.Comparison                            <T>  comparison) => this.Sort      (begin, end,                                         ([GameMethod(AggressiveInlining)] (ref T a, ref T b) => comparison(a, b)));
      [GameMethod(AggressiveInlining), GameResolution(0)] public      void       TrimExcess                                                       ()                                                                                                                                   => this.TrimExcess(base.Count);
      [GameMethod(AggressiveInlining), GameResolution(0)] public      void       TrimExcess                                                       (uint                                 capacity)                                                                                      { capacity = RefList<T>.GetCapacity(capacity); if (capacity < this.capacity && capacity >= base.Count) System.Array.Resize(ref base.Items, (int) (this.capacity = capacity)); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public      bool       TrueForAll                                                       (Game.RefPredicate        <T> predicate)                                                                                     { for (uint index = 0u; index != base.Count; ++index) { if (!predicate(ref base.GetValue(index))) return false; } return true; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public  new bool       TrueForAll                                                       (Game.RefReadOnlyPredicate<T> predicate)                                                                                     => base.TrueForAll(predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public  new bool       TrueForAll                                                       (System.Predicate                 <T> predicate)                                                                                     => base.TrueForAll(predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public      bool       TryAdd                                                           (in T                                 element)                                                                                       { if (!base.Contains(in element)) { this.Add(in element); return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public      ref T      TryAppend                                                        (in T                                 element)                                                                                       { int index = base.IndexOf(in element); return ref (index == -1 ? ref this.Append(in element) : ref base.GetValue((uint) index)); }
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                   Game.Collections.IRefEquatable<RefList<T>>.Equals        (ref RefList                      <T> list)                                                                                          => this.Equals    (in list);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                   Game.Collections.IRefReadOnlyEquatable<RefList<T>>.Equals(in  RefList                      <T> list)                                                                                          => this.Equals    (in list);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                   System.Collections.Generic.ICollection<T>.Add                    (T                                    element)                                                                                       => this.Add       (element);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                   System.Collections.Generic.ICollection<T>.Clear                  ()                                                                                                                                   => this.Clear     ();
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                   System.Collections.Generic.ICollection<T>.Contains               (T            element)                                                                                                               => base.Contains  (element);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                   System.Collections.Generic.ICollection<T>.CopyTo                 (T[]          array, int index)                                                                                                      => base.CopyTo    (array, (uint) index);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                   System.Collections.Generic.ICollection<T>.Remove                 (T            element)                                                                                                               => this.Remove    (element);
      [GameMethod(AggressiveInlining), GameResolution(0)] int                    System.Collections.Generic.IList<T>.IndexOf                      (T            element)                                                                                                               => base.IndexOf   (element);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                   System.Collections.Generic.IList<T>.Insert                       (int          index, T element)                                                                                                      => this.Insert    ((uint) index, element);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                   System.Collections.Generic.IList<T>.RemoveAt                     (int          index)                                                                                                                 => this.RemoveAt  ((uint) index);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                   System.Collections.ICollection.CopyTo                            (System.Array array, int index)                                                                                                      { foreach (ref T element in this) array.SetValue(element, index++); }
      [GameMethod(AggressiveInlining), GameResolution(0)] int                    System.Collections.IList.Add                                     (object?      element)                                                                                                               {  this    .Add        ((T) element!); return (int) this.Count; }
      [GameMethod(AggressiveInlining), GameResolution(0)] void                   System.Collections.IList.Clear                                   ()                                                                                                                                   => this    .Clear      ();
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                   System.Collections.IList.Contains                                (object? element)                                                                                                                    => base    .Contains   ((T) element!);
      [GameMethod(AggressiveInlining), GameResolution(0)] int                    System.Collections.IList.IndexOf                                 (object? element)                                                                                                                    => base    .IndexOf    ((T) element!);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                   System.Collections.IList.Insert                                  (int     index, object? element)                                                                                                     => this    .Insert     ((uint) index, (T) element!);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                   System.Collections.IList.Remove                                  (object? element)                                                                                                                    => this    .Remove     ((T) element!);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                   System.Collections.IList.RemoveAt                                (int     index)                                                                                                                      => this    .RemoveAt   ((uint) index);
      [GameMethod(AggressiveInlining), GameResolution(0)] int                    System.Collections.IStructuralComparable.CompareTo               (object?                              value, System.Collections.IComparer         comparer)                                          => comparer.Compare    (this, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                   System.Collections.IStructuralEquatable.Equals                   (object?                              value, System.Collections.IEqualityComparer comparer)                                          => comparer.Equals     (this, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] int                    System.Collections.IStructuralEquatable.GetHashCode              (System.Collections.IEqualityComparer comparer)                                                                                      => comparer.GetHashCode(this);
      [GameMethod(AggressiveInlining), GameResolution(0)] object                 System.ICloneable.Clone                                          ()                                                                                                                                   => base    .Clone      ();
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                   System.IEquatable<RefList<T>>.Equals                             (RefList<T> list)                                                                                                                    => this    .Equals     (list);

      /* … */
      public new ref T          this                                    [uint         index] => ref base.GetValue(index);
      public new     RefList<T> this                                    [System.Range range] => new((System.ReadOnlyMemory<T>) this.Items[range]);
      T                         System.Collections.Generic.IList<T>.this[int          index] { get => this[(uint) index]; set => this[(uint) index] = value; }
      object?                   System.Collections.IList.this           [int          index] { get => this[(uint) index]; set => this[(uint) index] = (T) value!; }
    }
      [System.Serializable] public class AnimationCurveList : Game.Collections.RefList<UnityEngine.AnimationCurve> { [GameConstructor, GameMethod(AggressiveInlining)] public AnimationCurveList() : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public AnimationCurveList(uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public AnimationCurveList(System.Collections.Generic.IEnumerable<UnityEngine.AnimationCurve> enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public AnimationCurveList(in System.ReadOnlySpan<UnityEngine.AnimationCurve> span) : base(span) {} }
      [System.Serializable] public class BooleanList        : Game.Collections.RefList<System     .Boolean>        { [GameConstructor, GameMethod(AggressiveInlining)] public BooleanList       () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public BooleanList       (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public BooleanList       (System.Collections.Generic.IEnumerable<System     .Boolean>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public BooleanList       (in System.ReadOnlySpan<System     .Boolean>        span) : base(span) {} }
      [System.Serializable] public class BoundsList         : Game.Collections.RefList<UnityEngine.Bounds>         { [GameConstructor, GameMethod(AggressiveInlining)] public BoundsList        () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public BoundsList        (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public BoundsList        (System.Collections.Generic.IEnumerable<UnityEngine.Bounds>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public BoundsList        (in System.ReadOnlySpan<UnityEngine.Bounds>         span) : base(span) {} }
      [System.Serializable] public class BoundsIntList      : Game.Collections.RefList<UnityEngine.BoundsInt>      { [GameConstructor, GameMethod(AggressiveInlining)] public BoundsIntList     () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public BoundsIntList     (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public BoundsIntList     (System.Collections.Generic.IEnumerable<UnityEngine.BoundsInt>      enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public BoundsIntList     (in System.ReadOnlySpan<UnityEngine.BoundsInt>      span) : base(span) {} }
      [System.Serializable] public class ColorList          : Game.Collections.RefList<UnityEngine.Color>          { [GameConstructor, GameMethod(AggressiveInlining)] public ColorList         () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public ColorList         (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public ColorList         (System.Collections.Generic.IEnumerable<UnityEngine.Color>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public ColorList         (in System.ReadOnlySpan<UnityEngine.Color>          span) : base(span) {} }
      [System.Serializable] public class DoubleList         : Game.Collections.RefList<System     .Double>         { [GameConstructor, GameMethod(AggressiveInlining)] public DoubleList        () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public DoubleList        (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public DoubleList        (System.Collections.Generic.IEnumerable<System     .Double>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public DoubleList        (in System.ReadOnlySpan<System     .Double>         span) : base(span) {} }
      [System.Serializable] public class FloatList          : Game.Collections.RefList<System     .Single>         { [GameConstructor, GameMethod(AggressiveInlining)] public FloatList         () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public FloatList         (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public FloatList         (System.Collections.Generic.IEnumerable<System     .Single>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public FloatList         (in System.ReadOnlySpan<System     .Single>         span) : base(span) {} }
      [System.Serializable] public class GameObjectList     : Game.Collections.RefList<UnityEngine.GameObject>     { [GameConstructor, GameMethod(AggressiveInlining)] public GameObjectList    () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public GameObjectList    (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public GameObjectList    (System.Collections.Generic.IEnumerable<UnityEngine.GameObject>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public GameObjectList    (in System.ReadOnlySpan<UnityEngine.GameObject>     span) : base(span) {} }
      [System.Serializable] public class GradientList       : Game.Collections.RefList<UnityEngine.Gradient>       { [GameConstructor, GameMethod(AggressiveInlining)] public GradientList      () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public GradientList      (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public GradientList      (System.Collections.Generic.IEnumerable<UnityEngine.Gradient>       enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public GradientList      (in System.ReadOnlySpan<UnityEngine.Gradient>       span) : base(span) {} }
      [System.Serializable] public class IntList            : Game.Collections.RefList<System     .Int32>          { [GameConstructor, GameMethod(AggressiveInlining)] public IntList           () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public IntList           (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public IntList           (System.Collections.Generic.IEnumerable<System     .Int32>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public IntList           (in System.ReadOnlySpan<System     .Int32>          span) : base(span) {} }
      [System.Serializable] public class List<T>            : Game.Collections.RefList<T>                          { [GameConstructor, GameMethod(AggressiveInlining)] public List              () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public List              (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public List              (System.Collections.Generic.IEnumerable<T>                          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public List              (in System.ReadOnlySpan<T>                          span) : base(span) {} }
      [System.Serializable] public class LongList           : Game.Collections.RefList<System     .Int64>          { [GameConstructor, GameMethod(AggressiveInlining)] public LongList          () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public LongList          (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public LongList          (System.Collections.Generic.IEnumerable<System     .Int64>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public LongList          (in System.ReadOnlySpan<System     .Int64>          span) : base(span) {} }
      [System.Serializable] public class RectList           : Game.Collections.RefList<UnityEngine.Rect>           { [GameConstructor, GameMethod(AggressiveInlining)] public RectList          () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public RectList          (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public RectList          (System.Collections.Generic.IEnumerable<UnityEngine.Rect>           enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public RectList          (in System.ReadOnlySpan<UnityEngine.Rect>           span) : base(span) {} }
      [System.Serializable] public class RectIntList        : Game.Collections.RefList<UnityEngine.RectInt>        { [GameConstructor, GameMethod(AggressiveInlining)] public RectIntList       () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public RectIntList       (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public RectIntList       (System.Collections.Generic.IEnumerable<UnityEngine.RectInt>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public RectIntList       (in System.ReadOnlySpan<UnityEngine.RectInt>        span) : base(span) {} }
      [System.Serializable] public class StringList         : Game.Collections.RefList<System     .String>         { [GameConstructor, GameMethod(AggressiveInlining)] public StringList        () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public StringList        (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public StringList        (System.Collections.Generic.IEnumerable<System     .String>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public StringList        (in System.ReadOnlySpan<System     .String>         span) : base(span) {} }
      [System.Serializable] public class UIntList           : Game.Collections.RefList<System     .UInt32>         { [GameConstructor, GameMethod(AggressiveInlining)] public UIntList          () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public UIntList          (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public UIntList          (System.Collections.Generic.IEnumerable<System     .UInt32>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public UIntList          (in System.ReadOnlySpan<System     .UInt32>         span) : base(span) {} }
      [System.Serializable] public class ULongList          : Game.Collections.RefList<System     .UInt64>         { [GameConstructor, GameMethod(AggressiveInlining)] public ULongList         () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public ULongList         (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public ULongList         (System.Collections.Generic.IEnumerable<System     .UInt64>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public ULongList         (in System.ReadOnlySpan<System     .UInt64>         span) : base(span) {} }
      [System.Serializable] public class Vector2List        : Game.Collections.RefList<UnityEngine.Vector2>        { [GameConstructor, GameMethod(AggressiveInlining)] public Vector2List       () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector2List       (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector2List       (System.Collections.Generic.IEnumerable<UnityEngine.Vector2>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector2List       (in System.ReadOnlySpan<UnityEngine.Vector2>        span) : base(span) {} }
      [System.Serializable] public class Vector2IntList     : Game.Collections.RefList<UnityEngine.Vector2Int>     { [GameConstructor, GameMethod(AggressiveInlining)] public Vector2IntList    () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector2IntList    (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector2IntList    (System.Collections.Generic.IEnumerable<UnityEngine.Vector2Int>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector2IntList    (in System.ReadOnlySpan<UnityEngine.Vector2Int>     span) : base(span) {} }
      [System.Serializable] public class Vector3List        : Game.Collections.RefList<UnityEngine.Vector3>        { [GameConstructor, GameMethod(AggressiveInlining)] public Vector3List       () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector3List       (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector3List       (System.Collections.Generic.IEnumerable<UnityEngine.Vector3>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector3List       (in System.ReadOnlySpan<UnityEngine.Vector3>        span) : base(span) {} }
      [System.Serializable] public class Vector3IntList     : Game.Collections.RefList<UnityEngine.Vector3Int>     { [GameConstructor, GameMethod(AggressiveInlining)] public Vector3IntList    () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector3IntList    (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector3IntList    (System.Collections.Generic.IEnumerable<UnityEngine.Vector3Int>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector3IntList    (in System.ReadOnlySpan<UnityEngine.Vector3Int>     span) : base(span) {} }
      [System.Serializable] public class Vector4List        : Game.Collections.RefList<UnityEngine.Vector4>        { [GameConstructor, GameMethod(AggressiveInlining)] public Vector4List       () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector4List       (uint capacity) : base(capacity) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector4List       (System.Collections.Generic.IEnumerable<UnityEngine.Vector4>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector4List       (in System.ReadOnlySpan<UnityEngine.Vector4>        span) : base(span) {} }

    public /* sealed */ class RefReadOnlyComparer<T> : System.Collections.Generic.Comparer<T>, Game.Collections.IRefReadOnlyComparer<T>, System.Collections.Generic.IComparer<T>, System.Collections.IComparer {
      private abstract class Sentinel : Game.Collections.IRefReadOnlyComparable<Sentinel> {
        int Game.Collections.IRefReadOnlyComparable<Sentinel>.CompareTo(in Sentinel value) => default;
        int System.IComparable.CompareTo                                       (object?     value) => default;
        int System.IComparable<Sentinel>.CompareTo                             (Sentinel    value) => default;
      }

      /* … */
      private static readonly Game.RefReadOnlyComparison<T> CompareValue = (Game.RefReadOnlyComparison<T>) (
        typeof(Game.Collections.IRefReadOnlyComparable<T>).IsAssignableFrom(typeof(T)) ? ((Game.RefReadOnlyComparison<RefReadOnlyComparer<T>.Sentinel>) RefReadOnlyComparer<RefReadOnlyComparer<T>.Sentinel>.RefReadOnlyComparableCompare).Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.RefReadOnlyComparison<T>)) :
        typeof(System.IComparable                             <T>).IsAssignableFrom(typeof(T)) ? ((Game.RefReadOnlyComparison<RefReadOnlyComparer<T>.Sentinel>) RefReadOnlyComparer<RefReadOnlyComparer<T>.Sentinel>.ComparableCompare)           .Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.RefReadOnlyComparison<T>)) :
        typeof(System.IComparable)                                .IsAssignableFrom(typeof(T)) ? ((Game.RefReadOnlyComparison<RefReadOnlyComparer<T>.Sentinel>) RefReadOnlyComparer<RefReadOnlyComparer<T>.Sentinel>.ComparableCompare2)          .Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.RefReadOnlyComparison<T>)) :
        (Game.RefReadOnlyComparison<T>) RefReadOnlyComparer<T>.ObjectCompare<T>
      );
      protected        readonly Game.RefReadOnlyComparison<T> comparison       = RefReadOnlyComparer<T>.CompareValue;
      public    static new      RefReadOnlyComparer               <T> Default { get; } = new();

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)] public    RefReadOnlyComparer()                                                 : base() {}
      [GameConstructor, GameMethod(AggressiveInlining)] protected RefReadOnlyComparer(Game.RefReadOnlyComparison<T> comparison) : base() => this.comparison = comparison;

      /* … */
      [GameMethod(AggressiveInlining)] private static   int                    ComparableCompare <U>                                   (in U                                  a, in U    b) where U : System.IComparable<U>                              => a .CompareTo(b);
      [GameMethod(AggressiveInlining)] private static   int                    ComparableCompare2<U>                                   (in U                                  a, in U    b) where U : System.IComparable                                 => a!.CompareTo(b);
      [GameMethod(AggressiveInlining)] public  virtual  int                    Compare                                                 (in T                                  a, in T    b)                                                              { if (RefReadOnlyComparer<T>.CompareValue == this.comparison) { if (Game.Collections.RefReadOnlyEqualityComparer<T>.Default.Equals(in a, in b)) return 0; if (a is null) return b is null ? 0 : -1; if (b is null) return a is null ? 0 : +1; } return this.comparison(in a, in b); }
      [GameMethod(AggressiveInlining)] public  override int                    Compare                                                 (T                                     a, T       b)                                                              => this.Compare(in a, in b);
      [GameMethod(AggressiveInlining)] public  static   RefReadOnlyComparer<T> Create                                                  (Game.RefReadOnlyComparison<T> comparison)                                                                => new(comparison);
      [GameMethod(AggressiveInlining)] private static   int                    ObjectCompare               <U>                         (in U                                  a, in U    b)                                                              => System.Collections.Comparer.Default.Compare(a, b);
      [GameMethod(AggressiveInlining)] private static   int                    RefReadOnlyComparableCompare<U>                         (in U                                  a, in U    b) where U : Game.Collections.IRefReadOnlyComparable<U> => a.CompareTo(in b);
      [GameMethod(AggressiveInlining)] int                                     Game.Collections.IRefReadOnlyComparer<T>.Compare(in T                                  a, in T    b)                                                              => this.Compare(in a,   in b);
      [GameMethod(AggressiveInlining)] int                                     System.Collections.Generic.IComparer<T>.Compare         (T?                                    a, T?      b)                                                              => this.Compare(in a!,  in b!);
      [GameMethod(AggressiveInlining)] int                                     System.Collections.IComparer.Compare                    (object?                               a, object? b)                                                              => this.Compare((T) a!, (T) b!);
    }

    [System.Serializable]
    public class RefReadOnlyDictionary<TKey, TValue> : Game.Collections.IRefEquatable<RefReadOnlyDictionary<TKey, TValue>>, System.Collections.Generic.IReadOnlyCollection<Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>>, System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>, UnityEngine.ISerializationCallbackReceiver /* ->> Based on `System.Collections.Generic.Dictionary<TKey, TValue>` previously; See `https://web.archive.org/web/20240722203244/https://discussions.unity.com/t/finally-a-serializable-dictionary-for-unity-extracted-from-system-collections-generic/586385` */ {
      public readonly struct AlternateLookup<TAlternateKey> /* ->> Based on `System.Collections.Generic.Dictionary<TKey, TValue>.AlternateLookup<TAlternateKey>` */ {
        public readonly RefReadOnlyDictionary<TKey, TValue> Dictionary;

        /* … */
        [GameMethod(AggressiveInlining)]
        internal AlternateLookup(RefReadOnlyDictionary<TKey, TValue> dictionary) => this.Dictionary = dictionary;

        /* … */
        [GameMethod(AggressiveInlining)] public readonly bool ContainsKey(in TAlternateKey key)                                         => false;
        [GameMethod(AggressiveInlining)] public readonly bool Remove     (in TAlternateKey key)                                         => false;
        [GameMethod(AggressiveInlining)] public readonly bool Remove     (in TAlternateKey key, out TKey   actualKey, out TValue value) { actualKey = default!; value = default!; return false; }
        [GameMethod(AggressiveInlining)] public readonly bool TryAdd     (in TAlternateKey key, in TValue  value)                       => false;
        [GameMethod(AggressiveInlining)] public readonly bool TryGetValue(in TAlternateKey key, out TValue value)                       {                       value = default!; return false; }
        [GameMethod(AggressiveInlining)] public readonly bool TryGetValue(in TAlternateKey key, out TKey   actualKey, out TValue value) { actualKey = default!; value = default!; return false; }

        public readonly ref TValue this[in TAlternateKey key] => ref Util.Reference<TValue>.Null;
      }

      public readonly struct Enumerator : System.Collections.Generic.IEnumerator<Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IDictionaryEnumerator /* ->> Based on `System.Collections.Generic.Dictionary<TKey, TValue>.Enumerator` */ {
        private sealed class Index { public int value; }

        /* … */
        public  readonly Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue> Current                                                                                                        => new(this.dictionary, (uint) this.index.value);
        private readonly RefReadOnlyDictionary<TKey, TValue>                            dictionary                                                                                                     =  default!;
        private readonly Enumerator.Index                                               index                                                                                                          =  new() {value = -1};
        readonly Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>         System.Collections.Generic.IEnumerator<Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>>.Current => this.Current;
        readonly System.Collections.Generic.KeyValuePair         <TKey, TValue>         System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Current          => ((System.Collections.Generic.KeyValuePair<TKey, TValue>) this.Current);
        readonly System.Collections.DictionaryEntry                                     System.Collections.IDictionaryEnumerator.Entry                                                                 => new(this.dictionary.keys[(uint) this.index.value], this.dictionary.values[(uint) this.index.value]);
        readonly object                                                                 System.Collections.IDictionaryEnumerator.Key                                                                   => this.dictionary.keys  [(uint) this.index.value]!;
        readonly object?                                                                System.Collections.IDictionaryEnumerator.Value                                                                 => this.dictionary.values[(uint) this.index.value];
        readonly object                                                                 System.Collections.IEnumerator.Current                                                                         => this.Current;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        public Enumerator(RefReadOnlyDictionary<TKey, TValue> dictionary) {
          this.Reset();
          this.dictionary = dictionary;
        }

        /* … */
        [GameMethod(AggressiveInlining)] public readonly void Dispose                                () { /* Do nothing… */ }
        [GameMethod(AggressiveInlining)] public readonly bool MoveNext                               () { if (this.index.value + 1 < this.dictionary.Count) { ++this.index.value; return true; } return false; }
        [GameMethod(AggressiveInlining)] public readonly void Reset                                  () => this.index.value = -1;
        [GameMethod(AggressiveInlining)] readonly bool        System.Collections.IEnumerator.MoveNext() => this.MoveNext();
        [GameMethod(AggressiveInlining)] readonly void        System.Collections.IEnumerator.Reset   () => this.Reset   ();
        [GameMethod(AggressiveInlining)] readonly void        System.IDisposable.Dispose             () => this.Dispose ();
      }

      public /* sealed */ class KeyCollection : System.Collections.Generic.IReadOnlyCollection<TKey> {
        public readonly struct Enumerator : System.Collections.Generic.IEnumerator<TKey> /* ->> Based on `System.Collections.Generic.Dictionary<TKey, TValue>.KeyCollection.Enumerator` */ {
          public  readonly ref readonly TKey                              Current                                              => ref this.enumerator.Current.Key;
          private readonly RefReadOnlyDictionary<TKey, TValue>.Enumerator enumerator                                           =  default;
          readonly TKey                                                   System.Collections.Generic.IEnumerator<TKey>.Current => this.Current;
          readonly object                                                 System.Collections.IEnumerator.Current               => this.Current!;

          /* … */
          [GameConstructor, GameMethod(AggressiveInlining)]
          internal Enumerator(in RefReadOnlyDictionary<TKey, TValue>.Enumerator enumerator) => this.enumerator = enumerator;

          /* … */
          [GameMethod(AggressiveInlining)] public readonly void Dispose                                () => this.enumerator.Dispose ();
          [GameMethod(AggressiveInlining)] public readonly bool MoveNext                               () => this.enumerator.MoveNext();
          [GameMethod(AggressiveInlining)] public readonly void Reset                                  () => this.enumerator.Reset   ();
          [GameMethod(AggressiveInlining)] readonly bool        System.Collections.IEnumerator.MoveNext() => this           .MoveNext();
          [GameMethod(AggressiveInlining)] readonly void        System.Collections.IEnumerator.Reset   () => this           .Reset   ();
          [GameMethod(AggressiveInlining)] readonly void        System.IDisposable.Dispose             () => this           .Dispose ();
        }

        /* … */
        public  uint                                Count                                                      => this.dictionary.Count;
        private RefReadOnlyDictionary<TKey, TValue> dictionary                                                 =  default!;
        int                                         System.Collections.Generic.IReadOnlyCollection<TKey>.Count => ((int) this.Count);

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        public KeyCollection(RefReadOnlyDictionary<TKey, TValue> dictionary) => this.dictionary = dictionary;

        /* … */
        [GameMethod(AggressiveInlining)] public bool                                  Contains     (in TKey element)                               => this.dictionary.ContainsKey(in element);
        [GameMethod(AggressiveInlining)] public void                                  CopyTo       (TKey[]  array, uint index)                     { foreach (ref readonly TKey element in this) array[index++] = element; }
        [GameMethod(AggressiveInlining)] public KeyCollection.Enumerator              GetEnumerator()                                              => new(this.dictionary.GetEnumerator());
        [GameMethod(AggressiveInlining)] System.Collections.Generic.IEnumerator<TKey> System.Collections.Generic.IEnumerable<TKey>.GetEnumerator() => this.GetEnumerator();
        [GameMethod(AggressiveInlining)] System.Collections.IEnumerator               System.Collections.IEnumerable.GetEnumerator              () => this.GetEnumerator();
      }

      public /* sealed */ class ValueCollection : System.Collections.Generic.IReadOnlyCollection<TValue> {
        public readonly struct Enumerator : System.Collections.Generic.IEnumerator<TValue> /* ->> Based on `System.Collections.Generic.Dictionary<TKey, TValue>.ValueCollection.Enumerator` */ {
          public  readonly ref readonly TValue                            Current                                                => ref this.enumerator.Current.Value;
          private readonly RefReadOnlyDictionary<TKey, TValue>.Enumerator enumerator                                             =  default;
          readonly TValue                                                 System.Collections.Generic.IEnumerator<TValue>.Current => this.Current;
          readonly object                                                 System.Collections.IEnumerator.Current                 => this.Current!;

          /* … */
          [GameConstructor, GameMethod(AggressiveInlining)]
          internal Enumerator(in RefReadOnlyDictionary<TKey, TValue>.Enumerator enumerator) => this.enumerator = enumerator;

          /* … */
          [GameMethod(AggressiveInlining)] public readonly void Dispose                                () => this.enumerator.Dispose ();
          [GameMethod(AggressiveInlining)] public readonly bool MoveNext                               () => this.enumerator.MoveNext();
          [GameMethod(AggressiveInlining)] public readonly void Reset                                  () => this.enumerator.Reset   ();
          [GameMethod(AggressiveInlining)] readonly bool        System.Collections.IEnumerator.MoveNext() => this           .MoveNext();
          [GameMethod(AggressiveInlining)] readonly void        System.Collections.IEnumerator.Reset   () => this           .Reset   ();
          [GameMethod(AggressiveInlining)] readonly void        System.IDisposable.Dispose             () => this           .Dispose ();
        }

        /* … */
        public  uint                                Count                                                        => this.dictionary.Count;
        private RefReadOnlyDictionary<TKey, TValue> dictionary                                                   =  default!;
        int                                         System.Collections.Generic.IReadOnlyCollection<TValue>.Count => ((int) this.Count);

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        public ValueCollection(RefReadOnlyDictionary<TKey, TValue> dictionary) => this.dictionary = dictionary;

        /* … */
        [GameMethod(AggressiveInlining)] public void                                    CopyTo       (TValue[] array, uint index)                      { foreach (ref readonly TValue element in this) array[index++] = element; }
        [GameMethod(AggressiveInlining)] public ValueCollection.Enumerator              GetEnumerator()                                                => new(this.dictionary.GetEnumerator());
        [GameMethod(AggressiveInlining)] System.Collections.Generic.IEnumerator<TValue> System.Collections.Generic.IEnumerable<TValue>.GetEnumerator() => this.GetEnumerator();
        [GameMethod(AggressiveInlining)] System.Collections.IEnumerator                 System.Collections.IEnumerable.GetEnumerator                () => this.GetEnumerator();
      }

      /* … */
      [UnityEngine.HideInInspector]                             public   uint                                                        Capacity                                                                                                             => this.keys.Capacity; // ->> or `this.values.Capacity`
      [UnityEngine.HideInInspector, UnityEngine.SerializeField] public   Game.Collections.IRefReadOnlyEqualityComparer<TKey> Comparer                                                                                                             =  Game.Collections.RefReadOnlyEqualityComparer<TKey>.Default;
      [UnityEngine.HideInInspector]                             public   uint                                                        Count                                                                                                                => this.keys.Count; // ->> or `this.values.Count`
      [UnityEngine.HideInInspector]                             public   RefReadOnlyDictionary<TKey, TValue>.KeyCollection           Keys                                                                                                                 => new(this);
      [UnityEngine.HideInInspector, UnityEngine.SerializeField] internal Game.Collections.RefReadOnlyList<TKey>              keys                                                                                                                 =  Game.Collections.RefReadOnlyList<TKey>.Empty;
      [UnityEngine.HideInInspector]                             internal ref TValue                                                  Null                                                                                                                 => ref this.nullValue; // ->> `Util.Reference<TValue>.Null` didn’t work for some reason
      [UnityEngine.HideInInspector]                             private  TValue                                                      nullValue                                                                                                            =  default!;
      [UnityEngine.HideInInspector]                             public   RefReadOnlyDictionary<TKey, TValue>.ValueCollection         Values                                                                                                               => new(this);
      [UnityEngine.HideInInspector, UnityEngine.SerializeField] internal Game.Collections.RefReadOnlyList<TValue>            values                                                                                                               =  Game.Collections.RefReadOnlyList<TValue>.Empty;
      int                                                                                                                            System.Collections.Generic.IReadOnlyCollection<Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>>.Count => ((int) this.Count);
      int                                                                                                                            System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>.Count          => ((int) this.Count);
      System.Collections.Generic.IEnumerable<TKey>                                                                                   System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>.Keys                                                    => this.Keys;
      System.Collections.Generic.IEnumerable<TValue>                                                                                 System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>.Values                                                  => this.Values;

      public static readonly RefReadOnlyDictionary<TKey, TValue> Empty = new();

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RefReadOnlyDictionary()                                                                                                                                                                                                         {}
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RefReadOnlyDictionary(RefReadOnlyDictionary                 <TKey, TValue>                                                   dictionary) : this(dictionary, dictionary.Comparer)                                                {}
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RefReadOnlyDictionary(System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>> enumerable) : this(enumerable, Game.Collections.RefReadOnlyEqualityComparer<TKey>.Default) {}
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RefReadOnlyDictionary(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>          enumerable) : this(enumerable, Game.Collections.RefReadOnlyEqualityComparer<TKey>.Default) {}
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RefReadOnlyDictionary(RefReadOnlyDictionary                 <TKey, TValue>                                                   dictionary, Game.Collections.IRefReadOnlyEqualityComparer<TKey> comparer)                  { this.Comparer = comparer; if (!dictionary.IsEmpty()) { uint length = dictionary.Count;                  this.keys = new(length); this.values = new(length); this.CopyTo(this.keys, 0u, this.values, 0u, (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>>) dictionary); this.keys.Count = this.values.Count = length; } }
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RefReadOnlyDictionary(System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>> enumerable, Game.Collections.IRefReadOnlyEqualityComparer<TKey> comparer)                  { this.Comparer = comparer; if (!enumerable.IsEmpty()) { uint length = Util.Enumerable.Count(enumerable); this.keys = new(length); this.values = new(length); this.CopyTo(this.keys, 0u, this.values, 0u, enumerable);                                                                                                          this.keys.Count = this.values.Count = length; } }
      [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RefReadOnlyDictionary(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<TKey> comparer)                  { this.Comparer = comparer; if (!enumerable.IsEmpty()) { uint length = Util.Enumerable.Count(enumerable); this.keys = new(length); this.values = new(length); this.CopyTo(this.keys, 0u, this.values, 0u, enumerable);                                                                                                          this.keys.Count = this.values.Count = length; } }

      /* … */
      [GameMethod(AggressiveInlining), GameResolution(0)] public             RefReadOnlyDictionary<TKey, TValue>                                                 AsCopy                                                                                                              ()                                                                                                                                                                                                            => new(this);
      [GameMethod(AggressiveInlining), GameResolution(0)] public             RefReadOnlyDictionary<TKey, TValue>                                                 AsReadOnly                                                                                                          ()                                                                                                                                                                                                            => this;
      [GameMethod(AggressiveInlining), GameResolution(1)] public             bool                                                                                Contains                                                                                                            (in Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue> element)                                                                                                                                   { int index = this.GetValue(in element.Key); return index != -1 && Game.Collections.RefReadOnlyEqualityComparer<TValue>.Default.Equals(in this.values[(uint) index], in element.Value); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public             bool                                                                                Contains                                                                                                            (in System.Collections.Generic.KeyValuePair         <TKey, TValue> element)                                                                                                                                   { int index = this.GetValue(element.Key);    return index != -1 && Game.Collections.RefReadOnlyEqualityComparer<TValue>.Default.Equals(in this.values[(uint) index], element.Value); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public             bool                                                                                ContainsKey                                                                                                         (in TKey                                                           key)                                                                                                                                       => this.GetValue(in key) != -1;
      [GameMethod(AggressiveInlining), GameResolution(0)] public             bool                                                                                ContainsValue                                                                                                       (in TValue                                                         value)                                                                                                                                     => this.values.Contains(in value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public             void                                                                                CopyTo                                                                                                              (Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>[]  array, uint index)                                                                                                                         { for (uint subindex = 0u; subindex != this.Count; ++subindex) array[index++] = new(in this.keys[subindex], in this.values[subindex]); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public             void                                                                                CopyTo                                                                                                              (System.Collections.Generic.KeyValuePair         <TKey, TValue>[]  array, uint index)                                                                                                                         { for (uint subindex = 0u; subindex != this.Count; ++subindex) array[index++] = new(this.keys[subindex],    this.values[subindex]); }
      [GameMethod(NoInlining),         GameResolution(0)] protected          void                                                                                CopyTo                                                                                                              (Game.Collections.RefReadOnlyList        <TKey>            keys,  uint keyIndex, Game.Collections.RefReadOnlyList<TValue> values, uint valueIndex, System.Collections.IEnumerable enumerable) { [GameMethod(NoInlining)] void Copy(in TKey key, in TValue value) { if (key is null) { throw new System.ArgumentNullException("Dictionary element with null key can not be constructed"); } if (this.FindIndex(keys, in key) != -1) { throw new System.ArgumentException($"Dictionary element with the same key has already been constructed. Key: `{key.ToString()}`"); } keys.SetValue(in key, keyIndex); values.SetValue(in value, valueIndex); ++keyIndex; ++valueIndex; } for (System.Collections.IEnumerator enumerator = enumerable.GetEnumerator(); enumerator.MoveNext(); ) switch (enumerator.Current) { case Game.Collections.RefKeyValuePair<TKey, TValue> element: Copy(in element.Key, in element.Value); break; case Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue> element: Copy(in element.Key, in element.Value); break; default: System.Collections.Generic.KeyValuePair<TKey, TValue> _ = (System.Collections.Generic.KeyValuePair<TKey, TValue>) enumerator.Current; Copy(_.Key, _.Value); break; } }
      [GameMethod(AggressiveInlining), GameResolution(0)] public             bool                                                                                Equals                                                                                                              (in RefReadOnlyDictionary                <TKey, TValue> dictionary)                                                                                                                                           => object.ReferenceEquals(this, dictionary);
      [GameMethod(AggressiveInlining), GameResolution(0)] protected          int                                                                                 FindIndex                                                                                                           (Game.Collections.RefReadOnlyList<TKey>         keys, in TKey key)                                                                                                                                    { if (key is not null) { for (uint index = 0u; index != keys.Count; ++index) if (this.Comparer.Equals(in keys[index], in key)) return (int) index; } return -1; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public             RefReadOnlyDictionary<TKey, TValue>.AlternateLookup<TAlternateKey>                  GetAlternateLookup<TAlternateKey>                                                                                   ()                                                                                                                                                                                                            => new(this);
      [GameMethod(AggressiveInlining), GameResolution(0)] public             RefReadOnlyDictionary<TKey, TValue>.Enumerator                                      GetEnumerator                                                                                                       ()                                                                                                                                                                                                            => new(this);
      [GameMethod(AggressiveInlining), GameResolution(0)] public             int                                                                                 GetValue                                                                                                            (in TKey key)                                                                                                                                                                                                 => this.FindIndex(this.keys, in key);
      [GameMethod(AggressiveInlining), GameResolution(0)] public             bool                                                                                IsEmpty                                                                                                             ()                                                                                                                                                                                                            => 0u == this.Count;
      [GameMethod(AggressiveInlining), GameResolution(0)] public             Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>                      Random                                                                                                              ()                                                                                                                                                                                                            => new(this, Util.RandomUInt(this.Count));
      [GameMethod(AggressiveInlining), GameResolution(0)] public             void                                                                                SetValue                                                                                                            (in TValue value, int index)                                                                                                                                                                                  => this.values.SetValue(in value, (uint) index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public    override string?                                                                             ToString                                                                                                            ()                                                                                                                                                                                                            { uint end = this.Count, index = 0u; if (end != index) unsafe { System.Text.StringBuilder builder = new(); char* separator = stackalloc[] {',', ' '}; foreach (Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue> element in this) { builder.Append(element.ToString()); if (end == ++index) return $"({end}) [{builder.ToString()}]"; builder.Append(separator, 2); } } return "(0) []"; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public             bool                                                                                TryGetAlternateLookup<TAlternateKey>                                                                                (out RefReadOnlyDictionary<TKey, TValue>.AlternateLookup<TAlternateKey> lookup)                                                                                                                               { lookup = this.GetAlternateLookup<TAlternateKey>(); return false; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public             bool                                                                                TryGetValue                                                                                                         (in TKey                                                                key, out TValue value)                                                                                                                { int index = this.GetValue(in key); if (index != -1) { value = this.values[(uint) index]; return true; } value = default!; return false; }
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                                                                   Game.Collections.IRefEquatable<RefReadOnlyDictionary<TKey, TValue>>.Equals                                  (ref RefReadOnlyDictionary<TKey, TValue>                                dictionary)                                                                                                                           => this.Equals       (in dictionary);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                                                                   Game.Collections.IRefReadOnlyEquatable<RefReadOnlyDictionary<TKey, TValue>>.Equals                          (in  RefReadOnlyDictionary<TKey, TValue>                                dictionary)                                                                                                                           => this.Equals       (in dictionary);
      [GameMethod(AggressiveInlining), GameResolution(0)] System.Collections.Generic.IEnumerator<Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<TKey, TValue>>.GetEnumerator()                                                                                                                                                                                                            => this.GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)] System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>          System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>.GetEnumerator         ()                                                                                                                                                                                                            => this.GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                                                                   System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>.ContainsKey                                            (TKey                                key)                                                                                                                                                                     => this.ContainsKey  (in key);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                                                                   System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>.TryGetValue                                            (TKey                                key, out TValue value)                                                                                                                                                   => this.TryGetValue  (in key, out value);
      [GameMethod(AggressiveInlining), GameResolution(0)] System.Collections.IEnumerator                                                                         System.Collections.IEnumerable.GetEnumerator                                                                        ()                                                                                                                                                                                                            => this.GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                                                                   System.IEquatable<RefReadOnlyDictionary<TKey, TValue>>.Equals                                                       (RefReadOnlyDictionary<TKey, TValue> dictionary)                                                                                                                                                              => this.Equals       (dictionary);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                                                                   UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize                                                       ()                                                                                                                                                                                                            { ((UnityEngine.ISerializationCallbackReceiver) this.keys).OnAfterDeserialize(); ((UnityEngine.ISerializationCallbackReceiver) this.values).OnAfterDeserialize(); }
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                                                                   UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize                                                        ()                                                                                                                                                                                                            { ((UnityEngine.ISerializationCallbackReceiver) this.keys).OnBeforeSerialize (); ((UnityEngine.ISerializationCallbackReceiver) this.values).OnBeforeSerialize (); }

      public ref TValue this                                                             [in TKey key] { get { int index = this.GetValue(in key); if (index != -1) { return ref this.values.GetValue((uint) index); } throw new System.Collections.Generic.KeyNotFoundException(key?.ToString()); } }
      TValue            System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>.this[TKey key]    { get { int index = this.GetValue(in key); if (index != -1) { return this.values[(uint) index]; }              throw new System.Collections.Generic.KeyNotFoundException(key?.ToString()); } }
    }
      [System.Serializable] public class AnimationCurveReadOnlyDictionary : Game.Collections.RefReadOnlyDictionary<string, UnityEngine.AnimationCurve> { public static new readonly AnimationCurveReadOnlyDictionary Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public AnimationCurveReadOnlyDictionary() : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public AnimationCurveReadOnlyDictionary(Game.Collections.RefReadOnlyDictionary<string, UnityEngine.AnimationCurve> dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public AnimationCurveReadOnlyDictionary(System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.AnimationCurve>> enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public AnimationCurveReadOnlyDictionary(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.AnimationCurve>> enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public AnimationCurveReadOnlyDictionary(Game.Collections.RefReadOnlyDictionary<string, UnityEngine.AnimationCurve> dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public AnimationCurveReadOnlyDictionary(System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.AnimationCurve>> enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public AnimationCurveReadOnlyDictionary(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.AnimationCurve>> enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class BooleanReadOnlyDictionary        : Game.Collections.RefReadOnlyDictionary<string, System     .Boolean>        { public static new readonly BooleanReadOnlyDictionary        Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BooleanReadOnlyDictionary       () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BooleanReadOnlyDictionary       (Game.Collections.RefReadOnlyDictionary<string, System     .Boolean>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BooleanReadOnlyDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Boolean>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BooleanReadOnlyDictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Boolean>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BooleanReadOnlyDictionary       (Game.Collections.RefReadOnlyDictionary<string, System     .Boolean>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BooleanReadOnlyDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Boolean>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BooleanReadOnlyDictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Boolean>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class BoundsIntReadOnlyDictionary      : Game.Collections.RefReadOnlyDictionary<string, UnityEngine.BoundsInt>      { public static new readonly BoundsIntReadOnlyDictionary      Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsIntReadOnlyDictionary     () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsIntReadOnlyDictionary     (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.BoundsInt>      dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BoundsIntReadOnlyDictionary     (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.BoundsInt>>      enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsIntReadOnlyDictionary     (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.BoundsInt>>      enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsIntReadOnlyDictionary     (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.BoundsInt>      dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BoundsIntReadOnlyDictionary     (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.BoundsInt>>      enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsIntReadOnlyDictionary     (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.BoundsInt>>      enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class BoundsReadOnlyDictionary         : Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Bounds>         { public static new readonly BoundsReadOnlyDictionary         Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsReadOnlyDictionary        () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsReadOnlyDictionary        (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Bounds>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BoundsReadOnlyDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Bounds>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsReadOnlyDictionary        (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Bounds>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsReadOnlyDictionary        (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Bounds>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public BoundsReadOnlyDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Bounds>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public BoundsReadOnlyDictionary        (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Bounds>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class CanvasRendererReadOnlyDictionary : Game.Collections.RefReadOnlyDictionary<string, UnityEngine.CanvasRenderer> { public static new readonly CanvasRendererReadOnlyDictionary Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public CanvasRendererReadOnlyDictionary() : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public CanvasRendererReadOnlyDictionary(Game.Collections.RefReadOnlyDictionary<string, UnityEngine.CanvasRenderer> dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public CanvasRendererReadOnlyDictionary(System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.CanvasRenderer>> enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public CanvasRendererReadOnlyDictionary(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.CanvasRenderer>> enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public CanvasRendererReadOnlyDictionary(Game.Collections.RefReadOnlyDictionary<string, UnityEngine.CanvasRenderer> dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public CanvasRendererReadOnlyDictionary(System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.CanvasRenderer>> enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public CanvasRendererReadOnlyDictionary(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.CanvasRenderer>> enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class ColorReadOnlyDictionary          : Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Color>          { public static new readonly ColorReadOnlyDictionary          Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ColorReadOnlyDictionary         () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ColorReadOnlyDictionary         (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Color>          dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public ColorReadOnlyDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Color>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ColorReadOnlyDictionary         (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Color>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ColorReadOnlyDictionary         (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Color>          dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public ColorReadOnlyDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Color>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ColorReadOnlyDictionary         (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Color>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class ReadOnlyDictionary<T>            : Game.Collections.RefReadOnlyDictionary<string, T>                          { public static new readonly ReadOnlyDictionary<T>            Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ReadOnlyDictionary              () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ReadOnlyDictionary              (Game.Collections.RefReadOnlyDictionary<string, T>                          dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public ReadOnlyDictionary              (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, T>>                          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ReadOnlyDictionary              (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, T>>                          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ReadOnlyDictionary              (Game.Collections.RefReadOnlyDictionary<string, T>                          dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public ReadOnlyDictionary              (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, T>>                          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ReadOnlyDictionary              (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, T>>                          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class DoubleReadOnlyDictionary         : Game.Collections.RefReadOnlyDictionary<string, System     .Double>         { public static new readonly DoubleReadOnlyDictionary         Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public DoubleReadOnlyDictionary        () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public DoubleReadOnlyDictionary        (Game.Collections.RefReadOnlyDictionary<string, System     .Double>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public DoubleReadOnlyDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Double>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public DoubleReadOnlyDictionary        (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Double>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public DoubleReadOnlyDictionary        (Game.Collections.RefReadOnlyDictionary<string, System     .Double>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public DoubleReadOnlyDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Double>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public DoubleReadOnlyDictionary        (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Double>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class FloatReadOnlyDictionary          : Game.Collections.RefReadOnlyDictionary<string, System     .Single>         { public static new readonly FloatReadOnlyDictionary          Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public FloatReadOnlyDictionary         () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public FloatReadOnlyDictionary         (Game.Collections.RefReadOnlyDictionary<string, System     .Single>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public FloatReadOnlyDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Single>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public FloatReadOnlyDictionary         (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Single>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public FloatReadOnlyDictionary         (Game.Collections.RefReadOnlyDictionary<string, System     .Single>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public FloatReadOnlyDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Single>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public FloatReadOnlyDictionary         (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Single>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class GameObjectReadOnlyDictionary     : Game.Collections.RefReadOnlyDictionary<string, UnityEngine.GameObject>     { public static new readonly GameObjectReadOnlyDictionary     Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GameObjectReadOnlyDictionary    () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GameObjectReadOnlyDictionary    (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.GameObject>     dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public GameObjectReadOnlyDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.GameObject>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GameObjectReadOnlyDictionary    (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.GameObject>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GameObjectReadOnlyDictionary    (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.GameObject>     dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public GameObjectReadOnlyDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.GameObject>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GameObjectReadOnlyDictionary    (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.GameObject>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class GradientReadOnlyDictionary       : Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Gradient>       { public static new readonly GradientReadOnlyDictionary       Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GradientReadOnlyDictionary      () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GradientReadOnlyDictionary      (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Gradient>       dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public GradientReadOnlyDictionary      (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Gradient>>       enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GradientReadOnlyDictionary      (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Gradient>>       enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GradientReadOnlyDictionary      (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Gradient>       dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public GradientReadOnlyDictionary      (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Gradient>>       enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public GradientReadOnlyDictionary      (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Gradient>>       enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class IntReadOnlyDictionary            : Game.Collections.RefReadOnlyDictionary<string, System     .Int32>          { public static new readonly IntReadOnlyDictionary            Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public IntReadOnlyDictionary           () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public IntReadOnlyDictionary           (Game.Collections.RefReadOnlyDictionary<string, System     .Int32>          dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public IntReadOnlyDictionary           (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Int32>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public IntReadOnlyDictionary           (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Int32>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public IntReadOnlyDictionary           (Game.Collections.RefReadOnlyDictionary<string, System     .Int32>          dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public IntReadOnlyDictionary           (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Int32>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public IntReadOnlyDictionary           (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Int32>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class LongReadOnlyDictionary           : Game.Collections.RefReadOnlyDictionary<string, System     .Int64>          { public static new readonly LongReadOnlyDictionary           Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public LongReadOnlyDictionary          () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public LongReadOnlyDictionary          (Game.Collections.RefReadOnlyDictionary<string, System     .Int64>          dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public LongReadOnlyDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Int64>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public LongReadOnlyDictionary          (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Int64>>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public LongReadOnlyDictionary          (Game.Collections.RefReadOnlyDictionary<string, System     .Int64>          dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public LongReadOnlyDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .Int64>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public LongReadOnlyDictionary          (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .Int64>>          enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class RectReadOnlyDictionary           : Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Rect>           { public static new readonly RectReadOnlyDictionary           Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectReadOnlyDictionary          () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectReadOnlyDictionary          (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Rect>           dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RectReadOnlyDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Rect>>           enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectReadOnlyDictionary          (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Rect>>           enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectReadOnlyDictionary          (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Rect>           dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RectReadOnlyDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Rect>>           enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectReadOnlyDictionary          (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Rect>>           enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class RectIntReadOnlyDictionary        : Game.Collections.RefReadOnlyDictionary<string, UnityEngine.RectInt>        { public static new readonly RectIntReadOnlyDictionary        Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectIntReadOnlyDictionary       () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectIntReadOnlyDictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.RectInt>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RectIntReadOnlyDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.RectInt>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectIntReadOnlyDictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.RectInt>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectIntReadOnlyDictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.RectInt>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public RectIntReadOnlyDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.RectInt>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public RectIntReadOnlyDictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.RectInt>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class StringReadOnlyDictionary         : Game.Collections.RefReadOnlyDictionary<string, System     .String>         { public static new readonly StringReadOnlyDictionary         Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public StringReadOnlyDictionary        () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public StringReadOnlyDictionary        (Game.Collections.RefReadOnlyDictionary<string, System     .String>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public StringReadOnlyDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .String>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public StringReadOnlyDictionary        (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .String>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public StringReadOnlyDictionary        (Game.Collections.RefReadOnlyDictionary<string, System     .String>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public StringReadOnlyDictionary        (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .String>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public StringReadOnlyDictionary        (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .String>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class UIntReadOnlyDictionary           : Game.Collections.RefReadOnlyDictionary<string, System     .UInt32>         { public static new readonly UIntReadOnlyDictionary           Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public UIntReadOnlyDictionary          () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public UIntReadOnlyDictionary          (Game.Collections.RefReadOnlyDictionary<string, System     .UInt32>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public UIntReadOnlyDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .UInt32>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public UIntReadOnlyDictionary          (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .UInt32>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public UIntReadOnlyDictionary          (Game.Collections.RefReadOnlyDictionary<string, System     .UInt32>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public UIntReadOnlyDictionary          (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .UInt32>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public UIntReadOnlyDictionary          (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .UInt32>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class ULongReadOnlyDictionary          : Game.Collections.RefReadOnlyDictionary<string, System     .UInt64>         { public static new readonly ULongReadOnlyDictionary          Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ULongReadOnlyDictionary         () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ULongReadOnlyDictionary         (Game.Collections.RefReadOnlyDictionary<string, System     .UInt64>         dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public ULongReadOnlyDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .UInt64>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ULongReadOnlyDictionary         (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .UInt64>>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ULongReadOnlyDictionary         (Game.Collections.RefReadOnlyDictionary<string, System     .UInt64>         dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public ULongReadOnlyDictionary         (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, System     .UInt64>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public ULongReadOnlyDictionary         (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, System     .UInt64>>         enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class Vector2ReadOnlyDictionary        : Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector2>        { public static new readonly Vector2ReadOnlyDictionary        Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2ReadOnlyDictionary       () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2ReadOnlyDictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector2>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector2ReadOnlyDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector2>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2ReadOnlyDictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector2>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2ReadOnlyDictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector2>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector2ReadOnlyDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector2>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2ReadOnlyDictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector2>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class Vector2IntReadOnlyDictionary     : Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector2Int>     { public static new readonly Vector2IntReadOnlyDictionary     Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2IntReadOnlyDictionary    () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2IntReadOnlyDictionary    (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector2Int>     dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector2IntReadOnlyDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector2Int>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2IntReadOnlyDictionary    (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector2Int>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2IntReadOnlyDictionary    (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector2Int>     dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector2IntReadOnlyDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector2Int>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector2IntReadOnlyDictionary    (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector2Int>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class Vector3ReadOnlyDictionary        : Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector3>        { public static new readonly Vector3ReadOnlyDictionary        Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3ReadOnlyDictionary       () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3ReadOnlyDictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector3>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector3ReadOnlyDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector3>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3ReadOnlyDictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector3>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3ReadOnlyDictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector3>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector3ReadOnlyDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector3>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3ReadOnlyDictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector3>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class Vector3IntReadOnlyDictionary     : Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector3Int>     { public static new readonly Vector3IntReadOnlyDictionary     Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3IntReadOnlyDictionary    () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3IntReadOnlyDictionary    (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector3Int>     dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector3IntReadOnlyDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector3Int>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3IntReadOnlyDictionary    (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector3Int>>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3IntReadOnlyDictionary    (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector3Int>     dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector3IntReadOnlyDictionary    (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector3Int>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector3IntReadOnlyDictionary    (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector3Int>>     enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }
      [System.Serializable] public class Vector4ReadOnlyDictionary        : Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector4>        { public static new readonly Vector4ReadOnlyDictionary        Empty = new(); [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector4ReadOnlyDictionary       () : base() {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector4ReadOnlyDictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector4>        dictionary) : base(dictionary) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector4ReadOnlyDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector4>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector4ReadOnlyDictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector4>>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector4ReadOnlyDictionary       (Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Vector4>        dictionary, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(dictionary, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(1)] public Vector4ReadOnlyDictionary       (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<string, UnityEngine.Vector4>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} [GameConstructor, GameMethod(AggressiveInlining), GameResolution(0)] public Vector4ReadOnlyDictionary       (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, UnityEngine.Vector4>>        enumerable, Game.Collections.IRefReadOnlyEqualityComparer<string> comparer) : base(enumerable, comparer) {} }

    public /* sealed */ class RefReadOnlyEqualityComparer<T> : System.Collections.Generic.EqualityComparer<T>, Game.Collections.IRefReadOnlyEqualityComparer<T> {
      private abstract class Sentinel : Game.Collections.IRefReadOnlyEquatable<Sentinel> {
        bool Game.Collections.IRefReadOnlyEquatable<Sentinel>.Equals(in Sentinel value) => default;
        bool System.IEquatable<Sentinel>.Equals                             (Sentinel    value) => default;
      }

      /* … */
      private static readonly Game.RefReadOnlyHasher            <T> GetHashCodeValue = [GameMethod(AggressiveInlining)] static (in T value) => System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(value);
      private static readonly Game.RefReadOnlyEqualityComparison<T> EqualsValue      = (Game.RefReadOnlyEqualityComparison<T>) (
        typeof(Game.Collections.IRefReadOnlyEquatable<T>).IsAssignableFrom(typeof(T)) ? ((Game.RefReadOnlyEqualityComparison<RefReadOnlyEqualityComparer<T>.Sentinel>) RefReadOnlyEqualityComparer<RefReadOnlyEqualityComparer<T>.Sentinel>.RefReadOnlyEquatableEquals).Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.RefReadOnlyEqualityComparison<T>)) :
        typeof(System.IEquatable                             <T>).IsAssignableFrom(typeof(T)) ? ((Game.RefReadOnlyEqualityComparison<RefReadOnlyEqualityComparer<T>.Sentinel>) RefReadOnlyEqualityComparer<RefReadOnlyEqualityComparer<T>.Sentinel>.EquatableEquals)           .Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.RefReadOnlyEqualityComparison<T>)) :
        (Game.RefReadOnlyEqualityComparison<T>) RefReadOnlyEqualityComparer<T>.ObjectEquals<T>
      );

      protected            readonly Game.RefReadOnlyEqualityComparison<T> comparison       = RefReadOnlyEqualityComparer<T>.EqualsValue;
      protected            Game.RefReadOnlyHasher                     <T> hasher           = RefReadOnlyEqualityComparer<T>.GetHashCodeValue;
      public    static new RefReadOnlyEqualityComparer                        <T> Default { get; } = new();

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)] public    RefReadOnlyEqualityComparer()                                                                                                    : base() {}
      [GameConstructor, GameMethod(AggressiveInlining)] protected RefReadOnlyEqualityComparer(Game.RefReadOnlyEqualityComparison<T> comparison, Game.RefReadOnlyHasher<T>? hasher) : base() { this.comparison = comparison; this.hasher = hasher ?? this.hasher; }

      /* … */
      [GameMethod(AggressiveInlining)] public  static   RefReadOnlyEqualityComparer<T> Create                                                              (Game.RefReadOnlyEqualityComparison<T> comparison, Game.RefReadOnlyHasher<T>? hasher = null)                    => new(comparison, hasher);
      [GameMethod(AggressiveInlining)] public  virtual  bool                           Equals                                                              (in T                                          a, in T                                        b)                                => RefReadOnlyEqualityComparer<T>.EqualsValue == this.comparison && a is null ? b is null : this.comparison(in a, in b);
      [GameMethod(AggressiveInlining)] public  override bool                           Equals                                                              (T                                             a, T                                           b)                                => this.Equals(in a!, in b!);
      [GameMethod(AggressiveInlining)] private static   bool                           EquatableEquals<U>                                                  (in U                                          a, in U                                        b) where U : System.IEquatable<U> => a.Equals(b);
      [GameMethod(AggressiveInlining)] public  virtual  int                            GetHashCode                                                         (in T                                          value)                                                                           => RefReadOnlyEqualityComparer<T>.GetHashCodeValue == this.hasher && value is null ? 0 : this.hasher(in value);
      [GameMethod(AggressiveInlining)] public  override int                            GetHashCode                                                         (T                                             value)                                                                           => this.GetHashCode(in value!);
      [GameMethod(AggressiveInlining)] private static   bool                           ObjectEquals              <U>                                       (in U                                          a, in U b)                                                                       => a!.Equals(b);
      [GameMethod(AggressiveInlining)] private static   bool                           RefReadOnlyEquatableEquals<U>                                       (in U                                          a, in U b) where U : Game.Collections.IRefReadOnlyEquatable<U>           => a .Equals(in b);
      [GameMethod(AggressiveInlining)] bool                                            Game.Collections.IRefReadOnlyEqualityComparer<T>.Equals     (in T                                          a, in T b)                                                                       => this.Equals     (in a, in b);
      [GameMethod(AggressiveInlining)] int                                             Game.Collections.IRefReadOnlyEqualityComparer<T>.GetHashCode(in T                                          value)                                                                           => this.GetHashCode(in value);
      [GameMethod(AggressiveInlining)] bool                                            System.Collections.Generic.IEqualityComparer<T>.Equals              (T?                                            a, T? b)                                                                         => this.Equals     (in a!, in b!);
      [GameMethod(AggressiveInlining)] int                                             System.Collections.Generic.IEqualityComparer<T>.GetHashCode         (T                                             value)                                                                           => this.GetHashCode(in value);
      [GameMethod(AggressiveInlining)] bool                                            System.Collections.IEqualityComparer.Equals                         (object?                                       a, object? b)                                                                    => this.Equals     ((T) a!, (T) b!);
      [GameMethod(AggressiveInlining)] int                                             System.Collections.IEqualityComparer.GetHashCode                    (object                                        value)                                                                           => this.GetHashCode((T) value);
    }

    public readonly struct RefReadOnlyKeyValuePair<TKey, TValue> : Game.Collections.IKeyValuePair /* ->> Based on `System.Collections.Generic.KeyValuePair<TKey, TValue>` (hence no `System.IEquatable<RefKeyValuePair<TKey, TValue>>` implementation) */ {
      private  readonly Game.Collections.RefReadOnlyDictionary<TKey, TValue>? dictionary                                   =  null;
      private  readonly uint                                                          index                                        =  0u;
      public   readonly ref readonly TKey                                             Key                                          => ref this.key;
      internal readonly ref TKey                                                      key                                          => ref (this.dictionary is not null ? ref this.dictionary!.keys.GetValue(this.index) : ref Util.Reference<(TKey key, TValue)>.Only(this.pair).key);
      private  readonly (TKey key, TValue value)[]                                    pair                                         =  System.Array.Empty<(TKey, TValue)>(); // ->> `System.Collections.Generic.KeyValuePair<TKey, TValue>` but `ref`-errable
      public   readonly ref readonly TValue                                           Value                                        => ref this.value;
      internal readonly ref TValue                                                    value                                        => ref (this.dictionary is not null ? ref this.dictionary!.values.GetValue(this.index) : ref Util.Reference<(TKey, TValue value)>.Only(this.pair).value);
      readonly object                                                                 Game.Collections.IKeyValuePair.Key   => this.Key!;
      readonly object?                                                                Game.Collections.IKeyValuePair.Value => this.Value;

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)] internal RefReadOnlyKeyValuePair(Game.Collections.RefReadOnlyDictionary<TKey, TValue> dictionary, uint      index) { this.dictionary = dictionary; this.index = index; }
      [GameConstructor, GameMethod(AggressiveInlining)] public   RefReadOnlyKeyValuePair(in TKey                                                      key,        in TValue value) => this.pair = new[] {(key, value)};

      /* … */
      [GameMethod(AggressiveInlining)] public          readonly void    Deconstruct(out TKey key, out TValue value) { key = this.Key; value = this.Value; }
      [GameMethod(AggressiveInlining)] public override readonly string? ToString   ()                               => $"[{this.Key}, {this.Value}]";

      [GameMethod(AggressiveInlining)] public static implicit operator System.Collections.Generic.KeyValuePair<TKey, TValue>(in RefReadOnlyKeyValuePair<TKey, TValue> pair) => new(pair.Key, pair.Value);
      #if !NET7_0_OR_GREATER
        [GameMethod(AggressiveInlining)] public static implicit operator System.ValueTuple<TKey, TValue>(in RefReadOnlyKeyValuePair<TKey, TValue> pair) => (pair.Key, pair.Value);
      #endif
    }

    [System.Serializable]
    public class RefReadOnlyList<T> : Game.Collections.IRefEquatable<RefReadOnlyList<T>>, System.Collections.Generic.IEnumerable<T>, System.Collections.Generic.IReadOnlyList<T>, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.ICloneable, UnityEngine.ISerializationCallbackReceiver /* ->> Based on `System.Collections.Generic.List<T>` and `System.Collections.ObjectModel.ReadOnlyCollection<T>`; See `https://web.archive.org/web/20241126212444/https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1?view=net-9.0` and `https://web.archive.org/web/20241117194530/https://learn.microsoft.com/en-us/dotnet/api/system.collections.objectmodel.readonlycollection-1?view=net-9.0` */ {
      public readonly struct Enumerator : System.Collections.Generic.IEnumerator<T> {
        internal sealed class Index { public int value; }

        /* … */
        public   readonly ref readonly T     Current                                           => ref this.list.GetValue((uint) this.index.value);
        internal readonly Enumerator.Index   index                                             =  new() {value = -1};
        internal readonly RefReadOnlyList<T> list                                              =  default!;
        readonly T                           System.Collections.Generic.IEnumerator<T>.Current => this.Current;
        readonly object                      System.Collections.IEnumerator.Current            => this.Current!;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        public Enumerator(RefReadOnlyList<T> list) {
          this.Reset();
          this.list = list;
        }

        /* … */
        [GameMethod(AggressiveInlining)] public readonly void Dispose                                () { /* Do nothing… */ }
        [GameMethod(AggressiveInlining)] public readonly bool MoveNext                               () { if (this.index.value + 1 < this.list.Count) { ++this.index.value; return true; } return false; }
        [GameMethod(AggressiveInlining)] public readonly void Reset                                  () => this.index.value = -1;
        [GameMethod(AggressiveInlining)] readonly bool        System.Collections.IEnumerator.MoveNext() => this.MoveNext();
        [GameMethod(AggressiveInlining)] readonly void        System.Collections.IEnumerator.Reset   () => this.Reset   ();
        [GameMethod(AggressiveInlining)] readonly void        System.IDisposable.Dispose             () => this.Dispose ();
      }

      [System.Serializable]
      private sealed class Serializable {
        [UnityEngine.SerializeField] public T value = default!;
      }

      /* … */
      [UnityEngine.HideInInspector]                             public   uint   Capacity                                                => this.Count;
      [UnityEngine.HideInInspector, UnityEngine.SerializeField] public   uint   Count { get; internal set; }                            =  0u;
      [UnityEngine.HideInInspector]                             public   bool   IsPending                                               => RefReadOnlyList<T>.Pending.Contains(this);
      [UnityEngine.HideInInspector, UnityEngine.SerializeField] internal T[]    Items                                                   =  System.Array.Empty<T>();
      [UnityEngine.HideInInspector]                             internal ref T  Null                                                    => ref this.nullElement; // ->> `Util.Reference<T>.Null` didn’t work for some reason
      [UnityEngine.HideInInspector]                             private  T      nullElement                                             =  default!;
      [UnityEngine.HideInInspector, UnityEngine.SerializeField] private  string serializedData                                          =  string.Empty;
      int                                                                       System.Collections.Generic.IReadOnlyCollection<T>.Count => ((int) this.Count);

      public   static readonly RefReadOnlyList<T>                                                          Empty   = new();
      internal static readonly System.Collections.Generic.List<UnityEngine.ISerializationCallbackReceiver> Pending = new();

      /* … ->> Availability of `System.Runtime.InteropServices.CollectionMarshal.AsSpan(…)` would replace `RefReadOnlyList<T>`’s entire purpose */
      [GameConstructor, GameMethod(AggressiveInlining)] public             RefReadOnlyList()                                                                                     {}
      [GameConstructor, GameMethod(AggressiveInlining)] internal           RefReadOnlyList(uint                                      capacity)                                   => this.Items = Util.Array<T>.Create(capacity);
      [GameConstructor, GameMethod(AggressiveInlining)] public             RefReadOnlyList(RefReadOnlyList                       <T> list)                                       => this.Count = (uint) (this.Items = (T[]) list.Items.Clone()).Length;
      [GameConstructor, GameMethod(AggressiveInlining)] public             RefReadOnlyList(System.Collections.Generic.ICollection<T> collection)                                 { if (!collection.IsEmpty()) { this.Items = new T[this.Count = (uint) collection.Count];           this.CopyFrom(((System.Collections.Generic.IEnumerable<T>) collection).GetEnumerator()); } }
      [GameConstructor, GameMethod(AggressiveInlining)] public             RefReadOnlyList(System.Collections.Generic.IEnumerable<T> enumerable)                                 { if (!enumerable.IsEmpty()) { this.Items = new T[this.Count = Util.Enumerable.Count(enumerable)]; this.CopyFrom(enumerable                                              .GetEnumerator()); } }
      [GameConstructor, GameMethod(AggressiveInlining)] public             RefReadOnlyList(in System.Memory                      <T> memory) : this(memory.Span)                 {}
      [GameConstructor, GameMethod(AggressiveInlining)] public             RefReadOnlyList(in System.ReadOnlyMemory              <T> memory) : this(memory.Span)                 {}
      [GameConstructor, GameMethod(AggressiveInlining)] public             RefReadOnlyList(in System.ReadOnlySpan                <T> span)                                       => this.Count = (uint) (this.Items = Util.Array<T>.From(span)).Length;
      [GameConstructor, GameMethod(AggressiveInlining)] public             RefReadOnlyList(in System.Span                        <T> span) : this((System.ReadOnlySpan<T>) span) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public             RefReadOnlyList(in Util.Array<T>.Copyable                 copyable)                                   { if (!copyable.IsEmpty()) copyable.CopyTo(this.Items = new T[this.Count = copyable.Count], 0); }
      [GameConstructor, GameMethod(AggressiveInlining)] protected internal RefReadOnlyList(T[]                                       array)                                      => this.Count = (uint) (this.Items = array)                                                                           .Length;
      [GameConstructor, GameMethod(AggressiveInlining)] protected          RefReadOnlyList(T[]                                       array, uint index, uint length)             => this.Count = (uint) (this.Items = Util.Array<T>.From(new System.ArraySegment<T>(array, (int) index, (int) length))).Length;

      /* … */
      [GameMethod(AggressiveInlining), GameResolution(0)] public            RefReadOnlyList<T>            AsCopy                                                                   ()                                                                                                                                                 => new(this);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            RefReadOnlyList<T>            AsReadOnly                                                               ()                                                                                                                                                 =>     this;
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           BinarySearch                                                             (in T element)                                                                                                                                     => this.BinarySearch(0u, this.Count, in element, null as Game.Collections.IRefReadOnlyComparer<T>);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           BinarySearch                                                             (in T element, Game.Collections.IRefReadOnlyComparer<T>? comparer)                                                                         => this.BinarySearch(0u, this.Count, in element, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           BinarySearch                                                             (in T element, System.Collections.Generic.IComparer         <T>? comparer)                                                                         => this.BinarySearch(0u, this.Count, in element, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           BinarySearch                                                             (uint index,   uint                                              length, in T element, Game.Collections.IRefReadOnlyComparer<T>? comparer) { for (length = System.Math.Min(length, this.Count); index <= length; ) { uint subindex = index + ((length - index) >>> 1); int comparison = (comparer ?? Game.Collections.RefReadOnlyComparer<T>.Default).Compare(in this.GetValue(subindex), in element); if (comparison < 0) { index  = subindex + 1u; continue; } if (comparison > 0) { length = subindex - 1u; continue; } return (int) subindex; } return -1; } // ->> Requires pre-sorted in ascending order
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           BinarySearch                                                             (uint index,   uint                                              length, in T element, System.Collections.Generic.IComparer         <T>? comparer) => this.BinarySearch(index, length, in element, comparer is not null ? Game.Collections.RefReadOnlyComparer<T>.Create([GameMethod(AggressiveInlining)] (in T a, in T b) => comparer.Compare(a, b)) : null);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            object                        Clone                                                                    ()                                                                                                                                                 => this.AsCopy      ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public            bool                          Contains                                                                 (in T                                         element)                                                                                             { for (uint index = this.Count; 0u != index--; ) { if (Game.Collections.RefReadOnlyEqualityComparer<T>.Default.Equals(in this.GetValue(index), in element)) return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            RefReadOnlyList<U>            ConvertAll<U>                                                            (Game.RefReadOnlyConverter     <T, U> converter)                                                                                           { RefReadOnlyList<U> list = new(this.Count); for (; list.Count != this.Count; ++list.Count) { list.SetValue(converter(in this.GetValue(list.Count)), list.Count); } return list; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            RefReadOnlyList<U>            ConvertAll<U>                                                            (System.Converter                      <T, U> converter)                                                                                           => this.ConvertAll([GameMethod(AggressiveInlining)] (in T element) => converter(element));
      [GameMethod(AggressiveInlining), GameResolution(0)] protected         void                          CopyFrom                                                                 (System.Collections.Generic.IEnumerator<T>    enumerator)                                                                                          => this.CopyFrom(enumerator, 0u);
      [GameMethod(AggressiveInlining), GameResolution(0)] protected         void                          CopyFrom                                                                 (System.Collections.Generic.IEnumerator<T>    enumerator, uint index)                                                                              { while (enumerator.MoveNext()) { this.SetValue(enumerator.Current, index++); } enumerator.Dispose(); }
      [GameMethod(AggressiveInlining), GameResolution(0)] protected         void                          CopyFrom                                                                 (System.Collections.Generic.IEnumerator<T>    enumerator, uint index, uint length)                                                                 { while (0u != length--) { enumerator.MoveNext(); this.SetValue(enumerator.Current,    index++); } enumerator.Dispose(); }
      [GameMethod(AggressiveInlining), GameResolution(0)] protected         void                          CopyFrom                                                                 (in System.ReadOnlySpan<T>.Enumerator         enumerator, uint index, uint length)                                                                 { while (0u != length--) { enumerator.MoveNext(); this.SetValue(in enumerator.Current, index++); } }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            void                          CopyTo                                                                   (T[]                                          array)                                                                                               => this.CopyTo    (0u, array, 0u,           this.Count);
      [GameMethod(AggressiveInlining), GameResolution(0)] internal          void                          CopyTo                                                                   (T[]                                          array, int  index)                                                                                   => this.CopyTo    (0u, array, (uint) index, this.Count); // ->> Strictly for `struct Util.Array<T>.Copyable` to work with
      [GameMethod(AggressiveInlining), GameResolution(1)] public            void                          CopyTo                                                                   (T[]                                          array, uint index)                                                                                   => this.CopyTo    (0u, array, index,        this.Count);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            void                          CopyTo                                                                   (uint                                         index, T[]  array, uint arrayIndex, uint length)                                                     => Util.Array<T>.Copy(this.Items, index, array, arrayIndex, length); // ->> Possible buffer overflow
      [GameMethod(AggressiveInlining), GameResolution(0)] public            bool                          Equals                                                                   (in RefReadOnlyList               <T>         list)                                                                                                => object.ReferenceEquals(this, list);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            bool                          Exists                                                                   (Game.RefReadOnlyPredicate<T>         predicate)                                                                                           { for (uint index = 0u; index != this.Count; ++index) { if (predicate(in this.GetValue(index))) return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            bool                          Exists                                                                   (System.Predicate                 <T>         predicate)                                                                                           => this.Exists([GameMethod(AggressiveInlining)] (in T element) => predicate(element));
      [GameMethod(AggressiveInlining), GameResolution(0)] public            ref readonly T                Find                                                                     (Game.RefReadOnlyPredicate<T>         predicate)                                                                                           { for (uint index = 0u; index != this.Count; ++index) { ref readonly T element = ref this.GetValue(index); if (predicate(in element)) return ref element; } return ref this.Null; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            ref readonly T                Find                                                                     (System.Predicate                 <T>         predicate)                                                                                           => ref this.Find([GameMethod(AggressiveInlining)] (in T element) => predicate(element));
      [GameMethod(AggressiveInlining), GameResolution(0)] public            RefReadOnlyList<T>            FindAll                                                                  (Game.RefReadOnlyPredicate<T>         predicate)                                                                                           { RefReadOnlyList<T> list = new(this.Count); for (uint index = 0u; index != this.Count; ++index) { ref readonly T element = ref this.GetValue(index); if (predicate(in element)) list.SetValue(in element, list.Count++); } return list; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            RefReadOnlyList<T>            FindAll                                                                  (System.Predicate                 <T>         predicate)                                                                                           => this.FindAll  ([GameMethod(AggressiveInlining)] (in T element) => predicate(element));
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           FindIndex                                                                (Game.RefReadOnlyPredicate<T>         predicate)                                                                                           => this.FindIndex(0u, this.Count, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           FindIndex                                                                (System.Predicate                 <T>         predicate)                                                                                           => this.FindIndex(0u, this.Count, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           FindIndex                                                                (uint                                         index, Game.RefReadOnlyPredicate<T> predicate)                                               { for (; index < this.Count; ++index) { if (predicate(in this.GetValue(index))) return (int) index; } return -1; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           FindIndex                                                                (uint                                         index, System.Predicate                 <T> predicate)                                               => this.FindIndex(index, index <= this.Count ? this.Count - index : 0u, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           FindIndex                                                                (uint                                         index, uint                                 length, Game.RefReadOnlyPredicate<T> predicate)  { for (uint end = System.Math.Min(this.Count, index + length); end > index; ++index) { if (predicate(in this.GetValue(index))) return (int) index; } return -1; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           FindIndex                                                                (uint                                         index, uint                                 length, System.Predicate                 <T> predicate)  => this.Items.FindIndex((int) index, (int) length, predicate)!;
      [GameMethod(AggressiveInlining), GameResolution(0)] public            ref readonly T                FindLast                                                                 (Game.RefReadOnlyPredicate<T>         predicate)                                                                                           { for (uint index = this.Count; 0u != index--; ) { ref readonly T element = ref this.GetValue(index); if (predicate(in element)) return ref element; } return ref this.Null; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            ref readonly T                FindLast                                                                 (System.Predicate                 <T>         predicate)                                                                                           => ref this.FindLast     ([GameMethod(AggressiveInlining)] (in T element) => predicate(element));
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           FindLastIndex                                                            (Game.RefReadOnlyPredicate<T>         predicate)                                                                                           =>     this.FindLastIndex(0u, this.Count, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           FindLastIndex                                                            (System.Predicate                 <T>         predicate)                                                                                           =>     this.FindLastIndex(0u, this.Count, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           FindLastIndex                                                            (uint                                         index, Game.RefReadOnlyPredicate<T> predicate)                                               { for (uint end = this.Count; end-- > index; ) { if (predicate(in this.GetValue(end))) return (int) end; } return -1; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           FindLastIndex                                                            (uint                                         index, System.Predicate                 <T> predicate)                                               => this.FindLastIndex(index, index <= this.Count ? this.Count - index : 0u, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           FindLastIndex                                                            (uint                                         index, uint                                 length, Game.RefReadOnlyPredicate<T> predicate)  { for (uint end = System.Math.Min(this.Count, index + length); end-- > index; ) { if (predicate(in this.GetValue(end))) return (int) end; } return -1; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           FindLastIndex                                                            (uint                                         index, uint                                 length, System.Predicate                 <T> predicate)  => this.Items.FindLastIndex((int) index, (int) length, predicate)!;
      [GameMethod(AggressiveInlining), GameResolution(0)] public            void                          ForEach                                                                  (Game.RefReadOnlyAction<T>            action)                                                                                              { for (uint index = 0u; index != this.Count; ++index) action(in this.GetValue(index)); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            void                          ForEach                                                                  (System.Action                 <T>            action)                                                                                              => this.ForEach([GameMethod(AggressiveInlining)] (in T element) => action(element));
      [GameMethod(AggressiveInlining), GameResolution(0)] public            RefReadOnlyList<T>.Enumerator GetEnumerator                                                            ()                                                                                                                                                 => new(this);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            RefReadOnlyList<T>            GetRange                                                                 (uint index, uint length)                                                                                                                          => new(this.Items, index, length);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            ref T                         GetValue                                                                 (uint index)                                                                                                                                       => ref Util.Reference<T>.At(this.Items, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           IndexOf                                                                  (in T element)                                                                                                                                     => this.IndexOf(in element, 0u,    this.Count);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           IndexOf                                                                  (in T element, uint index)                                                                                                                         => this.IndexOf(in element, index, this.Count);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           IndexOf                                                                  (in T element, uint index, uint                                  length)                                                                           { for (uint end = System.Math.Min(this.Count, index + length); end > index; ++index) { if (Game.Collections.RefReadOnlyEqualityComparer<T>.Default.Equals(in this.GetValue(index), in element)) return (int) index; } return -1; }
      [GameMethod(AggressiveInlining), GameResolution(0)] private           void                          InsertionSort                                                            (uint begin,   uint end,   Game.RefReadOnlyComparison<T> comparison)                                                                       { for (uint index = begin + 1u; end != index; ++index) { T element = this.GetValue(index); int subindex = ((int) index) - 1; for (; subindex >= 0 && comparison(in this.GetValue((uint) subindex), in element) > 0; --subindex) { this.SetValue(in this.GetValue((uint) subindex + 0u), (uint) subindex + 1u); } this.SetValue(in element, (uint) ++subindex); } }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            bool                          IsEmpty                                                                  ()                                                                                                                                                 => 0u == this.Count;
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           LastIndexOf                                                              (in T element)                                                                                                                                     => this.LastIndexOf(in element, 0u,    this.Count);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           LastIndexOf                                                              (in T element, uint index)                                                                                                                         => this.LastIndexOf(in element, index, this.Count);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            int                           LastIndexOf                                                              (in T element, uint index, uint length)                                                                                                            { for (uint end = System.Math.Min(this.Count, index + length); end-- > index; ) { if (Game.Collections.RefReadOnlyEqualityComparer<T>.Default.Equals(in this.GetValue(end), in element)) return (int) end; } return -1; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            ref readonly T                Random                                                                   ()                                                                                                                                                 => ref (!this.IsEmpty() ? ref this.GetValue(Util.RandomUInt(this.Count)) : ref this.Null);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            void                          SetValue                                                                 (in T element, uint index)                                                                                                                         => Util.Reference<T>.At(this.Items, index) = element;
      [GameMethod(AggressiveInlining), GameResolution(0)] public            RefReadOnlyList<T>            Slice                                                                    (uint index,   uint length)                                                                                                                        => new(this.Items, index, length);
      [GameMethod(AggressiveInlining), GameResolution(0)] public            void                          Sort                                                                     ()                                                                                                                                                 => this.Sort(0u,    this.Count,                                  (Game.RefReadOnlyComparison<T>) (Game.Collections.RefReadOnlyComparer<T>.Default.Compare));
      [GameMethod(AggressiveInlining), GameResolution(4)] public            void                          Sort                                                                     (Game.Collections.IRefReadOnlyComparer<T>? comparer)                                                                                       => this.Sort(0u,    this.Count,                                  (Game.RefReadOnlyComparison<T>) (comparer   is not null ? comparer.Compare : Game.Collections.RefReadOnlyComparer<T>.Default.Compare));
      [GameMethod(AggressiveInlining), GameResolution(2)] public            void                          Sort                                                                     (Game.RefReadOnlyComparison           <T>? comparison)                                                                                     => this.Sort(0u,    this.Count,                                  (Game.RefReadOnlyComparison<T>) (comparison is not null ? comparison       : Game.Collections.RefReadOnlyComparer<T>.Default.Compare));
      [GameMethod(AggressiveInlining), GameResolution(3)] public            void                          Sort                                                                     (System.Collections.Generic.IComparer         <T>? comparer)                                                                                       => this.Sort(0u,    this.Count,                                  (System.Comparison<T>)                  (comparer   is not null ? comparer.Compare : System.Collections.Generic.Comparer         <T>.Default.Compare));
      [GameMethod(AggressiveInlining), GameResolution(1)] public            void                          Sort                                                                     (System.Comparison                            <T>? comparison)                                                                                     => this.Sort(0u,    this.Count,                                  (System.Comparison<T>)                  (comparison is not null ? comparison       : System.Collections.Generic.Comparer         <T>.Default.Compare));
      [GameMethod(AggressiveInlining), GameResolution(1)] public            void                          Sort                                                                     (uint                                              index, uint length, Game.Collections.IRefReadOnlyComparer<T>? comparer)                 => this.Sort(index, System.Math.Min(this.Count, index + length), (Game.RefReadOnlyComparison<T>) (comparer   is not null ? comparer.Compare : Game.Collections.RefReadOnlyComparer<T>.Default.Compare));
      [GameMethod(AggressiveInlining), GameResolution(2)] private           void                          Sort                                                                     (uint                                              begin, uint end,    Game.RefReadOnlyComparison           <T>  comparison)               { if (this.Count > 1u) this.InsertionSort(begin, end, comparison); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            void                          Sort                                                                     (uint                                              index, uint length, System.Collections.Generic.IComparer         <T>? comparer)                 => this.Sort(index, System.Math.Min(this.Count, index + length), comparer is not null ? ([GameMethod(AggressiveInlining)] (in T a, in T b) => comparer.Compare(a, b)) : Game.Collections.RefReadOnlyComparer<T>.Default.Compare);
      [GameMethod(AggressiveInlining), GameResolution(0)] private           void                          Sort                                                                     (uint                                              begin, uint end,    System.Comparison                            <T>  comparison)               => this.Sort(begin, end,                                         ([GameMethod(AggressiveInlining)] (in T a, in T b) => comparison(a, b)));
      [GameMethod(AggressiveInlining), GameResolution(0)] public            T[]                           ToArray                                                                  ()                                                                                                                                                 { T[] array = (T[]) this.Items.Clone(); System.Array.Resize(ref array, (int) this.Count); return array; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public   override string?                       ToString                                                                 ()                                                                                                                                                 { uint end = this.Count, index = 0u; if (end != index) unsafe { System.Text.StringBuilder builder = new(); for (char* separator = stackalloc[] {',', ' '}; ; builder.Append(separator, 2)) { builder.Append(this.GetValue(index)); if (end == ++index) return $"({end}) [{builder.ToString()}]"; } } return "(0) []"; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            bool                          TrueForAll                                                               (Game.RefReadOnlyPredicate<T> predicate)                                                                                                   { for (uint index = 0u; index != this.Count; ++index) { if (!predicate(in this.GetValue(index))) return false; } return true; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public            bool                          TrueForAll                                                               (System.Predicate                 <T> predicate)                                                                                                   => this.TrueForAll([GameMethod(AggressiveInlining)] (in T element) => predicate(element));
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                            Game.Collections.IRefEquatable<RefReadOnlyList<T>>.Equals        (ref RefReadOnlyList              <T> list)                                                                                                        => this.Equals(in list);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                            Game.Collections.IRefReadOnlyEquatable<RefReadOnlyList<T>>.Equals(in  RefReadOnlyList              <T> list)                                                                                                        => this.Equals(in list);
      [GameMethod(AggressiveInlining), GameResolution(0)] System.Collections.Generic.IEnumerator<T>       System.Collections.Generic.IEnumerable<T>.GetEnumerator                  ()                                                                                                                                                 => (System.Collections.Generic.IEnumerator<T>) this.GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)] System.Collections.IEnumerator                  System.Collections.IEnumerable.GetEnumerator                             ()                                                                                                                                                 => (System.Collections.IEnumerator)            this.GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                             System.Collections.IStructuralComparable.CompareTo                       (object?                              value, System.Collections.IComparer         comparer)                                                        => comparer.Compare           (this, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                            System.Collections.IStructuralEquatable.Equals                           (object?                              value, System.Collections.IEqualityComparer comparer)                                                        => comparer.Equals            (this, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                             System.Collections.IStructuralEquatable.GetHashCode                      (System.Collections.IEqualityComparer comparer)                                                                                                    => comparer.GetHashCode       (this);
      [GameMethod(AggressiveInlining), GameResolution(0)] object                                          System.ICloneable.Clone                                                  ()                                                                                                                                                 => this    .Clone             ();
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                            System.IEquatable<RefReadOnlyList<T>>.Equals                             (RefReadOnlyList<T> list)                                                                                                                          => this    .Equals            (list);

      void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize() {
        int  index          = -1;
        bool isNonPrimitive = typeof(UnityEngine.Component).IsAssignableFrom(typeof(T)) || typeof(T) == typeof(UnityEngine.GameObject);

        // …
        if (isNonPrimitive && Util.Game.Object is null) {
          if (!RefList<T>.Pending.Contains(this))
          RefList<T>.Pending.Add(this);
        }

        if (this.IsPending)
        return;

        this.Items = this.serializedData.Substring(this.serializedData.IndexOf('\x01') + 1).Split('\x02', System.StringSplitOptions.None).ConvertAll(datum => {
          RefList<T>.Serializable serializable = new();

          // …
          ++index;

          if (isNonPrimitive && Util.Game.Object is not null) {
            // … ->> Catch prematurely modified `::Items` before repeated attempt to de-serialize
            if (index < this.Items.Length && null != this.Items[index])
            return this.Items[index];
          }

          if (!string.IsNullOrEmpty(datum)) {
            if (!isNonPrimitive)
              UnityEngine.JsonUtility.FromJsonOverwrite(datum, serializable);

            else {
              string[]                          data  = datum.Split('\x04', System.StringSplitOptions.None);
              UnityEngine.SceneManagement.Scene scene = default;

              // … ->> “UnItYeXcEpTiOn: GeTsCeNeByPaTh cAn oNlY Be cAlLeD FrOm tHe mAiN ThReAd.”, “UnItYeXcEpTiOn: GeTsCeNeByPaTh iS NoT AlLoWeD To bE CaLlEd dUrInG SeRiAlIzAtIoN, cAlL It fRoM AwAkE Or sTaRt iNsTeAd.”, …
              #if UNITY_EDITOR
                scene = UnityEditor.SceneManagement.EditorSceneManager.GetSceneByPath(Util.Reference<string>.First(data));
              #else
                scene = UnityEngine.SceneManagement.SceneManager.GetSceneByPath(Util.Reference<string>.First(data));
              #endif

              if (scene.IsValid()) {
                UnityEngine.GameObject? gameObject = null;
                bool                    rooted     = true;

                // …
                foreach (string hierarchy in Util.Reference<string>.Last(data).Split('\x05', System.StringSplitOptions.None)) {
                  data = hierarchy.Split('\x06', System.StringSplitOptions.None);

                  for ((System.Collections.IEnumerator enumerator, string name, uint siblingIndex) = (!rooted ? gameObject!.transform.GetEnumerator() : scene.GetRootGameObjects().ConvertAll([GameMethod(AggressiveInlining)] static (gameObject) => gameObject.transform).GetEnumerator(), Util.Reference<string>.First(data), uint.Parse(Util.Reference<string>.Last(data))); enumerator.MoveNext(); )
                  if (name == ((UnityEngine.Transform) enumerator.Current).name) /* ->> `siblingIndex` useless for now since `UnityEngine.GameObject` tree could be updated; which means this may find duplicates */ {
                    gameObject = ((UnityEngine.Transform) enumerator.Current).gameObject;
                    break;
                  }

                  if (null == gameObject)
                  break;

                  rooted = false;
                }

                if (null != gameObject)
                serializable.value = (T) (typeof(UnityEngine.Component).IsAssignableFrom(typeof(T)) ? (object) gameObject.GetComponent(typeof(T)) : (object) gameObject);
              }
            }
          }

          // …
          return serializable.value!;
        });
        this.Count = uint.Parse(this.serializedData.Substring(0, this.serializedData.IndexOf('\x01')));
      }

      void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize() {
        string serializedData = this.serializedData;

        // …
        this.serializedData = this.Count.ToString() + '\x01';

        if (0u != this.Items.Length)
        for (uint index = 0u; ; this.serializedData += '\x02') {
          ref readonly T element = ref this.Items[index];

          // …
          if (index < this.Count && null != element && !Game.Collections.RefReadOnlyEqualityComparer<T>.Default.Equals(in element, default(T)!)) {
            string                  data       = string.Empty;
            UnityEngine.GameObject? gameObject = null;

            // …
            if      (element is UnityEngine.GameObject subGameObject) gameObject = subGameObject;
            else if (element is UnityEngine.Component  component)     gameObject = component.gameObject;

            // …
            if (gameObject is null)
              data = UnityEngine.JsonUtility.ToJson(new RefList<T>.Serializable() {value = element});

            else if (null != gameObject && gameObject.scene.IsValid()) {
              for (UnityEngine.Transform? hierarchy = gameObject.transform; null != hierarchy; ) {
                UnityEngine.Transform? hierarchyParent = hierarchy!.parent;
                uint                   siblingIndex    = 0u; // ->> `hierarchy.GetSiblingIndex()`

                // …
                for (System.Collections.IEnumerator enumerator = null != hierarchyParent ? hierarchyParent.GetEnumerator() : gameObject.scene.GetRootGameObjects().ConvertAll([GameMethod(AggressiveInlining)] static (gameObject) => gameObject.transform).GetEnumerator(); enumerator.MoveNext(); ++siblingIndex) {
                  if (hierarchy == (UnityEngine.Transform) enumerator.Current)
                  break; // ->> `siblingIndex = …;`
                }

                data      = hierarchy!.name + '\x06' + siblingIndex.ToString() + (!string.IsNullOrEmpty(data) ? '\x05' + data : string.Empty);
                hierarchy = hierarchyParent;
              }

              data = gameObject.scene.path + '\x04' + data;
            }

            this.serializedData += data;
          }

          if (++index == this.Items.Length)
          break;
        }

        if (serializedData != this.serializedData)
        Util.Game.AskToSave();
      }

      /* … */
      public ref readonly T     this                                            [uint         index] => ref this.GetValue(index);
      public RefReadOnlyList<T> this                                            [System.Range range] => new(this.Items[range]);
      T                         System.Collections.Generic.IReadOnlyList<T>.this[int          index] => this[(uint) index];
    }
      [System.Serializable] public class AnimationCurveReadOnlyList : Game.Collections.RefReadOnlyList<UnityEngine.AnimationCurve> { public static new readonly AnimationCurveReadOnlyList Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public AnimationCurveReadOnlyList() : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public AnimationCurveReadOnlyList(System.Collections.Generic.IEnumerable<UnityEngine.AnimationCurve> enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public AnimationCurveReadOnlyList(in System.ReadOnlySpan<UnityEngine.AnimationCurve> span) : base(span) {} }
      [System.Serializable] public class BooleanReadOnlyList        : Game.Collections.RefReadOnlyList<System     .Boolean>        { public static new readonly BooleanReadOnlyList        Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public BooleanReadOnlyList       () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public BooleanReadOnlyList       (System.Collections.Generic.IEnumerable<System     .Boolean>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public BooleanReadOnlyList       (in System.ReadOnlySpan<System     .Boolean>        span) : base(span) {} }
      [System.Serializable] public class BoundsReadOnlyList         : Game.Collections.RefReadOnlyList<UnityEngine.Bounds>         { public static new readonly BoundsReadOnlyList         Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public BoundsReadOnlyList        () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public BoundsReadOnlyList        (System.Collections.Generic.IEnumerable<UnityEngine.Bounds>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public BoundsReadOnlyList        (in System.ReadOnlySpan<UnityEngine.Bounds>         span) : base(span) {} }
      [System.Serializable] public class BoundsIntReadOnlyList      : Game.Collections.RefReadOnlyList<UnityEngine.BoundsInt>      { public static new readonly BoundsIntReadOnlyList      Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public BoundsIntReadOnlyList     () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public BoundsIntReadOnlyList     (System.Collections.Generic.IEnumerable<UnityEngine.BoundsInt>      enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public BoundsIntReadOnlyList     (in System.ReadOnlySpan<UnityEngine.BoundsInt>      span) : base(span) {} }
      [System.Serializable] public class ColorReadOnlyList          : Game.Collections.RefReadOnlyList<UnityEngine.Color>          { public static new readonly ColorReadOnlyList          Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public ColorReadOnlyList         () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public ColorReadOnlyList         (System.Collections.Generic.IEnumerable<UnityEngine.Color>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public ColorReadOnlyList         (in System.ReadOnlySpan<UnityEngine.Color>          span) : base(span) {} }
      [System.Serializable] public class DoubleReadOnlyList         : Game.Collections.RefReadOnlyList<System     .Double>         { public static new readonly DoubleReadOnlyList         Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public DoubleReadOnlyList        () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public DoubleReadOnlyList        (System.Collections.Generic.IEnumerable<System     .Double>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public DoubleReadOnlyList        (in System.ReadOnlySpan<System     .Double>         span) : base(span) {} }
      [System.Serializable] public class FloatReadOnlyList          : Game.Collections.RefReadOnlyList<System     .Single>         { public static new readonly FloatReadOnlyList          Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public FloatReadOnlyList         () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public FloatReadOnlyList         (System.Collections.Generic.IEnumerable<System     .Single>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public FloatReadOnlyList         (in System.ReadOnlySpan<System     .Single>         span) : base(span) {} }
      [System.Serializable] public class GameObjectReadOnlyList     : Game.Collections.RefReadOnlyList<UnityEngine.GameObject>     { public static new readonly GameObjectReadOnlyList     Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public GameObjectReadOnlyList    () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public GameObjectReadOnlyList    (System.Collections.Generic.IEnumerable<UnityEngine.GameObject>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public GameObjectReadOnlyList    (in System.ReadOnlySpan<UnityEngine.GameObject>     span) : base(span) {} }
      [System.Serializable] public class GradientReadOnlyList       : Game.Collections.RefReadOnlyList<UnityEngine.Gradient>       { public static new readonly GradientReadOnlyList       Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public GradientReadOnlyList      () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public GradientReadOnlyList      (System.Collections.Generic.IEnumerable<UnityEngine.Gradient>       enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public GradientReadOnlyList      (in System.ReadOnlySpan<UnityEngine.Gradient>       span) : base(span) {} }
      [System.Serializable] public class IntReadOnlyList            : Game.Collections.RefReadOnlyList<System     .Int32>          { public static new readonly IntReadOnlyList            Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public IntReadOnlyList           () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public IntReadOnlyList           (System.Collections.Generic.IEnumerable<System     .Int32>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public IntReadOnlyList           (in System.ReadOnlySpan<System     .Int32>          span) : base(span) {} }
      [System.Serializable] public class LongReadOnlyList           : Game.Collections.RefReadOnlyList<System     .Int64>          { public static new readonly LongReadOnlyList           Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public LongReadOnlyList          () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public LongReadOnlyList          (System.Collections.Generic.IEnumerable<System     .Int64>          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public LongReadOnlyList          (in System.ReadOnlySpan<System     .Int64>          span) : base(span) {} }
      [System.Serializable] public class ReadOnlyList<T>            : Game.Collections.RefReadOnlyList<T>                          { public static new readonly ReadOnlyList<T>            Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public ReadOnlyList              () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public ReadOnlyList              (System.Collections.Generic.IEnumerable<T>                          enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public ReadOnlyList              (in System.ReadOnlySpan<T>                          span) : base(span) {} }
      [System.Serializable] public class RectReadOnlyList           : Game.Collections.RefReadOnlyList<UnityEngine.Rect>           { public static new readonly RectReadOnlyList           Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public RectReadOnlyList          () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public RectReadOnlyList          (System.Collections.Generic.IEnumerable<UnityEngine.Rect>           enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public RectReadOnlyList          (in System.ReadOnlySpan<UnityEngine.Rect>           span) : base(span) {} }
      [System.Serializable] public class RectIntReadOnlyList        : Game.Collections.RefReadOnlyList<UnityEngine.RectInt>        { public static new readonly RectIntReadOnlyList        Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public RectIntReadOnlyList       () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public RectIntReadOnlyList       (System.Collections.Generic.IEnumerable<UnityEngine.RectInt>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public RectIntReadOnlyList       (in System.ReadOnlySpan<UnityEngine.RectInt>        span) : base(span) {} }
      [System.Serializable] public class StringReadOnlyList         : Game.Collections.RefReadOnlyList<System     .String>         { public static new readonly StringReadOnlyList         Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public StringReadOnlyList        () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public StringReadOnlyList        (System.Collections.Generic.IEnumerable<System     .String>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public StringReadOnlyList        (in System.ReadOnlySpan<System     .String>         span) : base(span) {} }
      [System.Serializable] public class UIntReadOnlyList           : Game.Collections.RefReadOnlyList<System     .UInt32>         { public static new readonly UIntReadOnlyList           Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public UIntReadOnlyList          () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public UIntReadOnlyList          (System.Collections.Generic.IEnumerable<System     .UInt32>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public UIntReadOnlyList          (in System.ReadOnlySpan<System     .UInt32>         span) : base(span) {} }
      [System.Serializable] public class ULongReadOnlyList          : Game.Collections.RefReadOnlyList<System     .UInt64>         { public static new readonly ULongReadOnlyList          Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public ULongReadOnlyList         () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public ULongReadOnlyList         (System.Collections.Generic.IEnumerable<System     .UInt64>         enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public ULongReadOnlyList         (in System.ReadOnlySpan<System     .UInt64>         span) : base(span) {} }
      [System.Serializable] public class Vector2ReadOnlyList        : Game.Collections.RefReadOnlyList<UnityEngine.Vector2>        { public static new readonly Vector2ReadOnlyList        Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public Vector2ReadOnlyList       () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector2ReadOnlyList       (System.Collections.Generic.IEnumerable<UnityEngine.Vector2>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector2ReadOnlyList       (in System.ReadOnlySpan<UnityEngine.Vector2>        span) : base(span) {} }
      [System.Serializable] public class Vector2IntReadOnlyList     : Game.Collections.RefReadOnlyList<UnityEngine.Vector2Int>     { public static new readonly Vector2IntReadOnlyList     Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public Vector2IntReadOnlyList    () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector2IntReadOnlyList    (System.Collections.Generic.IEnumerable<UnityEngine.Vector2Int>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector2IntReadOnlyList    (in System.ReadOnlySpan<UnityEngine.Vector2Int>     span) : base(span) {} }
      [System.Serializable] public class Vector3ReadOnlyList        : Game.Collections.RefReadOnlyList<UnityEngine.Vector3>        { public static new readonly Vector3ReadOnlyList        Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public Vector3ReadOnlyList       () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector3ReadOnlyList       (System.Collections.Generic.IEnumerable<UnityEngine.Vector3>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector3ReadOnlyList       (in System.ReadOnlySpan<UnityEngine.Vector3>        span) : base(span) {} }
      [System.Serializable] public class Vector3IntReadOnlyList     : Game.Collections.RefReadOnlyList<UnityEngine.Vector3Int>     { public static new readonly Vector3IntReadOnlyList     Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public Vector3IntReadOnlyList    () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector3IntReadOnlyList    (System.Collections.Generic.IEnumerable<UnityEngine.Vector3Int>     enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector3IntReadOnlyList    (in System.ReadOnlySpan<UnityEngine.Vector3Int>     span) : base(span) {} }
      [System.Serializable] public class Vector4ReadOnlyList        : Game.Collections.RefReadOnlyList<UnityEngine.Vector4>        { public static new readonly Vector4ReadOnlyList        Empty = new(); [GameConstructor, GameMethod(AggressiveInlining)] public Vector4ReadOnlyList       () : base() {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector4ReadOnlyList       (System.Collections.Generic.IEnumerable<UnityEngine.Vector4>        enumerable) : base(enumerable) {} [GameConstructor, GameMethod(AggressiveInlining)] public Vector4ReadOnlyList       (in System.ReadOnlySpan<UnityEngine.Vector4>        span) : base(span) {} }

    public class RefSortedCollection<TSort, T> : Game.Collections.IRefEquatable<RefSortedCollection<TSort, T>>, System.Collections.Generic.IList<T>, System.Collections.ICollection, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.ICloneable /* ->> No read-only analogue */ {
      public  uint                                                 Capacity                                             => this.items.Capacity;
      public  Game.Collections.IRefReadOnlyComparer<TSort> Comparer { get; private init; }                      =  Game.Collections.RefComparer<TSort>.Default;
      public  uint                                                 Count                                                => this.items.Count;
      private Game.Collections.RefList        <T>          items                                                =  new();
      public  Game.Collections.RefReadOnlyList<TSort>      Keys                                                 => (Game.Collections.RefReadOnlyList<TSort>) this.ranks;
      private Game.Collections.RefList        <TSort>      ranks                                                =  new();
      public  Game.Collections.RefReadOnlyList<T>          Values                                               => (Game.Collections.RefReadOnlyList<T>) this.items;
      int                                                          System.Collections.Generic.ICollection<T>.Count      => ((int) this.Count);
      bool                                                         System.Collections.Generic.ICollection<T>.IsReadOnly => false;
      int                                                          System.Collections.ICollection.Count                 => ((int) this.Count);
      bool                                                         System.Collections.ICollection.IsSynchronized        => false;
      object                                                       System.Collections.ICollection.SyncRoot              => this;
      bool                                                         System.Collections.IList.IsFixedSize                 => false;
      bool                                                         System.Collections.IList.IsReadOnly                  => false;

      /* … */
      [GameMethod(AggressiveInlining)] public RefSortedCollection()                                                                                                                                  : this(0u,                      null!)    {}
      [GameMethod(AggressiveInlining)] public RefSortedCollection(uint                                                    capacity)                                                                  : this(capacity,                null!)    {}
      [GameMethod(AggressiveInlining)] public RefSortedCollection(Game.Collections.IRefReadOnlyComparer<TSort>    comparer)                                                                  : this(2u,                      comparer) {}
      [GameMethod(AggressiveInlining)] public RefSortedCollection(System.Collections.Generic.IDictionary       <TSort, T> dictionary)                                                                : this((uint) dictionary.Count, null!)    {}
      [GameMethod(AggressiveInlining)] public RefSortedCollection(System.Collections.Generic.IDictionary       <TSort, T> dictionary, Game.Collections.IRefReadOnlyComparer<TSort> comparer) : this((uint) dictionary.Count, comparer) { foreach (System.Collections.Generic.KeyValuePair<TSort, T> element in dictionary) this.Add(element); }
      [GameMethod(AggressiveInlining)] public RefSortedCollection(uint                                                    capacity,   Game.Collections.IRefReadOnlyComparer<TSort> comparer)                                           { this.Comparer = comparer ?? this.Comparer; this.items.EnsureCapacity(capacity); this.ranks.EnsureCapacity(capacity); }

      /* … */
      [GameMethod(AggressiveInlining), GameResolution(1)] public          void                                           Add                                                                                 (in Game.Collections.RefKeyValuePair<TSort, T>                                              element)                                                         => this.Add(in element.Key, in element.Value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           Add                                                                                 (in System.Collections.Generic.KeyValuePair <TSort, T>                                              element)                                                         => this.Add(element.Key,    element.Value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           Add                                                                                 (in TSort                                                                                           rank, in T                                      element)         { this.ranks.Add(in rank); this.ranks.Sort(this.Comparer); this.items.Insert((uint) this.ranks.LastIndexOf(in rank), in element); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           AddRange                                                                            (in TSort                                                                                           rank, System.Collections.Generic.IEnumerable<T> enumerable)      { foreach (T                                                          element in enumerable) this.Add(in rank, in element); }
      [GameMethod(AggressiveInlining), GameResolution(1)] public          void                                           AddRange                                                                            (System.Collections.Generic.IEnumerable<Game.Collections.RefKeyValuePair<TSort, T>>         enumerable)                                                      { foreach (Game.Collections.RefKeyValuePair        <TSort, T> element in enumerable) this.Add(in element); }
      [GameMethod(AggressiveInlining), GameResolution(2)] public          void                                           AddRange                                                                            (System.Collections.Generic.IEnumerable<Game.Collections.RefReadOnlyKeyValuePair<TSort, T>> enumerable)                                                      { foreach (Game.Collections.RefReadOnlyKeyValuePair<TSort, T> element in enumerable) this.Add((System.Collections.Generic.KeyValuePair<TSort, T>) element); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           AddRange                                                                            (System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TSort, T>>          enumerable)                                                      { foreach (System.Collections.Generic.KeyValuePair         <TSort, T> element in enumerable) this.Add(in element); }
      [GameMethod(AggressiveInlining), GameResolution(1)] public          ref T                                          Append                                                                              (in Game.Collections.RefKeyValuePair<TSort, T>                                              element)                                                         => ref this.Append(in element.Key, in element.Value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          ref T                                          Append                                                                              (in System.Collections.Generic.KeyValuePair <TSort, T>                                              element)                                                         { (TSort rank, T element)[] pair = new[] {(element.Key, element.Value)}; return ref this.Append(in Util.Reference<(TSort rank, T)>.Only(pair).rank, in Util.Reference<(TSort, T element)>.Only(pair).element); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          ref T                                          Append                                                                              (in TSort                                                                                           rank, in T element)                                              { this.ranks.Add(in rank); this.ranks.Sort(this.Comparer); uint index = (uint) this.ranks.LastIndexOf(in rank); this.items.Insert(index, in element);    return ref this.items[index]; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          RefSortedCollection<TSort, T>                  AsCopy                                                                              ()                                                                                                                                                                   { RefSortedCollection<TSort, T> sorted = new(this.Count, this.Comparer); this.items.CopyTo(sorted.items.Items); this.ranks.CopyTo(sorted.ranks.Items); sorted.items.Count = sorted.ranks.Count = this.Count; return sorted; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          RefSortedCollection<TSort, T>                  AsReadOnly                                                                          ()                                                                                                                                                                   => this;
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            BinarySearch                                                                        (in T     element)                                                                                                                                                   => this.items.BinarySearch(in element);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            BinarySearch                                                                        (in T     element, Game.Collections.IRefReadOnlyComparer<T>? comparer)                                                                                       => this.items.BinarySearch(in element, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            BinarySearch                                                                        (in T     element, System.Collections.Generic.IComparer         <T>? comparer)                                                                                       => this.items.BinarySearch(in element, comparer);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            BinarySearch                                                                        (uint     index,   uint                                              length, in T element, Game.Collections.IRefReadOnlyComparer<T>? comparer)               => this.items.BinarySearch(index, length, in element, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            BinarySearch                                                                        (uint     index,   uint                                              length, in T element, System.Collections.Generic.IComparer         <T>? comparer)               => this.items.BinarySearch(index, length, in element, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            BinarySearchRank                                                                    (in TSort rank)                                                                                                                                                      => this.ranks.BinarySearch(in rank);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            BinarySearchRank                                                                    (in TSort rank,  Game.Collections.IRefReadOnlyComparer<TSort>? comparer)                                                                                     => this.ranks.BinarySearch(in rank, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            BinarySearchRank                                                                    (in TSort rank,  System.Collections.Generic.IComparer         <TSort>? comparer)                                                                                     => this.ranks.BinarySearch(in rank, comparer);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            BinarySearchRank                                                                    (uint     index, uint                                                  length, in TSort rank, Game.Collections.IRefReadOnlyComparer<TSort>? comparer)        => this.ranks.BinarySearch(index, length, in rank, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            BinarySearchRank                                                                    (uint     index, uint                                                  length, in TSort rank, System.Collections.Generic.IComparer         <TSort>? comparer)        => this.ranks.BinarySearch(index, length, in rank, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           Clear                                                                               ()                                                                                                                                                                   { this.items.Clear(); this.ranks.Clear(); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          object                                         Clone                                                                               ()                                                                                                                                                                   => this      .AsCopy  ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           Contains                                                                            (in T                                                    element)                                                                                                    => this.items.Contains(in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           ContainsRank                                                                        (in TSort                                                rank)                                                                                                       => this.ranks.Contains(in rank);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          RefSortedCollection<TSort, U>                  ConvertAll<U>                                                                       (Game.RefConverter        <T, U>                 converter)                                                                                                  { RefSortedCollection<TSort, U> sorted = new(this.Count, this.Comparer); this.items.ConvertAll(converter).CopyTo(sorted.items.Items); this.ranks.CopyTo(sorted.ranks.Items); sorted.items.Count = sorted.ranks.Count = this.Count; return sorted; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public          RefSortedCollection<TSort, U>                  ConvertAll<U>                                                                       (Game.RefReadOnlyConverter<T, U>                 converter)                                                                                                  => this      .ConvertAll([GameMethod(AggressiveInlining)] (ref T element) => converter(in element));
      [GameMethod(AggressiveInlining), GameResolution(0)] public          RefSortedCollection<TSort, U>                  ConvertAll<U>                                                                       (System.Converter                 <T, U>                 converter)                                                                                                  => this      .ConvertAll([GameMethod(AggressiveInlining)] (ref T element) => converter(element));
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           CopyTo                                                                              (T[]                                                     array)                                                                                                      => this.items.CopyTo    (array);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          void                                           CopyTo                                                                              (in Game.Collections.RefKeyValuePair<TSort, T>[] array)                                                                                                      => this      .CopyTo    (array, 0u);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           CopyTo                                                                              (in System.Collections.Generic.KeyValuePair <TSort, T>[] array)                                                                                                      => this      .CopyTo    (array, 0u);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           CopyTo                                                                              (T[]                                                     array,    int                                                     index)                                    => this.items.CopyTo    (array, index); // ->> Strictly for `struct Util.Array<T>.Copyable` to work with
      [GameMethod(AggressiveInlining), GameResolution(1)] public          void                                           CopyTo                                                                              (T[]                                                     array,    uint                                                    index)                                    => this.items.CopyTo    (array, index);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          void                                           CopyTo                                                                              (in Game.Collections.RefKeyValuePair<TSort, T>[] array,    uint                                                    index)                                    => this      .CopyTo    (0u, array, index, array.Length > index ? (uint) array.Length - index : 0u);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           CopyTo                                                                              (in System.Collections.Generic.KeyValuePair <TSort, T>[] array,    uint                                                    index)                                    => this      .CopyTo    (0u, array, index, array.Length > index ? (uint) array.Length - index : 0u);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           CopyTo                                                                              (uint                                                    index,    T[]                                                     array, uint arrayIndex, uint length)      => this.items.CopyTo    (index, array, arrayIndex, length);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          void                                           CopyTo                                                                              (uint                                                    index,    in Game.Collections.RefKeyValuePair<TSort, T>[] array, uint arrayIndex, uint length)      { for (; 0u != length-- && index < this.Count; ++index) array[arrayIndex++] = new(in this.ranks[index], in this.items[index]); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           CopyTo                                                                              (uint                                                    index,    in System.Collections.Generic.KeyValuePair <TSort, T>[] array, uint arrayIndex, uint length)      { for (; 0u != length-- && index < this.Count; ++index) array[arrayIndex++] = new(this.ranks[index],    this.items[index]); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           EnsureCapacity                                                                      (uint                                                    capacity, bool                                                    precise = false)                          { this.items.EnsureCapacity(capacity, precise); this.ranks.EnsureCapacity(capacity, precise); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           Equals                                                                              (in RefSortedCollection           <TSort, T>             collection)                                                                                                 =>     object.ReferenceEquals  (this, collection);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          bool                                           Exists                                                                              (Game.RefPredicate        <T>                    predicate)                                                                                                  =>     this.items.Exists       (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          bool                                           Exists                                                                              (Game.RefReadOnlyPredicate<T>                    predicate)                                                                                                  =>     this.items.Exists       (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           Exists                                                                              (System.Predicate                 <T>                    predicate)                                                                                                  =>     this.items.Exists       (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           ExistsRank                                                                          (Game.RefPredicate        <TSort>                predicate)                                                                                                  =>     this.ranks.Exists       (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          bool                                           ExistsRank                                                                          (Game.RefReadOnlyPredicate<TSort>                predicate)                                                                                                  =>     this.ranks.Exists       (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           ExistsRank                                                                          (System.Predicate                 <TSort>                predicate)                                                                                                  =>     this.ranks.Exists       (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           Fill                                                                                (in T                                                    element)                                                                                                    =>     this.items.Fill         (in element);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          ref T                                          Find                                                                                (Game.RefPredicate        <T>                    predicate)                                                                                                  => ref this.items.Find         (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          ref T                                          Find                                                                                (Game.RefReadOnlyPredicate<T>                    predicate)                                                                                                  => ref this.items.Find         (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          ref T                                          Find                                                                                (System.Predicate                 <T>                    predicate)                                                                                                  => ref this.items.Find         (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          Game.Collections.RefList<T>            FindAll                                                                             (Game.RefPredicate        <T>                    predicate)                                                                                                  =>     this.items.FindAll      (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          Game.Collections.RefList<T>            FindAll                                                                             (Game.RefReadOnlyPredicate<T>                    predicate)                                                                                                  =>     this.items.FindAll      (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          Game.Collections.RefList<T>            FindAll                                                                             (System.Predicate                 <T>                    predicate)                                                                                                  =>     this.items.FindAll      (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          int                                            FindIndex                                                                           (Game.RefPredicate        <T>                    predicate)                                                                                                  =>     this.items.FindIndex    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            FindIndex                                                                           (Game.RefReadOnlyPredicate<T>                    predicate)                                                                                                  =>     this.items.FindIndex    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            FindIndex                                                                           (System.Predicate                 <T>                    predicate)                                                                                                  =>     this.items.FindIndex    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          int                                            FindIndex                                                                           (uint                                                    index, Game.RefPredicate        <T> predicate)                                                      =>     this.items.FindIndex    (index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            FindIndex                                                                           (uint                                                    index, Game.RefReadOnlyPredicate<T> predicate)                                                      =>     this.items.FindIndex    (index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            FindIndex                                                                           (uint                                                    index, System.Predicate                 <T> predicate)                                                      =>     this.items.FindIndex    (index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          int                                            FindIndex                                                                           (uint                                                    index, uint                                 length, Game.RefPredicate        <T> predicate)         =>     this.items.FindIndex    (index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            FindIndex                                                                           (uint                                                    index, uint                                 length, Game.RefReadOnlyPredicate<T> predicate)         =>     this.items.FindIndex    (index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            FindIndex                                                                           (uint                                                    index, uint                                 length, System.Predicate                 <T> predicate)         =>     this.items.FindIndex    (index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          ref T                                          FindLast                                                                            (Game.RefPredicate        <T>                    predicate)                                                                                                  => ref this.items.FindLast     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          ref T                                          FindLast                                                                            (Game.RefReadOnlyPredicate<T>                    predicate)                                                                                                  => ref this.items.FindLast     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          ref T                                          FindLast                                                                            (System.Predicate                 <T>                    predicate)                                                                                                  => ref this.items.FindLast     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          int                                            FindLastIndex                                                                       (Game.RefPredicate        <T>                    predicate)                                                                                                  =>     this.items.FindLastIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            FindLastIndex                                                                       (Game.RefReadOnlyPredicate<T>                    predicate)                                                                                                  =>     this.items.FindLastIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            FindLastIndex                                                                       (System.Predicate                 <T>                    predicate)                                                                                                  =>     this.items.FindLastIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          int                                            FindLastIndex                                                                       (uint                                                    index, Game.RefPredicate        <T> predicate)                                                      =>     this.items.FindLastIndex(index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            FindLastIndex                                                                       (uint                                                    index, Game.RefReadOnlyPredicate<T> predicate)                                                      =>     this.items.FindLastIndex(index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            FindLastIndex                                                                       (uint                                                    index, System.Predicate                 <T> predicate)                                                      =>     this.items.FindLastIndex(index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            FindLastIndex                                                                       (uint                                                    index, uint                                 length, Game.RefPredicate        <T> predicate)         =>     this.items.FindLastIndex(index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            FindLastIndex                                                                       (uint                                                    index, uint                                 length, Game.RefReadOnlyPredicate<T> predicate)         =>     this.items.FindLastIndex(index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            FindLastIndex                                                                       (uint                                                    index, uint                                 length, System.Predicate                 <T> predicate)         =>     this.items.FindLastIndex(index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          ref TSort                                      FindRank                                                                            (Game.RefPredicate        <TSort>                predicate)                                                                                                  => ref this.ranks.Find         (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          ref TSort                                      FindRank                                                                            (Game.RefReadOnlyPredicate<TSort>                predicate)                                                                                                  => ref this.ranks.Find         (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          ref TSort                                      FindRank                                                                            (System.Predicate                 <TSort>                predicate)                                                                                                  => ref this.ranks.Find         (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          int                                            FindRankIndex                                                                       (Game.RefPredicate        <TSort>                predicate)                                                                                                  =>     this.ranks.FindIndex    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            FindRankIndex                                                                       (Game.RefReadOnlyPredicate<TSort>                predicate)                                                                                                  =>     this.ranks.FindIndex    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            FindRankIndex                                                                       (System.Predicate                 <TSort>                predicate)                                                                                                  =>     this.ranks.FindIndex    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          int                                            FindRankIndex                                                                       (uint                                                    index, Game.RefPredicate        <TSort> predicate)                                                  =>     this.ranks.FindIndex    (index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            FindRankIndex                                                                       (uint                                                    index, Game.RefReadOnlyPredicate<TSort> predicate)                                                  =>     this.ranks.FindIndex    (index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            FindRankIndex                                                                       (uint                                                    index, System.Predicate                 <TSort> predicate)                                                  =>     this.ranks.FindIndex    (index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          int                                            FindRankIndex                                                                       (uint                                                    index, uint                                     length, Game.RefPredicate        <TSort> predicate) =>     this.ranks.FindIndex    (index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            FindRankIndex                                                                       (uint                                                    index, uint                                     length, Game.RefReadOnlyPredicate<TSort> predicate) =>     this.ranks.FindIndex    (index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            FindRankIndex                                                                       (uint                                                    index, uint                                     length, System.Predicate                 <TSort> predicate) =>     this.ranks.FindIndex    (index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          ref TSort                                      FindRankLast                                                                        (Game.RefPredicate        <TSort>                predicate)                                                                                                  => ref this.ranks.FindLast     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          ref TSort                                      FindRankLast                                                                        (Game.RefReadOnlyPredicate<TSort>                predicate)                                                                                                  => ref this.ranks.FindLast     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          ref TSort                                      FindRankLast                                                                        (System.Predicate                 <TSort>                predicate)                                                                                                  => ref this.ranks.FindLast     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          int                                            FindRankLastIndex                                                                   (Game.RefPredicate        <TSort>                predicate)                                                                                                  =>     this.ranks.FindLastIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            FindRankLastIndex                                                                   (Game.RefReadOnlyPredicate<TSort>                predicate)                                                                                                  =>     this.ranks.FindLastIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            FindRankLastIndex                                                                   (System.Predicate                 <TSort>                predicate)                                                                                                  =>     this.ranks.FindLastIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          int                                            FindRankLastIndex                                                                   (uint                                                    index, Game.RefPredicate        <TSort> predicate)                                                  =>     this.ranks.FindLastIndex(index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            FindRankLastIndex                                                                   (uint                                                    index, Game.RefReadOnlyPredicate<TSort> predicate)                                                  =>     this.ranks.FindLastIndex(index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            FindRankLastIndex                                                                   (uint                                                    index, System.Predicate                 <TSort> predicate)                                                  =>     this.ranks.FindLastIndex(index, predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          int                                            FindRankLastIndex                                                                   (uint                                                    index, uint                                     length, Game.RefPredicate        <TSort> predicate) =>     this.ranks.FindLastIndex(index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          int                                            FindRankLastIndex                                                                   (uint                                                    index, uint                                     length, Game.RefReadOnlyPredicate<TSort> predicate) =>     this.ranks.FindLastIndex(index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            FindRankLastIndex                                                                   (uint                                                    index, uint                                     length, System.Predicate                 <TSort> predicate) =>     this.ranks.FindLastIndex(index, length, predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          void                                           ForEach                                                                             (Game.RefAction        <T>                       action)                                                                                                     =>     this.items.ForEach      (action);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          void                                           ForEach                                                                             (Game.RefReadOnlyAction<T>                       action)                                                                                                     =>     this.items.ForEach      (action);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           ForEach                                                                             (System.Action                 <T>                       action)                                                                                                     =>     this.items.ForEach      (action);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          Game.Collections.RefList<T>.Enumerator GetEnumerator                                                                       ()                                                                                                                                                                   =>     this.items.GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)] public          RefSortedCollection<TSort, T>                  GetRange                                                                            (uint                                                  index, uint length)                                                                                           { RefSortedCollection<TSort, T> sorted = new(this.Count, this.Comparer); sorted.items = this.items.GetRange(index, length); sorted.ranks = this.ranks.GetRange(index, length); return sorted; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          ref T                                          GetValue                                                                            (uint                                                  index)                                                                                                        => ref this.items[index];
      [GameMethod(AggressiveInlining), GameResolution(0)] public          ref T                                          GetValueByRank                                                                      (in TSort                                              rank)                                                                                                         { int index = this.ranks.LastIndexOf(in rank); return ref (index != -1 ? ref this.items[(uint) index] : ref this.items.Null); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            IndexOf                                                                             (in T                                                  element)                                                                                                      => this.items.IndexOf(in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            IndexOf                                                                             (in T                                                  element, uint index)                                                                                          => this.items.IndexOf(in element, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            IndexOf                                                                             (in T                                                  element, uint index, uint length)                                                                             => this.items.IndexOf(in element, index, length);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            IndexOfRank                                                                         (in TSort                                              rank)                                                                                                         => this.ranks.IndexOf(in rank);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            IndexOfRank                                                                         (in TSort                                              rank, uint index)                                                                                             => this.ranks.IndexOf(in rank, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            IndexOfRank                                                                         (in TSort                                              rank, uint index, uint length)                                                                                => this.ranks.IndexOf(in rank, index, length);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           IsEmpty                                                                             ()                                                                                                                                                                   => 0u == this.Count;
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            LastIndexOf                                                                         (in T                                                  element)                                                                                                      => this.items.LastIndexOf(in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            LastIndexOf                                                                         (in T                                                  element, uint index)                                                                                          => this.items.LastIndexOf(in element, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            LastIndexOf                                                                         (in T                                                  element, uint index, uint length)                                                                             => this.items.LastIndexOf(in element, index, length);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            LastIndexOfRank                                                                     (in TSort                                              rank)                                                                                                         => this.ranks.LastIndexOf(in rank);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            LastIndexOfRank                                                                     (in TSort                                              rank, uint index)                                                                                             => this.ranks.LastIndexOf(in rank, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          int                                            LastIndexOfRank                                                                     (in TSort                                              rank, uint index, uint length)                                                                                => this.ranks.LastIndexOf(in rank, index, length);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           Remove                                                                              (in T                                                  element)                                                                                                      { int index = this.items.IndexOf(in element); if (index != -1) { this.RemoveAt((uint) index); return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public          bool                                           Remove                                                                              (in Game.Collections.RefKeyValuePair<TSort, T> element)                                                                                                      { for (uint index = 0u; index != this.Count; ++index) if (0 == this.Comparer.Compare(in this.ranks[index], in element.Key) && Game.Collections.RefEqualityComparer<T>.Default.Equals(ref this.items[index], ref element.Value)) { this.RemoveAt(index); return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           Remove                                                                              (in System.Collections.Generic.KeyValuePair <TSort, T> element)                                                                                                      => this.Remove(new Game.Collections.RefKeyValuePair<TSort, T>(element.Key, element.Value));
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           RemoveByRank                                                                        (in TSort                                              rank)                                                                                                         { int index = this.ranks.IndexOf(in rank); if (index != -1) { this.RemoveAt((uint) index); return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public          bool                                           RemoveByRank                                                                        (in Game.Collections.RefKeyValuePair<TSort, T> element)                                                                                                      => this.Remove(in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           RemoveByRank                                                                        (in System.Collections.Generic.KeyValuePair <TSort, T> element)                                                                                                      => this.Remove(in element);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          uint                                           RemoveAll                                                                           (Game.RefPredicate                  <T>        predicate)                                                                                                    { uint count = 0u; for (uint index = 0u; index != this.Count; ++index) { if (predicate(ref this.items[index])) { ++count; this.RemoveAt(index); } } return count; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public          uint                                           RemoveAll                                                                           (Game.RefReadOnlyPredicate          <T>        predicate)                                                                                                    { uint count = 0u; for (uint index = 0u; index != this.Count; ++index) { if (predicate(in  this.items[index])) { ++count; this.RemoveAt(index); } } return count; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          uint                                           RemoveAll                                                                           (System.Predicate                           <T>        predicate)                                                                                                    { uint count = 0u; for (uint index = 0u; index != this.Count; ++index) { if (predicate(this.items[index]))     { ++count; this.RemoveAt(index); } } return count; }
      [GameMethod(AggressiveInlining), GameResolution(2)] public          uint                                           RemoveAllRank                                                                       (Game.RefPredicate                  <TSort>    predicate)                                                                                                    { uint count = 0u; for (uint index = 0u; index != this.Count; ++index) { if (predicate(ref this.ranks[index])) { ++count; this.RemoveAt(index); } } return count; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public          uint                                           RemoveAllRank                                                                       (Game.RefReadOnlyPredicate          <TSort>    predicate)                                                                                                    { uint count = 0u; for (uint index = 0u; index != this.Count; ++index) { if (predicate(in  this.ranks[index])) { ++count; this.RemoveAt(index); } } return count; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          uint                                           RemoveAllRank                                                                       (System.Predicate                           <TSort>    predicate)                                                                                                    { uint count = 0u; for (uint index = 0u; index != this.Count; ++index) { if (predicate(this.ranks[index]))     { ++count; this.RemoveAt(index); } } return count; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           RemoveAt                                                                            (uint                                                  index)                                                                                                        {  this.items.RemoveAt(index); this.ranks.RemoveAt(index); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           SetValue                                                                            (uint                                                  index, in T element)                                                                                          => this.items[index] = element;
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           SetValueByRank                                                                      (in TSort                                              rank,  in T element)                                                                                          { int index = this.ranks.LastIndexOf(in rank); if (index != -1) this.items[(uint) index] = element; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          RefSortedCollection<TSort, T>                  Slice                                                                               (uint                                                  index, uint length)                                                                                           { RefSortedCollection<TSort, T> sorted = new(this.Count, this.Comparer); sorted.items = this.items.Slice(index, length); sorted.ranks = this.ranks.Slice(index, length); return sorted; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          T[]                                            ToArray                                                                             ()                                                                                                                                                                   => this.items.ToArray   ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public override string?                                        ToString                                                                            ()                                                                                                                                                                   => this.items.ToString  ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           TrimExcess                                                                          ()                                                                                                                                                                   {  this.items.TrimExcess();         this.ranks.TrimExcess(); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          void                                           TrimExcess                                                                          (uint                                                  capacity)                                                                                                     {  this.items.TrimExcess(capacity); this.ranks.TrimExcess(capacity); }
      [GameMethod(AggressiveInlining), GameResolution(1)] public          bool                                           TryAdd                                                                              (in Game.Collections.RefKeyValuePair<TSort, T> element)                                                                                                      => this.TryAdd(in element.Key, in element.Value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           TryAdd                                                                              (in System.Collections.Generic.KeyValuePair <TSort, T> element)                                                                                                      => this.TryAdd(element.Key,    element.Value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           TryAdd                                                                              (in TSort                                              rank, in T element)                                                                                           { if (!this.ranks.Contains(in rank)) { this.Add(in rank, in element); return true; } return false; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public          ref T                                          TryAppend                                                                           (in Game.Collections.RefKeyValuePair<TSort, T> element)                                                                                                      => ref this.TryAppend(in element.Key, in element.Value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          ref T                                          TryAppend                                                                           (in System.Collections.Generic.KeyValuePair <TSort, T> element)                                                                                                      { (TSort rank, T element)[] pair = new[] {(element.Key, element.Value)}; return ref this.TryAppend(in Util.Reference<(TSort rank, T)>.Only(pair).rank, in Util.Reference<(TSort, T element)>.Only(pair).element); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public          ref T                                          TryAppend                                                                           (in TSort                                              rank, in T element)                                                                                           { int index = this.ranks.LastIndexOf(in rank); if (index == -1) { this.ranks.Add(in rank); this.ranks.Sort(this.Comparer); index = this.ranks.LastIndexOf(in rank); this.items.Insert((uint) index, in element); } return ref this.items[(uint) index]; }
      [GameMethod(AggressiveInlining), GameResolution(2)] public          bool                                           TrueForAll                                                                          (Game.RefPredicate        <T>                  predicate)                                                                                                    => this.items.TrueForAll(predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          bool                                           TrueForAll                                                                          (Game.RefReadOnlyPredicate<T>                  predicate)                                                                                                    => this.items.TrueForAll(predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           TrueForAll                                                                          (System.Predicate                 <T>                  predicate)                                                                                                    => this.items.TrueForAll(predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public          bool                                           TrueForAllRank                                                                      (Game.RefPredicate        <TSort>              predicate)                                                                                                    => this.ranks.TrueForAll(predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public          bool                                           TrueForAllRank                                                                      (Game.RefReadOnlyPredicate<TSort>              predicate)                                                                                                    => this.ranks.TrueForAll(predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public          bool                                           TrueForAllRank                                                                      (System.Predicate                 <TSort>              predicate)                                                                                                    => this.ranks.TrueForAll(predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                           Game.Collections.IRefEquatable<RefSortedCollection<TSort, T>>.Equals        (ref RefSortedCollection          <TSort, T>           collection)                                                                                                   => this      .Equals    (in collection);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                           Game.Collections.IRefReadOnlyEquatable<RefSortedCollection<TSort, T>>.Equals(in  RefSortedCollection          <TSort, T>           collection)                                                                                                   => this      .Equals    (in collection);
      [GameMethod(NoInlining),         GameResolution(0)] void                                                           System.Collections.Generic.ICollection<T>.Add                                       (T                                                     element)                                                                                                      => throw new System.NotSupportedException("Sorted collection requires a sorting rank for modification");
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                           System.Collections.Generic.ICollection<T>.Clear                                     ()                                                                                                                                                                   => this.Clear        ();
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                           System.Collections.Generic.ICollection<T>.Contains                                  (T   element)                                                                                                                                                        => this.Contains     (element);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                           System.Collections.Generic.ICollection<T>.CopyTo                                    (T[] array, int index)                                                                                                                                               => this.CopyTo       (array, (uint) index);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                           System.Collections.Generic.ICollection<T>.Remove                                    (T   element)                                                                                                                                                        => this.Remove       (element);
      [GameMethod(AggressiveInlining), GameResolution(0)] System.Collections.Generic.IEnumerator<T>                      System.Collections.Generic.IEnumerable<T>.GetEnumerator                             ()                                                                                                                                                                   => this.GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)] System.Collections.IEnumerator                                 System.Collections.IEnumerable.GetEnumerator                                        ()                                                                                                                                                                   => this.GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                                            System.Collections.Generic.IList<T>.IndexOf                                         (T            element)                                                                                                                                               => this.IndexOf      (element);
      [GameMethod(NoInlining),         GameResolution(0)] void                                                           System.Collections.Generic.IList<T>.Insert                                          (int          index, T element)                                                                                                                                      => throw new System.NotSupportedException("Sorted collection requires a sorting rank for modification");
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                           System.Collections.Generic.IList<T>.RemoveAt                                        (int          index)                                                                                                                                                 => this.RemoveAt((uint) index);
      [GameMethod(NoInlining),         GameResolution(0)] void                                                           System.Collections.ICollection.CopyTo                                               (System.Array array, int index)                                                                                                                                      => throw new System.NotSupportedException("Sorted collection expected typed array for copy");
      [GameMethod(NoInlining),         GameResolution(0)] int                                                            System.Collections.IList.Add                                                        (object?      element)                                                                                                                                               => throw new System.NotSupportedException("Sorted collection requires a sorting rank for modification");
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                           System.Collections.IList.Clear                                                      ()                                                                                                                                                                   => this.Clear   ();
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                           System.Collections.IList.Contains                                                   (object?                              element)                                                                                                                       => this.Contains((T) element!);
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                                            System.Collections.IList.IndexOf                                                    (object?                              element)                                                                                                                       => this.IndexOf ((T) element!);
      [GameMethod(NoInlining),         GameResolution(0)] void                                                           System.Collections.IList.Insert                                                     (int                                  index, object? element)                                                                                                        => throw new System.NotSupportedException("Sorted collection requires a sorting rank for modification");
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                           System.Collections.IList.Remove                                                     (object?                              element)                                                                                                                       => this    .Remove     ((T) element!);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                           System.Collections.IList.RemoveAt                                                   (int                                  index)                                                                                                                         => this    .RemoveAt   ((uint) index);
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                                            System.Collections.IStructuralComparable.CompareTo                                  (object?                              value, System.Collections.IComparer         comparer)                                                                          => comparer.Compare    (this, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                           System.Collections.IStructuralEquatable.Equals                                      (object?                              value, System.Collections.IEqualityComparer comparer)                                                                          => comparer.Equals     (this, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                                            System.Collections.IStructuralEquatable.GetHashCode                                 (System.Collections.IEqualityComparer comparer)                                                                                                                      => comparer.GetHashCode(this);
      [GameMethod(AggressiveInlining), GameResolution(0)] object                                                         System.ICloneable.Clone                                                             ()                                                                                                                                                                   => this    .Clone      ();
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                           System.IEquatable<RefSortedCollection<TSort, T>>.Equals                             (RefSortedCollection<TSort, T> collection)                                                                                                                           => this    .Equals     (collection);

      /* … */
      public ref T                             this                                    [uint         index] => ref this.items[index];
      public     RefSortedCollection<TSort, T> this                                    [System.Range range] { get { (int index, int length) = range.GetOffsetAndLength((int) this.Count); return this.GetRange((uint) index, (uint) length); } }
      T                                        System.Collections.Generic.IList<T>.this[int          index] { get => this[(uint) index]; set => this[(uint) index] = value; }
      object?                                  System.Collections.IList.this           [int          index] { get => this[(uint) index]; set => this[(uint) index] = (T) value!; }
    }

    [System.Runtime.CompilerServices.CollectionBuilder(typeof(Sequence), nameof(Sequence.Create))]
    internal class Sequence : System.Collections.Generic.IEnumerable<int> /* ->> Based on collection expressions i.e. `[1, 2, …, 3]` */ {
      private readonly int[] values;

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)]
      public Sequence(System.ReadOnlySpan<int> values) => this.values = Util.Array<int>.From(values);

      /* … */
      [GameMethod(AggressiveInlining)] public static Sequence                                    Create                                      (System.ReadOnlySpan<int> values) => new(values);
      [GameMethod(AggressiveInlining)] public        System.Collections.Generic.IEnumerator<int> GetEnumerator                               ()                                => ((System.Collections.Generic.IEnumerable<int>) this.values).GetEnumerator();
      [GameMethod(AggressiveInlining)] System.Collections.IEnumerator                            System.Collections.IEnumerable.GetEnumerator()                                => this.values.GetEnumerator();

      [GameMethod(AggressiveInlining)] public static explicit operator int[](Sequence sequence) => sequence.values;
    }

    public readonly struct Shared<T> : Game.Collections.Proxy<T>, System.Dynamic.DynamicObject, Game.Collections.IShared, Game.Collections.IRefEquatable<Shared<T>> /* ->> Based on `System.Nullable<T>` */ {
      private static T Singleton = default!;

      public   readonly ref T Value                          => ref Shared<T>.Singleton;
      readonly object?        Game.Collections.IShared.Value => this.Value;

      /* … */
      [GameMethod(AggressiveInlining)] public Shared()           : base() {}
      [GameMethod(AggressiveInlining)] public Shared(in T value) : base() => Shared<T>.Singleton = value;

      /* … */
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in T                             value)      => this.Value is null ? value is null : this.Value!.Equals(value);
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (Game.Collections.IShared shared)     => shared.Value is T || (this.Value is null ? shared.Value is null : this.Value!.Equals(shared!.Value));
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in Shared<T>                     shared)     => true;
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals<U>                                                                              (in Shared<U>                     shared)     => this.Value is null ? Shared<U>.Singleton is null : this.Value!.Equals(Shared<U>.Singleton);
      [GameMethod(AggressiveInlining)] public override readonly bool    Equals                                                                                 (object?                          value)      => value switch { T subvalue => this.Equals(subvalue), Shared<T> shared => this.Equals(shared), Game.Collections.IShared shared => this.Equals(shared), null => this.Value is null, _ => this.Value?.Equals(value) ?? false };
      [GameMethod(AggressiveInlining)] public override readonly int     GetHashCode                                                                            ()                                            => this.Value?.GetHashCode() ?? base.GetHashCode();
      [GameMethod(AggressiveInlining)] public override readonly string? ToString                                                                               ()                                            => this.Value?.ToString   () ?? string.Empty;
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefEquatable<Game.Collections.IShared>.Equals        (ref Game.Collections.IShared shared) => this.Equals(shared);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefEquatable<Shared<T>>.Equals                               (ref Shared<T>                        shared) => this.Equals(in shared);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefReadOnlyEquatable<Game.Collections.IShared>.Equals(in  Game.Collections.IShared shared) => this.Equals(shared);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefReadOnlyEquatable<Shared<T>>.Equals                       (in  Shared<T>                        shared) => this.Equals(in shared);
      [GameMethod(AggressiveInlining)] readonly bool                    System.IEquatable<Game.Collections.IShared>.Equals                             (Game.Collections.IShared     shared) => this.Equals(shared);
      [GameMethod(AggressiveInlining)] readonly bool                    System.IEquatable<Shared<T>>.Equals                                                    (Shared<T>                            shared) => this.Equals(shared);

      [GameMethod(AggressiveInlining)] public static Shared<T> operator + (in Shared<T>             shared,  in T                     value)   => new Shared<T>(value);
      [GameMethod(AggressiveInlining)] public static bool      operator ==(in T                     value,   in Shared<T>             shared)  => value?.Equals(shared.Value) ?? null == shared.Value;
      [GameMethod(AggressiveInlining)] public static bool      operator ==(Game.Collections.IShared sharedA, in Shared<T>             sharedB) => sharedA.Equals(sharedB);
      [GameMethod(AggressiveInlining)] public static bool      operator ==(in Shared<T>             shared,  in T                     value)   => shared .Equals(in value);
      [GameMethod(AggressiveInlining)] public static bool      operator ==(in Shared<T>             sharedA, Game.Collections.IShared sharedB) => sharedA.Equals(sharedB);
      [GameMethod(AggressiveInlining)] public static bool      operator ==(in Shared<T>             sharedA, in Shared<T>             sharedB) => true;
      [GameMethod(AggressiveInlining)] public static bool      operator !=(in T                     value,   in Shared<T>             shared)  => !(value == shared);
      [GameMethod(AggressiveInlining)] public static bool      operator !=(Game.Collections.IShared sharedA, in Shared<T>             sharedB) => !sharedA.Equals(sharedB);
      [GameMethod(AggressiveInlining)] public static bool      operator !=(in Shared<T>             shared,  in T                     value)   => !shared .Equals(in value);
      [GameMethod(AggressiveInlining)] public static bool      operator !=(in Shared<T>             sharedA, Game.Collections.IShared sharedB) => !sharedA.Equals(sharedB);
      [GameMethod(AggressiveInlining)] public static bool      operator !=(in Shared<T>             sharedA, in Shared<T>             sharedB) => false;

      [GameMethod(AggressiveInlining)]
      public static implicit operator T(in Shared<T> shared) => shared.Value;
    }

    public struct SharedLazyMono<T> : /* System.DynamicObject, */ Game.Collections.IMono, Game.Collections.IRefEquatable<SharedLazyMono<T>>, Game.Collections.IShared {
      private static          System.Func<T>                                  Initializer  = [GameMethod(AggressiveInlining)] static () => default!;
      private static readonly System.Collections.Generic.List<System.Func<T>> Initializers = new(1);
      private static          Game.Collections.LazyMono<T>            LazyMono     = new([GameMethod(AggressiveInlining)] static () => { foreach (System.Func<T> initializer in SharedLazyMono<T>.Initializers) { T value = initializer(); if (null != value) return value; } return default!; });

      public   readonly ref readonly bool HasValue                                => ref SharedLazyMono<T>.LazyMono.HasValue;
      public   readonly System.Func<T>    Init { get; internal init; }            =      SharedLazyMono<T>.Initializer;
      public   readonly ref T             Value                                   => ref SharedLazyMono<T>.LazyMono.Value;
      readonly bool                       Game.Collections.IMono.HasValue =>     this                      .HasValue;
      readonly object?                    Game.Collections.IMono.Value    =>     this                      .Value;
      readonly object?                    Game.Collections.IShared.Value  =>     this                      .Value;

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)]
      public SharedLazyMono(System.Func<T> initializer) {
        SharedLazyMono<T>.Initializer = !SharedLazyMono<T>.Initializers.IsEmpty() ? (System.Func<T>) System.Delegate.Combine(SharedLazyMono<T>.Initializer, initializer) : initializer;
        SharedLazyMono<T>.Initializers.Add(initializer);
      }

      /* … */
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in T                                      value)          => SharedLazyMono<T>.LazyMono.Equals(in value);
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in Game.Collections.IMono         mono)           => SharedLazyMono<T>.LazyMono.Equals(mono  .Value);
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in Game.Collections.IShared       shared)         => SharedLazyMono<T>.LazyMono.Equals(shared.Value);
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in Game.Collections.LazyMono  <T> lazyMono)       => SharedLazyMono<T>.LazyMono.Equals(in lazyMono);
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in Game.Collections.Mono      <T> mono)           => SharedLazyMono<T>.LazyMono.Equals(in mono);
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in Game.Collections.Shared    <T> shared)         => SharedLazyMono<T>.LazyMono.Equals(in shared.Value);
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in Game.Collections.SharedMono<T> sharedMono)     => SharedLazyMono<T>.LazyMono.Equals(in Game.Collections.SharedMono<T>.Mono);
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in SharedLazyMono                     <T> sharedLazyMono) => true;
      [GameMethod(AggressiveInlining)] public override readonly bool    Equals                                                                                 (object?                                   value)          => value is SharedLazyMono<T> || value switch { Game.Collections.Shared<T> shared => this.Equals(shared), Game.Collections.SharedMono<T> sharedMono => this.Equals(sharedMono), Game.Collections.IShared shared => this.Equals(shared), _ => SharedLazyMono<T>.LazyMono.Equals(value) };
      [GameMethod(AggressiveInlining)] public override readonly int     GetHashCode                                                                            ()                                                         => SharedLazyMono<T>.LazyMono.GetHashCode      ();
      [GameMethod(AggressiveInlining)] public          readonly T       GetValueOrDefault                                                                      ()                                                         => SharedLazyMono<T>.LazyMono.GetValueOrDefault();
      [GameMethod(AggressiveInlining)] public          readonly T       GetValueOrDefault                                                                      (in T fallback)                                            => SharedLazyMono<T>.LazyMono.GetValueOrDefault(in fallback);
      [GameMethod(AggressiveInlining)] public override readonly string? ToString                                                                               ()                                                         => SharedLazyMono<T>.LazyMono.ToString         ();
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefEquatable<Game.Collections.IMono>.Equals          (ref Game.Collections.IMono   mono)                => this.Equals(mono);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefEquatable<Game.Collections.IShared>.Equals        (ref Game.Collections.IShared shared)              => this.Equals(shared);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefEquatable<SharedLazyMono<T>>.Equals                       (ref SharedLazyMono<T>                sharedLazyMono)      => this.Equals(in sharedLazyMono);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefReadOnlyEquatable<Game.Collections.IMono>.Equals  (in  Game.Collections.IMono   mono)                => this.Equals(mono);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefReadOnlyEquatable<Game.Collections.IShared>.Equals(in  Game.Collections.IShared shared)              => this.Equals(shared);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefReadOnlyEquatable<SharedLazyMono<T>>.Equals               (in  SharedLazyMono<T>                sharedLazyMono)      => this.Equals(in sharedLazyMono);
      [GameMethod(AggressiveInlining)] readonly bool                    System.IEquatable<Game.Collections.IMono>.Equals                               (Game.Collections.IMono       mono)                => this.Equals(mono);
      [GameMethod(AggressiveInlining)] readonly bool                    System.IEquatable<Game.Collections.IShared>.Equals                             (Game.Collections.IShared     shared)              => this.Equals(shared);
      [GameMethod(AggressiveInlining)] readonly bool                    System.IEquatable<SharedLazyMono<T>>.Equals                                            (SharedLazyMono<T>                    sharedLazyMono)      => this.Equals(sharedLazyMono);

      [GameMethod(AggressiveInlining)] public static bool              operator false(in SharedLazyMono<T>                      sharedLazyMono)                                                             =>  SharedLazyMono<T>.LazyMono ? false : true;
      [GameMethod(AggressiveInlining)] public static bool              operator true (in SharedLazyMono<T>                      sharedLazyMono)                                                             =>  SharedLazyMono<T>.LazyMono ? true  : false;
      [GameMethod(AggressiveInlining)] public static bool              operator !    (in SharedLazyMono<T>                      sharedLazyMono)                                                             => !SharedLazyMono<T>.LazyMono;
      [GameMethod(AggressiveInlining)] public static SharedLazyMono<T> operator +    (in SharedLazyMono<T>                      sharedLazyMono,  in T                                      value)           { SharedLazyMono<T>.LazyMono += value; return sharedLazyMono; }
      [GameMethod(AggressiveInlining)] public static bool              operator ==   (in T                                      value,           in SharedLazyMono<T>                      sharedLazyMono)  => value == SharedLazyMono<T>.LazyMono;
      [GameMethod(AggressiveInlining)] public static bool              operator ==   (Game.Collections.IMono            mono,            in SharedLazyMono<T>                      sharedLazyMono)  => mono  == SharedLazyMono<T>.LazyMono;
      [GameMethod(AggressiveInlining)] public static bool              operator ==   (Game.Collections.IShared          shared,          in SharedLazyMono<T>                      sharedLazyMono)  => SharedLazyMono<T>.LazyMono.HasValue && (shared.Value?.Equals(SharedLazyMono<T>.LazyMono.Value) ?? false);
      [GameMethod(AggressiveInlining)] public static bool              operator ==   (in Game.Collections.Mono      <T> mono,            in SharedLazyMono<T>                      sharedLazyMono)  => mono         == SharedLazyMono<T>.LazyMono;
      [GameMethod(AggressiveInlining)] public static bool              operator ==   (in Game.Collections.LazyMono  <T> lazyMono,        in SharedLazyMono<T>                      sharedLazyMono)  => lazyMono     == SharedLazyMono<T>.LazyMono;
      [GameMethod(AggressiveInlining)] public static bool              operator ==   (in Game.Collections.Shared    <T> shared,          in SharedLazyMono<T>                      sharedLazyMono)  => shared.Value == SharedLazyMono<T>.LazyMono;
      [GameMethod(AggressiveInlining)] public static bool              operator ==   (in Game.Collections.SharedMono<T> sharedMono,      in SharedLazyMono<T>                      sharedLazyMono)  => sharedMono   == SharedLazyMono<T>.LazyMono.Value;
      [GameMethod(AggressiveInlining)] public static bool              operator ==   (in SharedLazyMono                     <T> sharedLazyMono,  in T                                      value)           => SharedLazyMono<T>.LazyMono == value;
      [GameMethod(AggressiveInlining)] public static bool              operator ==   (in SharedLazyMono                     <T> sharedLazyMono,  Game.Collections.IMono            mono)            => SharedLazyMono<T>.LazyMono == mono;
      [GameMethod(AggressiveInlining)] public static bool              operator ==   (in SharedLazyMono                     <T> sharedLazyMono,  Game.Collections.IShared          shared)          => SharedLazyMono<T>.LazyMono.Equals(shared.Value);
      [GameMethod(AggressiveInlining)] public static bool              operator ==   (in SharedLazyMono                     <T> sharedLazyMono,  in Game.Collections.Mono      <T> mono)            => SharedLazyMono<T>.LazyMono == mono;
      [GameMethod(AggressiveInlining)] public static bool              operator ==   (in SharedLazyMono                     <T> sharedLazyMono,  in Game.Collections.Shared    <T> shared)          => SharedLazyMono<T>.LazyMono == shared.Value;
      [GameMethod(AggressiveInlining)] public static bool              operator ==   (in SharedLazyMono                     <T> sharedLazyMono,  in Game.Collections.SharedMono<T> sharedMono)      => SharedLazyMono<T>.LazyMono == Game.Collections.SharedMono<T>.Mono;
      [GameMethod(AggressiveInlining)] public static bool              operator ==   (in SharedLazyMono                     <T> sharedLazyMonoA, in SharedLazyMono                     <T> sharedLazyMonoB) => true;
      [GameMethod(AggressiveInlining)] public static bool              operator !=   (in T                                      value,           in SharedLazyMono<T>                      sharedLazyMono)  => value != SharedLazyMono<T>.LazyMono;
      [GameMethod(AggressiveInlining)] public static bool              operator !=   (Game.Collections.IMono            mono,            in SharedLazyMono<T>                      sharedLazyMono)  => mono  != SharedLazyMono<T>.LazyMono;
      [GameMethod(AggressiveInlining)] public static bool              operator !=   (Game.Collections.IShared          shared,          in SharedLazyMono<T>                      sharedLazyMono)  => !(shared == sharedLazyMono);
      [GameMethod(AggressiveInlining)] public static bool              operator !=   (in Game.Collections.Mono      <T> mono,            in SharedLazyMono<T>                      sharedLazyMono)  => mono         != SharedLazyMono<T>.LazyMono;
      [GameMethod(AggressiveInlining)] public static bool              operator !=   (in Game.Collections.LazyMono  <T> lazyMono,        in SharedLazyMono<T>                      sharedLazyMono)  => lazyMono     != SharedLazyMono<T>.LazyMono;
      [GameMethod(AggressiveInlining)] public static bool              operator !=   (in Game.Collections.Shared    <T> shared,          in SharedLazyMono<T>                      sharedLazyMono)  => shared.Value != SharedLazyMono<T>.LazyMono;
      [GameMethod(AggressiveInlining)] public static bool              operator !=   (in Game.Collections.SharedMono<T> sharedMono,      in SharedLazyMono<T>                      sharedLazyMono)  => sharedMono   != SharedLazyMono<T>.LazyMono.Value;
      [GameMethod(AggressiveInlining)] public static bool              operator !=   (in SharedLazyMono                     <T> sharedLazyMono,  in T                                      value)           => SharedLazyMono<T>.LazyMono != value;
      [GameMethod(AggressiveInlining)] public static bool              operator !=   (in SharedLazyMono                     <T> sharedLazyMono,  Game.Collections.IMono            mono)            => SharedLazyMono<T>.LazyMono != mono;
      [GameMethod(AggressiveInlining)] public static bool              operator !=   (in SharedLazyMono                     <T> sharedLazyMono,  Game.Collections.IShared          shared)          => !(sharedLazyMono == shared);
      [GameMethod(AggressiveInlining)] public static bool              operator !=   (in SharedLazyMono                     <T> sharedLazyMono,  in Game.Collections.Mono      <T> mono)            => SharedLazyMono<T>.LazyMono != mono;
      [GameMethod(AggressiveInlining)] public static bool              operator !=   (in SharedLazyMono                     <T> sharedLazyMono,  in Game.Collections.Shared    <T> shared)          => SharedLazyMono<T>.LazyMono != shared.Value;
      [GameMethod(AggressiveInlining)] public static bool              operator !=   (in SharedLazyMono                     <T> sharedLazyMono,  in Game.Collections.SharedMono<T> sharedMono)      => SharedLazyMono<T>.LazyMono != Game.Collections.SharedMono<T>.Mono;
      [GameMethod(AggressiveInlining)] public static bool              operator !=   (in SharedLazyMono                     <T> sharedLazyMonoA, in SharedLazyMono                     <T> sharedLazyMonoB) => false;

      [GameMethod(AggressiveInlining)] public static explicit operator T                                   (in SharedLazyMono<T> sharedLazyMono) => (T)                                SharedLazyMono<T>.LazyMono;
      [GameMethod(AggressiveInlining)] public static implicit operator Game.Collections.Mono    <T>(in SharedLazyMono<T> sharedLazyMono) => (Game.Collections.Mono<T>) SharedLazyMono<T>.LazyMono;
      [GameMethod(AggressiveInlining)] public static implicit operator Game.Collections.LazyMono<T>(in SharedLazyMono<T> sharedLazyMono) =>                                    SharedLazyMono<T>.LazyMono;
      [GameMethod(AggressiveInlining)] public static implicit operator SharedLazyMono<T>                   (in T                 value)          => new SharedLazyMono<T>() + value;
    }

    public class SharedList<T> : Game.Collections.IRefEquatable<SharedList<T>>, Game.Collections.IShared, System.Collections.Generic.IList<T>, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.ICloneable {
      protected internal static Game.Collections.RefList<T> List = new(); // ->> Singleton composition over inheritance

      public uint Capacity                                             { get => SharedList<T>.List.Capacity; set => SharedList<T>.List.Capacity = value; }
      public uint Count                                                => SharedList<T>.List.Count;
      object?     Game.Collections.IShared.Value               => SharedList<T>.List;
      int         System.Collections.Generic.ICollection<T>.Count      => ((int) SharedList<T>.List.Count);
      bool        System.Collections.Generic.ICollection<T>.IsReadOnly => false;
      int         System.Collections.ICollection.Count                 => ((int) SharedList<T>.List.Count);
      bool        System.Collections.ICollection.IsSynchronized        => false;
      object      System.Collections.ICollection.SyncRoot              => SharedList<T>.List;
      bool        System.Collections.IList.IsFixedSize                 => false;
      bool        System.Collections.IList.IsReadOnly                  => false;

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)] public SharedList(uint                                      capacity = 0u)                                        { SharedList<T>.List.EnsureCapacity(System.Math.Max(capacity, SharedList<T>.List.Capacity)); }
      [GameConstructor, GameMethod(AggressiveInlining)] public SharedList(SharedList                            <T> list)                                                 {}
      [GameConstructor, GameMethod(AggressiveInlining)] public SharedList(System.Collections.Generic.ICollection<T> collection) : this((uint) collection.Count)           { if (collection is SharedList<T>) return; SharedList<T>.List.Clear(); SharedList<T>.List.AddRange(collection); }
      [GameConstructor, GameMethod(AggressiveInlining)] public SharedList(System.Collections.Generic.IEnumerable<T> enumerable) : this(Util.Enumerable.Count(enumerable)) { if (enumerable is SharedList<T>) return; SharedList<T>.List.Clear(); SharedList<T>.List.AddRange(enumerable); }
      [GameConstructor, GameMethod(AggressiveInlining)] public SharedList(in System.Memory                      <T> memory)     : this((uint) memory.Length)              {                                          SharedList<T>.List.Clear(); SharedList<T>.List.AddRange(in memory); }
      [GameConstructor, GameMethod(AggressiveInlining)] public SharedList(in System.ReadOnlyMemory              <T> memory)     : this((uint) memory.Length)              {                                          SharedList<T>.List.Clear(); SharedList<T>.List.AddRange(in memory); }
      [GameConstructor, GameMethod(AggressiveInlining)] public SharedList(in System.ReadOnlySpan                <T> span)       : this((uint) span.Length)                {                                          SharedList<T>.List.Clear(); SharedList<T>.List.AddRange(in span); }
      [GameConstructor, GameMethod(AggressiveInlining)] public SharedList(in System.Span                        <T> span)       : this((uint) span.Length)                {                                          SharedList<T>.List.Clear(); SharedList<T>.List.AddRange(in span); }
      [GameConstructor, GameMethod(AggressiveInlining)] public SharedList(in Util.Array<T>.Copyable                 copyable)   : this(copyable.Count)                    {                                          SharedList<T>.List.Clear(); SharedList<T>.List.AddRange(in copyable); }

      /* … */
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           Add                                                                                    (in T                                      element)                                                                               =>     SharedList<T>.List.Add          (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           AddRange                                                                               (System.Collections.Generic.ICollection<T> collection)                                                                            =>     SharedList<T>.List.AddRange     (collection);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           AddRange                                                                               (System.Collections.Generic.IEnumerable<T> enumerable)                                                                            =>     SharedList<T>.List.AddRange     (enumerable);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           AddRange                                                                               (in System.Memory                      <T> memory)                                                                                =>     SharedList<T>.List.AddRange     (in memory);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           AddRange                                                                               (in System.ReadOnlyMemory              <T> memory)                                                                                =>     SharedList<T>.List.AddRange     (in memory);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           AddRange                                                                               (in System.ReadOnlySpan                <T> span)                                                                                  =>     SharedList<T>.List.AddRange     (in span);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           AddRange                                                                               (in System.Span                        <T> span)                                                                                  =>     SharedList<T>.List.AddRange     (in span);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           AddRange                                                                               (in Util.Array<T>.Copyable                 copyable)                                                                              =>     SharedList<T>.List.AddRange     (in copyable);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   ref T                                          Append                                                                                 (in T                                      element)                                                                               => ref SharedList<T>.List.Append       (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   Game.Collections.RefReadOnlyList<T>    AsReadOnly                                                                             ()                                                                                                                                =>     SharedList<T>.List.AsReadOnly   ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            BinarySearch                                                                           (in T element)                                                                                                                    =>     SharedList<T>.List.BinarySearch (in element);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   int                                            BinarySearch                                                                           (in T element,                         Game.Collections.IRefReadOnlyComparer<T>? comparer)                                =>     SharedList<T>.List.BinarySearch (in element, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            BinarySearch                                                                           (in T element,                         System.Collections.Generic.IComparer         <T>? comparer)                                =>     SharedList<T>.List.BinarySearch (in element, comparer);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   int                                            BinarySearch                                                                           (uint index, uint count, in T element, Game.Collections.IRefReadOnlyComparer<T>? comparer)                                =>     SharedList<T>.List.BinarySearch (index, count, in element, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            BinarySearch                                                                           (uint index, uint count, in T element, System.Collections.Generic.IComparer         <T>? comparer)                                =>     SharedList<T>.List.BinarySearch (index, count, in element, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           Clear                                                                                  ()                                                                                                                                =>     SharedList<T>.List.Clear        ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public   object                                         Clone                                                                                  ()                                                                                                                                =>     SharedList<T>.List.Clone        ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public   bool                                           Contains                                                                               (in T                                    element)                                                                                 =>     SharedList<T>.List.Contains     (in element);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   SharedList<U>                                  ConvertAll<U>                                                                          (Game.RefConverter        <T, U> converter)                                                                               => new(SharedList<T>.List.ConvertAll<U>(converter));
      [GameMethod(AggressiveInlining), GameResolution(1)] public   SharedList<U>                                  ConvertAll<U>                                                                          (Game.RefReadOnlyConverter<T, U> converter)                                                                               => new(SharedList<T>.List.ConvertAll<U>(converter));
      [GameMethod(AggressiveInlining), GameResolution(0)] public   SharedList<U>                                  ConvertAll<U>                                                                          (System.Converter                 <T, U> converter)                                                                               => new(SharedList<T>.List.ConvertAll<U>(converter));
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           CopyTo                                                                                 (T[]                                     array)                                                                                   =>     SharedList<T>.List.CopyTo       (array);
      [GameMethod(AggressiveInlining), GameResolution(0)] internal void                                           CopyTo                                                                                 (T[]                                     array, int  index)                                                                       =>     SharedList<T>.List.CopyTo       (array, index); // ->> Strictly for `struct Util.Array<T>.Copyable` to work with
      [GameMethod(AggressiveInlining), GameResolution(1)] public   void                                           CopyTo                                                                                 (T[]                                     array, uint index)                                                                       =>     SharedList<T>.List.CopyTo       (array, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           CopyTo                                                                                 (uint                                    index, T[]  array, uint arrayIndex, uint count)                                          =>     SharedList<T>.List.CopyTo       (index, array, arrayIndex, count);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   bool                                           Equals                                                                                 (Game.Collections.IShared        shared)                                                                                  =>     shared is SharedList<T>;
      [GameMethod(AggressiveInlining), GameResolution(1)] public   bool                                           Equals                                                                                 (in SharedList                    <T>    list)                                                                                    =>     true;
      [GameMethod(AggressiveInlining), GameResolution(2)] public   bool                                           Exists                                                                                 (Game.RefPredicate        <T>    predicate)                                                                               =>     SharedList<T>.List                                   .Exists   (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   bool                                           Exists                                                                                 (Game.RefReadOnlyPredicate<T>    predicate)                                                                               =>     SharedList<T>.List                                   .Exists   (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   bool                                           Exists                                                                                 (System.Predicate                 <T>    predicate)                                                                               =>     SharedList<T>.List                                   .Exists   (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           Fill                                                                                   (in T                                    element)                                                                                 =>     SharedList<T>.List                                   .Fill     (in element);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   ref T                                          Find                                                                                   (Game.RefPredicate        <T>    predicate)                                                                               => ref SharedList<T>.List                                   .Find     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   ref T                                          Find                                                                                   (Game.RefReadOnlyPredicate<T>    predicate)                                                                               => ref SharedList<T>.List                                   .Find     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   ref T                                          Find                                                                                   (System.Predicate                 <T>    predicate)                                                                               => ref SharedList<T>.List                                   .Find     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   SharedList<T>                                  FindAll                                                                                (Game.RefPredicate        <T>    predicate)                                                                               {      SharedList<T>.List                                   .RemoveAll([GameMethod(AggressiveInlining)] (ref T element) => !predicate(ref element)); return this; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public   SharedList<T>                                  FindAll                                                                                (Game.RefReadOnlyPredicate<T>    predicate)                                                                               {      SharedList<T>.List                                   .RemoveAll([GameMethod(AggressiveInlining)] (in  T element) => !predicate(in  element)); return this; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public   SharedList<T>                                  FindAll                                                                                (System.Predicate                 <T>    predicate)                                                                               {      SharedList<T>.List                                   .RemoveAll([GameMethod(AggressiveInlining)] (element)       => !predicate(element));     return this; }
      [GameMethod(AggressiveInlining), GameResolution(2)] public   int                                            FindIndex                                                                              (Game.RefPredicate        <T>    predicate)                                                                               =>     SharedList<T>.List                                   .FindIndex    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   int                                            FindIndex                                                                              (Game.RefReadOnlyPredicate<T>    predicate)                                                                               =>     SharedList<T>.List                                   .FindIndex    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            FindIndex                                                                              (System.Predicate                 <T>    predicate)                                                                               =>     SharedList<T>.List                                   .FindIndex    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   int                                            FindIndex                                                                              (uint                                    index,             Game.RefPredicate        <T> predicate)                       =>     SharedList<T>.List                                   .FindIndex    (index,        predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   int                                            FindIndex                                                                              (uint                                    index,             Game.RefReadOnlyPredicate<T> predicate)                       =>     SharedList<T>.List                                   .FindIndex    (index,        predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            FindIndex                                                                              (uint                                    index,             System.Predicate                 <T> predicate)                       =>     SharedList<T>.List                                   .FindIndex    (index,        predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   int                                            FindIndex                                                                              (uint                                    index, uint count, Game.RefPredicate        <T> predicate)                       =>     SharedList<T>.List                                   .FindIndex    (index, count, predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   int                                            FindIndex                                                                              (uint                                    index, uint count, Game.RefReadOnlyPredicate<T> predicate)                       =>     SharedList<T>.List                                   .FindIndex    (index, count, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            FindIndex                                                                              (uint                                    index, uint count, System.Predicate                 <T> predicate)                       =>     SharedList<T>.List                                   .FindIndex    (index, count, predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   ref T                                          FindLast                                                                               (Game.RefPredicate        <T>    predicate)                                                                               => ref SharedList<T>.List                                   .FindLast     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   ref T                                          FindLast                                                                               (Game.RefReadOnlyPredicate<T>    predicate)                                                                               => ref SharedList<T>.List                                   .FindLast     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   ref T                                          FindLast                                                                               (System.Predicate                 <T>    predicate)                                                                               => ref SharedList<T>.List                                   .FindLast     (predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   int                                            FindLastIndex                                                                          (Game.RefPredicate        <T>    predicate)                                                                               =>     SharedList<T>.List                                   .FindLastIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   int                                            FindLastIndex                                                                          (Game.RefReadOnlyPredicate<T>    predicate)                                                                               =>     SharedList<T>.List                                   .FindLastIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            FindLastIndex                                                                          (System.Predicate                 <T>    predicate)                                                                               =>     SharedList<T>.List                                   .FindLastIndex(predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   int                                            FindLastIndex                                                                          (uint                                    index,             Game.RefPredicate        <T> predicate)                       =>     SharedList<T>.List                                   .FindLastIndex(index,        predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   int                                            FindLastIndex                                                                          (uint                                    index,             Game.RefReadOnlyPredicate<T> predicate)                       =>     SharedList<T>.List                                   .FindLastIndex(index,        predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            FindLastIndex                                                                          (uint                                    index,             System.Predicate                 <T> predicate)                       =>     SharedList<T>.List                                   .FindLastIndex(index,        predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   int                                            FindLastIndex                                                                          (uint                                    index, uint count, Game.RefPredicate        <T> predicate)                       =>     SharedList<T>.List                                   .FindLastIndex(index, count, predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   int                                            FindLastIndex                                                                          (uint                                    index, uint count, Game.RefReadOnlyPredicate<T> predicate)                       =>     SharedList<T>.List                                   .FindLastIndex(index, count, predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            FindLastIndex                                                                          (uint                                    index, uint count, System.Predicate                 <T> predicate)                       =>     SharedList<T>.List                                   .FindLastIndex(index, count, predicate);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   void                                           ForEach                                                                                (Game.RefAction        <T>       action)                                                                                  =>     SharedList<T>.List                                   .ForEach      (action);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   void                                           ForEach                                                                                (Game.RefReadOnlyAction<T>       action)                                                                                  =>     SharedList<T>.List                                   .ForEach      (action);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           ForEach                                                                                (System.Action                 <T>       action)                                                                                  =>     SharedList<T>.List                                   .ForEach      (action);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   Game.Collections.RefList<T>.Enumerator GetEnumerator                                                                          ()                                                                                                                                =>     SharedList<T>.List                                   .GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)] public   SharedList<T>                                  GetRange                                                                               (uint index, uint count)                                                                                                          => new(SharedList<T>.List                                   .GetRange     (index, count));
      [GameMethod(AggressiveInlining), GameResolution(0)] public   ref T                                          GetValue                                                                               (uint index)                                                                                                                      => ref SharedList<T>.List                                   [index];
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            IndexOf                                                                                (in T element)                                                                                                                    =>     SharedList<T>.List                                   .IndexOf      (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            IndexOf                                                                                (in T element, uint                                      index)                                                                   =>     SharedList<T>.List                                   .IndexOf      (in element, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            IndexOf                                                                                (in T element, uint                                      index, uint count)                                                       =>     SharedList<T>.List                                   .IndexOf      (in element, index, count);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           Insert                                                                                 (uint index,   in T                                      element)                                                                 =>     SharedList<T>.List                                   .Insert       (index,      element);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           InsertRange                                                                            (uint index,   System.Collections.Generic.ICollection<T> collection)                                                              =>     SharedList<T>.List                                   .InsertRange  (index,      collection);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           InsertRange                                                                            (uint index,   System.Collections.Generic.IEnumerable<T> enumerable)                                                              =>     SharedList<T>.List                                   .InsertRange  (index,      enumerable);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           InsertRange                                                                            (uint index,   in System.Memory                      <T> memory)                                                                  =>     SharedList<T>.List                                   .InsertRange  (index,      in memory);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           InsertRange                                                                            (uint index,   in System.ReadOnlyMemory              <T> memory)                                                                  =>     SharedList<T>.List                                   .InsertRange  (index,      in memory);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           InsertRange                                                                            (uint index,   in System.ReadOnlySpan                <T> span)                                                                    =>     SharedList<T>.List                                   .InsertRange  (index,      in span);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           InsertRange                                                                            (uint index,   in System.Span                        <T> span)                                                                    =>     SharedList<T>.List                                   .InsertRange  (index,      in span);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           InsertRange                                                                            (uint index,   in Util.Array<T>.Copyable                 copyable)                                                                =>     SharedList<T>.List                                   .InsertRange  (index,      in copyable);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   bool                                           IsEmpty                                                                                ()                                                                                                                                =>     SharedList<T>.List                                   .IsEmpty      ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            LastIndexOf                                                                            (in T element)                                                                                                                    =>     SharedList<T>.List                                   .LastIndexOf  (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            LastIndexOf                                                                            (in T element, uint index)                                                                                                        =>     SharedList<T>.List                                   .LastIndexOf  (in element, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   int                                            LastIndexOf                                                                            (in T element, uint index, uint count)                                                                                            =>     SharedList<T>.List                                   .LastIndexOf  (in element, index, count);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   ref T                                          Prepend                                                                                (in T element)                                                                                                                    => ref SharedList<T>.List                                   .Prepend      (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   ref T                                          Random                                                                                 ()                                                                                                                                => ref SharedList<T>.List                                   .Random       ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public   bool                                           Remove                                                                                 (in T                                 element)                                                                                    =>     SharedList<T>.List                                   .Remove       (in element);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   uint                                           RemoveAll                                                                              (Game.RefPredicate        <T> predicate)                                                                                  =>     SharedList<T>.List                                   .RemoveAll    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   uint                                           RemoveAll                                                                              (Game.RefReadOnlyPredicate<T> predicate)                                                                                  =>     SharedList<T>.List                                   .RemoveAll    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   uint                                           RemoveAll                                                                              (System.Predicate                 <T> predicate)                                                                                  =>     SharedList<T>.List                                   .RemoveAll    (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           RemoveAt                                                                               (uint                                 index)                                                                                      =>     SharedList<T>.List                                   .RemoveAt     (index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           RemoveRange                                                                            (uint                                 index, uint count)                                                                          =>     SharedList<T>.List                                   .RemoveRange  (index, count);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           Reverse                                                                                ()                                                                                                                                =>     SharedList<T>.List                                   .Reverse      ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           Reverse                                                                                (uint index, uint count)                                                                                                          =>     SharedList<T>.List                                   .Reverse      (index, count);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           SetValue                                                                               (uint index, in T element)                                                                                                        =>     SharedList<T>.List                                   [index] = element;
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           Sort                                                                                   ()                                                                                                                                =>     SharedList<T>.List                                   .Sort         ();
      [GameMethod(AggressiveInlining), GameResolution(2)] public   void                                           Sort                                                                                   (Game.Collections.IRefComparer        <T>? comparer)                                                                      =>     SharedList<T>.List                                   .Sort         (comparer);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   void                                           Sort                                                                                   (Game.Collections.IRefReadOnlyComparer<T>? comparer)                                                                      =>     SharedList<T>.List                                   .Sort         (comparer);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   void                                           Sort                                                                                   (Game.RefComparison                   <T>  comparison)                                                                    =>     SharedList<T>.List                                   .Sort         (comparison);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   void                                           Sort                                                                                   (Game.RefReadOnlyComparison           <T>  comparison)                                                                    =>     SharedList<T>.List                                   .Sort         (comparison);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           Sort                                                                                   (System.Collections.Generic.IComparer         <T>? comparer)                                                                      =>     SharedList<T>.List                                   .Sort         (comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           Sort                                                                                   (System.Comparison                            <T>  comparison)                                                                    =>     SharedList<T>.List                                   .Sort         (comparison);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   void                                           Sort                                                                                   (uint                                              index, uint count, Game.Collections.IRefComparer        <T>? comparer) =>     SharedList<T>.List                                   .Sort         (index, count, comparer);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   void                                           Sort                                                                                   (uint                                              index, uint count, Game.Collections.IRefReadOnlyComparer<T>? comparer) =>     SharedList<T>.List                                   .Sort         (index, count, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           Sort                                                                                   (uint                                              index, uint count, System.Collections.Generic.IComparer         <T>? comparer) =>     SharedList<T>.List                                   .Sort         (index, count, comparer);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   T[]                                            ToArray                                                                                ()                                                                                                                                =>     SharedList<T>.List                                   .ToArray      ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           TrimExcess                                                                             ()                                                                                                                                =>     SharedList<T>.List                                   .TrimExcess   ();
      [GameMethod(AggressiveInlining), GameResolution(0)] public   void                                           TrimExcess                                                                             (uint capacity)                                                                                                                   =>     SharedList<T>.List                                   .TrimExcess   (capacity);
      [GameMethod(AggressiveInlining), GameResolution(2)] public   bool                                           TrueForAll                                                                             (Game.RefPredicate        <T> predicate)                                                                                  =>     SharedList<T>.List                                   .TrueForAll   (predicate);
      [GameMethod(AggressiveInlining), GameResolution(1)] public   bool                                           TrueForAll                                                                             (Game.RefReadOnlyPredicate<T> predicate)                                                                                  =>     SharedList<T>.List                                   .TrueForAll   (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   bool                                           TrueForAll                                                                             (System.Predicate                 <T> predicate)                                                                                  =>     SharedList<T>.List                                   .TrueForAll   (predicate);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   bool                                           TryAdd                                                                                 (in T                                 element)                                                                                    =>     SharedList<T>.List                                   .TryAdd       (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] public   ref T                                          TryAppend                                                                              (in T                                 element)                                                                                    => ref SharedList<T>.List                                   .TryAppend    (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                    Game.Collections.IRefEquatable<Game.Collections.IShared>.Equals        (ref Game.Collections.IShared shared)                                                                                     =>     this                                                 .Equals       (shared);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                    Game.Collections.IRefReadOnlyEquatable<Game.Collections.IShared>.Equals(in  Game.Collections.IShared shared)                                                                                     =>     this                                                 .Equals       (shared);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                    Game.Collections.IRefEquatable<SharedList<T>>.Equals                           (ref SharedList                   <T> list)                                                                                       =>     this                                                 .Equals       (in list);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                    Game.Collections.IRefReadOnlyEquatable<SharedList<T>>.Equals                   (in  SharedList                   <T> list)                                                                                       =>     this                                                 .Equals       (in list);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                    System.Collections.Generic.ICollection<T>.Add                                          (T                                    element)                                                                                    =>     this                                                 .Add          (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                    System.Collections.Generic.ICollection<T>.Clear                                        ()                                                                                                                                =>     this                                                 .Clear        ();
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                    System.Collections.Generic.ICollection<T>.Contains                                     (T   element)                                                                                                                     =>     this                                                 .Contains     (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                    System.Collections.Generic.ICollection<T>.CopyTo                                       (T[] array, int index)                                                                                                            =>     this                                                 .CopyTo       (array, (uint) index);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                    System.Collections.Generic.ICollection<T>.Remove                                       (T   element)                                                                                                                     =>     this                                                 .Remove       (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] System.Collections.Generic.IEnumerator<T>               System.Collections.Generic.IEnumerable<T>.GetEnumerator                                ()                                                                                                                                =>     this                                                 .GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                                     System.Collections.Generic.IList<T>.IndexOf                                            (T            element)                                                                                                            =>     this                                                 .IndexOf      (in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                    System.Collections.Generic.IList<T>.Insert                                             (int          index, T element)                                                                                                   =>     this                                                 .Insert       ((uint) index, in element);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                    System.Collections.Generic.IList<T>.RemoveAt                                           (int          index)                                                                                                              =>     this                                                 .RemoveAt     ((uint) index);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                    System.Collections.ICollection.CopyTo                                                  (System.Array array, int index)                                                                                                   =>     ((System.Collections.ICollection) SharedList<T>.List).CopyTo       (array, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] System.Collections.IEnumerator                          System.Collections.IEnumerable.GetEnumerator                                           ()                                                                                                                                =>     this                                                 .GetEnumerator();
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                                     System.Collections.IList.Add                                                           (object? element)                                                                                                                 {      this                                                 .Add          ((T) element!); return (int) this.Count; }
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                    System.Collections.IList.Clear                                                         ()                                                                                                                                =>     this                                                 .Clear        ();
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                    System.Collections.IList.Contains                                                      (object? element)                                                                                                                 =>     this                                                 .Contains     ((T) element!);
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                                     System.Collections.IList.IndexOf                                                       (object? element)                                                                                                                 =>     this                                                 .IndexOf      ((T) element!);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                    System.Collections.IList.Insert                                                        (int     index, object? element)                                                                                                  =>     this                                                 .Insert       ((uint) index, (T) element!);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                    System.Collections.IList.Remove                                                        (object? element)                                                                                                                 =>     this                                                 .Remove       ((T) element!);
      [GameMethod(AggressiveInlining), GameResolution(0)] void                                                    System.Collections.IList.RemoveAt                                                      (int     index)                                                                                                                   =>     this                                                 .RemoveAt     ((uint) index);
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                                     System.Collections.IStructuralComparable.CompareTo                                     (object?                              value, System.Collections.IComparer         comparer)                                       =>     0;
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                    System.Collections.IStructuralEquatable.Equals                                         (object?                              value, System.Collections.IEqualityComparer comparer)                                       =>     false;
      [GameMethod(AggressiveInlining), GameResolution(0)] int                                                     System.Collections.IStructuralEquatable.GetHashCode                                    (System.Collections.IEqualityComparer comparer)                                                                                   =>     0;
      [GameMethod(AggressiveInlining), GameResolution(0)] object                                                  System.ICloneable.Clone                                                                ()                                                                                                                                =>     this.Clone ();
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                    System.IEquatable<Game.Collections.IShared>.Equals                             (Game.Collections.IShared shared)                                                                                         =>     this.Equals(shared);
      [GameMethod(AggressiveInlining), GameResolution(0)] bool                                                    System.IEquatable<SharedList<T>>.Equals                                                (SharedList<T>                    list)                                                                                           =>     this.Equals(list);

      [GameMethod(AggressiveInlining), GameResolution(0)]
      public static implicit operator Game.Collections.RefList<T>(in SharedList<T> sharedList) => SharedList<T>.List;

      public ref T          this                                    [uint         index] => ref SharedList<T>.List[index];
      public     RefList<T> this                                    [System.Range range] =>     SharedList<T>.List[range];
      T                     System.Collections.Generic.IList<T>.this[int          index] { get => this[(uint) index]; set => this[(uint) index] = value; }
      object?               System.Collections.IList.this           [int          index] { get => this[(uint) index]; set => this[(uint) index] = (T) value!; }
    }
      public class GameObjectSharedList<T> : Game.Collections.SharedList<T>, Game.Collections.IRefEquatable<GameObjectSharedList<T>>, System.Collections.Generic.IList<T>, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.ICloneable where T : UnityEngine.Object /* ->> `UnityEngine.Component` or `UnityEngine.GameObject` */ {
        int    System.Collections.Generic.ICollection<T>.Count      => ((int) base.Count);
        bool   System.Collections.Generic.ICollection<T>.IsReadOnly => false;
        int    System.Collections.ICollection.Count                 => ((int) base.Count);
        bool   System.Collections.ICollection.IsSynchronized        => false;
        object System.Collections.ICollection.SyncRoot              => Game.Collections.SharedList<T>.List;
        bool   System.Collections.IList.IsFixedSize                 => false;
        bool   System.Collections.IList.IsReadOnly                  => false;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)] internal GameObjectSharedList(uint                                   capacity = 0u) : base(capacity) {}
        [GameConstructor, GameMethod(AggressiveInlining)] internal GameObjectSharedList(GameObjectSharedList               <T> list)          : base(list)     {}
        [GameConstructor, GameMethod(AggressiveInlining)] private  GameObjectSharedList(Game.Collections.SharedList<T> list)          : base(list)     {}

        /* … */
        [GameMethod(AggressiveInlining), GameResolution(0)] internal new void           Add     (in T                                      element)    =>     base.Add     (element);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal new void           AddRange(System.Collections.Generic.ICollection<T> collection) =>     base.AddRange(collection);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal new void           AddRange(System.Collections.Generic.IEnumerable<T> enumerable) =>     base.AddRange(enumerable);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal new void           AddRange(in System.Memory                      <T> memory)     =>     base.AddRange(in memory);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal new void           AddRange(in System.ReadOnlyMemory              <T> memory)     =>     base.AddRange(in memory);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal new void           AddRange(in System.ReadOnlySpan                <T> span)       =>     base.AddRange(in span);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal new void           AddRange(in System.Span                        <T> span)       =>     base.AddRange(in span);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal new void           AddRange(in Util.Array<T>.Copyable                 copyable)   =>     base.AddRange(in copyable);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal new ref readonly T Append  (in T                                      element)    => ref base.Append  (element);

        [GameMethod(AggressiveInlining), GameResolution(0)] public GameObjectSharedList<U> ByComponent<U>() where U : UnityEngine.Component => this.ByComponent(typeof(U)).ConvertAll(static element => (U) element);
        public GameObjectSharedList<UnityEngine.Component> ByComponent(System.Type type) {
          GameObjectSharedList<UnityEngine.Component> list = new(this.Count);

          // … ->> Avoid overriding underlying `GameObjectSharedList<UnityEngine.Component>.List` prematurely
          if (typeof(T) != typeof(UnityEngine.Component)) {
            list.Clear();

            foreach (T value in this)
            switch (value) {
              case UnityEngine.Component  component : list.Add(component .GetComponent(type)); break;
              case UnityEngine.GameObject gameObject: list.Add(gameObject.GetComponent(type)); break;
            }
          }

          return list;
        }

        [GameMethod(AggressiveInlining), GameResolution(0)]
        public GameObjectSharedList<T> ByName(string name) {
          this.RemoveAll(value => name != value.name);
          return new();
        }

        [GameMethod(AggressiveInlining), GameResolution(0)]
        public GameObjectSharedList<T> ByTag(string tag) {
          this.RemoveAll(value => value switch {
            UnityEngine.Component  component  => component .tag == tag,
            UnityEngine.GameObject gameObject => gameObject.tag == tag,
            _                                 => false
          });

          return new();
        }

        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    Clear                                                                         ()                                                                                                                                =>     base                                                 .Clear        ();
        [GameMethod(AggressiveInlining), GameResolution(2)] public             new GameObjectSharedList<U> ConvertAll<U>                                                                 (Game.RefConverter        <T, U> converter) where U : UnityEngine.Object /* ->> T */                                       => new(base                                                 .ConvertAll<U>(converter));
        [GameMethod(AggressiveInlining), GameResolution(1)] public             new GameObjectSharedList<U> ConvertAll<U>                                                                 (Game.RefReadOnlyConverter<T, U> converter) where U : UnityEngine.Object /* ->> T */                                       => new(base                                                 .ConvertAll<U>(converter));
        [GameMethod(AggressiveInlining), GameResolution(0)] public             new GameObjectSharedList<U> ConvertAll<U>                                                                 (System.Converter                 <T, U> converter) where U : UnityEngine.Object /* ->> T */                                       => new(base                                                 .ConvertAll<U>(converter));
        [GameMethod(AggressiveInlining), GameResolution(0)] public                 bool                    Equals                                                                        (in GameObjectSharedList          <T>    list)                                                                                    =>     base                                                 .Equals       ((Game.Collections.SharedList<T>) list);
        [GameMethod(AggressiveInlining), GameResolution(2)] internal           new GameObjectSharedList<T> FindAll                                                                       (Game.RefPredicate        <T>    predicate)                                                                               => new(base                                                 .FindAll      (predicate));
        [GameMethod(AggressiveInlining), GameResolution(1)] internal           new GameObjectSharedList<T> FindAll                                                                       (Game.RefReadOnlyPredicate<T>    predicate)                                                                               => new(base                                                 .FindAll      (predicate));
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new GameObjectSharedList<T> FindAll                                                                       (System.Predicate                 <T>    predicate)                                                                               => new(base                                                 .FindAll      (predicate));
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new GameObjectSharedList<T> GetRange                                                                      (uint                                    index, uint                                      count)                                  => new(base                                                 .GetRange     (index, count));
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    Insert                                                                        (uint                                    index, in T                                      element)                                =>     base                                                 .Insert       (index, element);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    InsertRange                                                                   (uint                                    index, System.Collections.Generic.ICollection<T> collection)                             =>     base                                                 .InsertRange  (index, collection);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    InsertRange                                                                   (uint                                    index, System.Collections.Generic.IEnumerable<T> enumerable)                             =>     base                                                 .InsertRange  (index, enumerable);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    InsertRange                                                                   (uint                                    index, in System.Memory                      <T> memory)                                 =>     base                                                 .InsertRange  (index, in memory);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    InsertRange                                                                   (uint                                    index, in System.ReadOnlyMemory              <T> memory)                                 =>     base                                                 .InsertRange  (index, in memory);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    InsertRange                                                                   (uint                                    index, in System.ReadOnlySpan                <T> span)                                   =>     base                                                 .InsertRange  (index, in span);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    InsertRange                                                                   (uint                                    index, in System.Span                        <T> span)                                   =>     base                                                 .InsertRange  (index, in span);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    InsertRange                                                                   (uint                                    index, in Util.Array<T>.Copyable                 copyable)                               =>     base                                                 .InsertRange  (index, in copyable);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new ref readonly T          Prepend                                                                       (in T                                    element)                                                                                 => ref base                                                 .Prepend      (element);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new bool                    Remove                                                                        (in T                                    element)                                                                                 =>     base                                                 .Remove       (element);
        [GameMethod(AggressiveInlining), GameResolution(2)] internal           new uint                    RemoveAll                                                                     (Game.RefPredicate        <T>    predicate)                                                                               =>     base                                                 .RemoveAll    (predicate);
        [GameMethod(AggressiveInlining), GameResolution(1)] internal           new uint                    RemoveAll                                                                     (Game.RefReadOnlyPredicate<T>    predicate)                                                                               =>     base                                                 .RemoveAll    (predicate);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new uint                    RemoveAll                                                                     (System.Predicate                 <T>    predicate)                                                                               =>     base                                                 .RemoveAll    (predicate);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    RemoveAt                                                                      (uint                                    index)                                                                                   =>     base                                                 .RemoveAt     (index);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    RemoveRange                                                                   (uint                                    index, uint count)                                                                       =>     base                                                 .RemoveRange  (index, count);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    Reverse                                                                       ()                                                                                                                                =>     base                                                 .Reverse      ();
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    Reverse                                                                       (uint index, uint count)                                                                                                          =>     base                                                 .Reverse      (index, count);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    Sort                                                                          ()                                                                                                                                =>     base                                                 .Sort         ();
        [GameMethod(AggressiveInlining), GameResolution(2)] internal           new void                    Sort                                                                          (Game.Collections.IRefComparer        <T>? comparer)                                                                      =>     base                                                 .Sort         (comparer);
        [GameMethod(AggressiveInlining), GameResolution(1)] internal           new void                    Sort                                                                          (Game.Collections.IRefReadOnlyComparer<T>? comparer)                                                                      =>     base                                                 .Sort         (comparer);
        [GameMethod(AggressiveInlining), GameResolution(2)] internal           new void                    Sort                                                                          (Game.RefComparison                   <T>  comparison)                                                                    =>     base                                                 .Sort         (comparison);
        [GameMethod(AggressiveInlining), GameResolution(1)] internal           new void                    Sort                                                                          (Game.RefReadOnlyComparison           <T>  comparison)                                                                    =>     base                                                 .Sort         (comparison);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    Sort                                                                          (System.Collections.Generic.IComparer         <T>? comparer)                                                                      =>     base                                                 .Sort         (comparer);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    Sort                                                                          (System.Comparison                            <T>  comparison)                                                                    =>     base                                                 .Sort         (comparison);
        [GameMethod(AggressiveInlining), GameResolution(2)] internal           new void                    Sort                                                                          (uint                                              index, uint count, Game.Collections.IRefComparer        <T>? comparer) =>     base                                                 .Sort         (index, count, comparer);
        [GameMethod(AggressiveInlining), GameResolution(1)] internal           new void                    Sort                                                                          (uint                                              index, uint count, Game.Collections.IRefReadOnlyComparer<T>? comparer) =>     base                                                 .Sort         (index, count, comparer);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new void                    Sort                                                                          (uint                                              index, uint count, System.Collections.Generic.IComparer         <T>? comparer) =>     base                                                 .Sort         (index, count, comparer);
        [GameMethod(AggressiveInlining), GameResolution(0)] protected internal new void                    TrimExcess                                                                    ()                                                                                                                                =>     base                                                 .TrimExcess   ();
        [GameMethod(AggressiveInlining), GameResolution(0)] protected internal new void                    TrimExcess                                                                    (uint                        capacity)                                                                                            =>     base                                                 .TrimExcess   (capacity);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new bool                    TryAdd                                                                        (in T                        element)                                                                                             =>     base                                                 .TryAdd       (in element);
        [GameMethod(AggressiveInlining), GameResolution(0)] internal           new ref readonly T          TryAppend                                                                     (in T                        element)                                                                                             => ref base                                                 .TryAppend    (in element);
        [GameMethod(AggressiveInlining), GameResolution(0)] bool                                           Game.Collections.IRefEquatable<GameObjectSharedList<T>>.Equals        (ref GameObjectSharedList<T> list)                                                                                                =>     this                                                 .Equals       (in list);
        [GameMethod(AggressiveInlining), GameResolution(0)] bool                                           Game.Collections.IRefReadOnlyEquatable<GameObjectSharedList<T>>.Equals(in  GameObjectSharedList<T> list)                                                                                                =>     this                                                 .Equals       (in list);
        [GameMethod(AggressiveInlining), GameResolution(0)] void                                           System.Collections.Generic.ICollection<T>.Add                                 (T                           element)                                                                                             =>     base                                                 .Add          (in element);
        [GameMethod(AggressiveInlining), GameResolution(0)] void                                           System.Collections.Generic.ICollection<T>.Clear                               ()                                                                                                                                =>     base                                                 .Clear        ();
        [GameMethod(AggressiveInlining), GameResolution(0)] bool                                           System.Collections.Generic.ICollection<T>.Contains                            (T   element)                                                                                                                     =>     base                                                 .Contains     (in element);
        [GameMethod(AggressiveInlining), GameResolution(0)] void                                           System.Collections.Generic.ICollection<T>.CopyTo                              (T[] array, int index)                                                                                                            =>     base                                                 .CopyTo       (array, (uint) index);
        [GameMethod(AggressiveInlining), GameResolution(0)] bool                                           System.Collections.Generic.ICollection<T>.Remove                              (T   element)                                                                                                                     =>     base                                                 .Remove       (in element);
        [GameMethod(AggressiveInlining), GameResolution(0)] System.Collections.Generic.IEnumerator<T>      System.Collections.Generic.IEnumerable<T>.GetEnumerator                       ()                                                                                                                                =>     base                                                 .GetEnumerator();
        [GameMethod(AggressiveInlining), GameResolution(0)] int                                            System.Collections.Generic.IList<T>.IndexOf                                   (T            element)                                                                                                            =>     base                                                 .IndexOf      (in element);
        [GameMethod(AggressiveInlining), GameResolution(0)] void                                           System.Collections.Generic.IList<T>.Insert                                    (int          index, T element)                                                                                                   =>     base                                                 .Insert       ((uint) index, in element);
        [GameMethod(AggressiveInlining), GameResolution(0)] void                                           System.Collections.Generic.IList<T>.RemoveAt                                  (int          index)                                                                                                              =>     base                                                 .RemoveAt     ((uint) index);
        [GameMethod(AggressiveInlining), GameResolution(0)] void                                           System.Collections.ICollection.CopyTo                                         (System.Array array, int index)                                                                                                   =>     ((System.Collections.ICollection) SharedList<T>.List).CopyTo       (array, index);
        [GameMethod(AggressiveInlining), GameResolution(0)] System.Collections.IEnumerator                 System.Collections.IEnumerable.GetEnumerator                                  ()                                                                                                                                =>     base                                                 .GetEnumerator();
        [GameMethod(AggressiveInlining), GameResolution(0)] int                                            System.Collections.IList.Add                                                  (object? element)                                                                                                                 {      base                                                 .Add          ((T) element!); return (int) base.Count; }
        [GameMethod(AggressiveInlining), GameResolution(0)] void                                           System.Collections.IList.Clear                                                ()                                                                                                                                =>     base                                                 .Clear        ();
        [GameMethod(AggressiveInlining), GameResolution(0)] bool                                           System.Collections.IList.Contains                                             (object? element)                                                                                                                 =>     base                                                 .Contains     ((T) element!);
        [GameMethod(AggressiveInlining), GameResolution(0)] int                                            System.Collections.IList.IndexOf                                              (object? element)                                                                                                                 =>     base                                                 .IndexOf      ((T) element!);
        [GameMethod(AggressiveInlining), GameResolution(0)] void                                           System.Collections.IList.Insert                                               (int     index, object? element)                                                                                                  =>     base                                                 .Insert       ((uint) index, (T) element!);
        [GameMethod(AggressiveInlining), GameResolution(0)] void                                           System.Collections.IList.Remove                                               (object? element)                                                                                                                 =>     base                                                 .Remove       ((T) element!);
        [GameMethod(AggressiveInlining), GameResolution(0)] void                                           System.Collections.IList.RemoveAt                                             (int     index)                                                                                                                   =>     base                                                 .RemoveAt     ((uint) index);
        [GameMethod(AggressiveInlining), GameResolution(0)] int                                            System.Collections.IStructuralComparable.CompareTo                            (object?                              value, System.Collections.IComparer         comparer)                                       =>     0;
        [GameMethod(AggressiveInlining), GameResolution(0)] bool                                           System.Collections.IStructuralEquatable.Equals                                (object?                              value, System.Collections.IEqualityComparer comparer)                                       =>     false;
        [GameMethod(AggressiveInlining), GameResolution(0)] int                                            System.Collections.IStructuralEquatable.GetHashCode                           (System.Collections.IEqualityComparer comparer)                                                                                   =>     0;
        [GameMethod(AggressiveInlining), GameResolution(0)] object                                         System.ICloneable.Clone                                                       ()                                                                                                                                =>     this.Clone ();
        [GameMethod(AggressiveInlining), GameResolution(0)] bool                                           System.IEquatable<GameObjectSharedList<T>>.Equals                             (GameObjectSharedList<T> list)                                                                                                    =>     this.Equals(list);
      }

    public readonly struct SharedMono<T> : /* System.DynamicObject, */ Game.Collections.IMono, Game.Collections.IRefEquatable<SharedMono<T>>, Game.Collections.IShared {
      internal static Game.Collections.Mono<T> Mono = new();

      public readonly ref readonly bool HasValue                                => ref SharedMono<T>.Mono.HasValue;
      public readonly ref T             Value                                   => ref SharedMono<T>.Mono.Value;
      readonly bool                     Game.Collections.IMono.HasValue =>     this              .HasValue;
      readonly object?                  Game.Collections.IMono.Value    =>     this              .Value;
      readonly object?                  Game.Collections.IShared.Value  =>     this              .Value;

      /* … */
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in T                                  value)      => SharedMono<T>.Mono.Equals(in value);
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in Game.Collections.IMono     mono)       => SharedMono<T>.Mono.Equals(mono  .Value);
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in Game.Collections.IShared   shared)     => SharedMono<T>.Mono.Equals(shared.Value);
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in Game.Collections.Mono  <T> mono)       => SharedMono<T>.Mono.Equals(in mono);
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in Game.Collections.Shared<T> shared)     => SharedMono<T>.Mono.Equals(in shared.Value);
      [GameMethod(AggressiveInlining)] public          readonly bool    Equals                                                                                 (in SharedMono                     <T> sharedMono) => true;
      [GameMethod(AggressiveInlining)] public override readonly bool    Equals                                                                                 (object?                               value)      => value is SharedMono<T> || value switch { Game.Collections.Shared<T> shared => this.Equals(shared), Game.Collections.IShared shared => this.Equals(shared), _ => SharedMono<T>.Mono.Equals(value) };
      [GameMethod(AggressiveInlining)] public override readonly int     GetHashCode                                                                            ()                                                 => SharedMono<T>.Mono.GetHashCode      ();
      [GameMethod(AggressiveInlining)] public          readonly T       GetValueOrDefault                                                                      ()                                                 => SharedMono<T>.Mono.GetValueOrDefault();
      [GameMethod(AggressiveInlining)] public          readonly T       GetValueOrDefault                                                                      (in T fallback)                                    => SharedMono<T>.Mono.GetValueOrDefault(in fallback);
      [GameMethod(AggressiveInlining)] public override readonly string? ToString                                                                               ()                                                 => SharedMono<T>.Mono.ToString         ();
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefEquatable<Game.Collections.IMono>.Equals          (ref Game.Collections.IMono   mono)        => this.Equals(mono);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefEquatable<Game.Collections.IShared>.Equals        (ref Game.Collections.IShared shared)      => this.Equals(shared);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefEquatable<SharedMono<T>>.Equals                           (ref SharedMono<T>                    sharedMono)  => this.Equals(in sharedMono);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefReadOnlyEquatable<Game.Collections.IMono>.Equals  (in  Game.Collections.IMono   mono)        => this.Equals(mono);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefReadOnlyEquatable<Game.Collections.IShared>.Equals(in  Game.Collections.IShared shared)      => this.Equals(shared);
      [GameMethod(AggressiveInlining)] readonly bool                    Game.Collections.IRefReadOnlyEquatable<SharedMono<T>>.Equals                   (in  SharedMono<T>                    sharedMono)  => this.Equals(in sharedMono);
      [GameMethod(AggressiveInlining)] readonly bool                    System.IEquatable<Game.Collections.IMono>.Equals                               (Game.Collections.IMono       mono)        => this.Equals(mono);
      [GameMethod(AggressiveInlining)] readonly bool                    System.IEquatable<Game.Collections.IShared>.Equals                             (Game.Collections.IShared     shared)      => this.Equals(shared);
      [GameMethod(AggressiveInlining)] readonly bool                    System.IEquatable<SharedMono<T>>.Equals                                                (SharedMono<T>                        sharedMono)  => this.Equals(sharedMono);

      [GameMethod(AggressiveInlining)] public static bool          operator false(in SharedMono<T>                      sharedMono)                                                     =>  SharedMono<T>.Mono ? false : true;
      [GameMethod(AggressiveInlining)] public static bool          operator true (in SharedMono<T>                      sharedMono)                                                     =>  SharedMono<T>.Mono ? true  : false;
      [GameMethod(AggressiveInlining)] public static bool          operator !    (in SharedMono<T>                      sharedMono)                                                     => !SharedMono<T>.Mono;
      [GameMethod(AggressiveInlining)] public static SharedMono<T> operator +    (in SharedMono<T>                      sharedMono,  in T                                  value)       { SharedMono<T>.Mono += value; return sharedMono; }
      [GameMethod(AggressiveInlining)] public static bool          operator ==   (in T                                  value,       in SharedMono<T>                      sharedMono)  => value == SharedMono<T>.Mono;
      [GameMethod(AggressiveInlining)] public static bool          operator ==   (Game.Collections.IMono        mono,        in SharedMono<T>                      sharedMono)  => mono  == SharedMono<T>.Mono;
      [GameMethod(AggressiveInlining)] public static bool          operator ==   (Game.Collections.IShared      shared,      in SharedMono<T>                      sharedMono)  => SharedMono<T>.Mono.HasValue && (shared.Value?.Equals(SharedMono<T>.Mono.Value) ?? false);
      [GameMethod(AggressiveInlining)] public static bool          operator ==   (in Game.Collections.Mono  <T> mono,        in SharedMono<T>                      sharedMono)  => mono         == SharedMono<T>.Mono;
      [GameMethod(AggressiveInlining)] public static bool          operator ==   (in Game.Collections.Shared<T> shared,      in SharedMono<T>                      sharedMono)  => shared.Value == SharedMono<T>.Mono;
      [GameMethod(AggressiveInlining)] public static bool          operator ==   (in SharedMono                     <T> sharedMono,  in T                                  value)       => SharedMono<T>.Mono == value;
      [GameMethod(AggressiveInlining)] public static bool          operator ==   (in SharedMono                     <T> sharedMono,  Game.Collections.IMono        mono)        => SharedMono<T>.Mono == mono;
      [GameMethod(AggressiveInlining)] public static bool          operator ==   (in SharedMono                     <T> sharedMono,  Game.Collections.IShared      shared)      => SharedMono<T>.Mono.Equals(shared.Value);
      [GameMethod(AggressiveInlining)] public static bool          operator ==   (in SharedMono                     <T> sharedMono,  in Game.Collections.Mono  <T> mono)        => SharedMono<T>.Mono == mono;
      [GameMethod(AggressiveInlining)] public static bool          operator ==   (in SharedMono                     <T> sharedMono,  in Game.Collections.Shared<T> shared)      => SharedMono<T>.Mono == shared.Value;
      [GameMethod(AggressiveInlining)] public static bool          operator ==   (in SharedMono                     <T> sharedMonoA, in SharedMono                     <T> sharedMonoB) => true;
      [GameMethod(AggressiveInlining)] public static bool          operator !=   (in T                                  value,       in SharedMono<T>                      sharedMono)  => value != SharedMono<T>.Mono;
      [GameMethod(AggressiveInlining)] public static bool          operator !=   (Game.Collections.IMono        mono,        in SharedMono<T>                      sharedMono)  => mono  != SharedMono<T>.Mono;
      [GameMethod(AggressiveInlining)] public static bool          operator !=   (Game.Collections.IShared      shared,      in SharedMono<T>                      sharedMono)  => !(shared == sharedMono);
      [GameMethod(AggressiveInlining)] public static bool          operator !=   (in Game.Collections.Mono  <T> mono,        in SharedMono<T>                      sharedMono)  => mono         != SharedMono<T>.Mono;
      [GameMethod(AggressiveInlining)] public static bool          operator !=   (in Game.Collections.Shared<T> shared,      in SharedMono<T>                      sharedMono)  => shared.Value != SharedMono<T>.Mono;
      [GameMethod(AggressiveInlining)] public static bool          operator !=   (in SharedMono                     <T> sharedMono,  in T                                  value)       => SharedMono<T>.Mono != value;
      [GameMethod(AggressiveInlining)] public static bool          operator !=   (in SharedMono                     <T> sharedMono,  Game.Collections.IMono        mono)        => SharedMono<T>.Mono != mono;
      [GameMethod(AggressiveInlining)] public static bool          operator !=   (in SharedMono                     <T> sharedMono,  Game.Collections.IShared      shared)      => !(sharedMono == shared);
      [GameMethod(AggressiveInlining)] public static bool          operator !=   (in SharedMono                     <T> sharedMono,  in Game.Collections.Mono  <T> mono)        => SharedMono<T>.Mono != mono;
      [GameMethod(AggressiveInlining)] public static bool          operator !=   (in SharedMono                     <T> sharedMono,  in Game.Collections.Shared<T> shared)      => SharedMono<T>.Mono != shared.Value;
      [GameMethod(AggressiveInlining)] public static bool          operator !=   (in SharedMono                     <T> sharedMonoA, in SharedMono                     <T> sharedMonoB) => false;

      [GameMethod(AggressiveInlining)] public static explicit operator T                               (in SharedMono<T> sharedMono) => (T) SharedMono<T>.Mono;
      [GameMethod(AggressiveInlining)] public static implicit operator Game.Collections.Mono<T>(in SharedMono<T> sharedMono) =>     SharedMono<T>.Mono;
      [GameMethod(AggressiveInlining)] public static implicit operator SharedMono<T>                   (in T             value)      => new SharedMono<T>() + value;
    }

    public class Timeframe : Game.Collections.Keyframe, System.Collections.Generic.IReadOnlyDictionary<string, object?>, System.Collections.IDictionary {
      public new readonly struct Enumerator : System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<string, object?>>, System.Collections.IDictionaryEnumerator {
        public  readonly System.Collections.Generic.KeyValuePair<string, object?> Current => new(this.enumerator.Current, this.sequence[this.enumerator.Current]);
        private readonly Game.Collections.Keyframe.KeyEnumerator enumerator;
        private readonly Timeframe                                        sequence;
        readonly System.Collections.Generic.KeyValuePair<string, object?>         System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<string, object?>>.Current => this.Current;
        readonly System.Collections.DictionaryEntry                               System.Collections.IDictionaryEnumerator.Entry                                                           => new(this.Current.Key, this.Current.Value);
        readonly object                                                           System.Collections.IDictionaryEnumerator.Key                                                             => this.Current.Key;
        readonly object?                                                          System.Collections.IDictionaryEnumerator.Value                                                           => this.Current.Value;
        readonly object                                                           System.Collections.IEnumerator.Current                                                                   => this.Current!;

        [GameConstructor, GameMethod(AggressiveInlining)]
        internal Enumerator(Timeframe sequence) => this.enumerator = new Game.Collections.Keyframe.KeyEnumerable(this.sequence = sequence).GetEnumerator();

        [GameMethod(AggressiveInlining)] public readonly void Dispose                                () => this.enumerator.Dispose ();
        [GameMethod(AggressiveInlining)] public readonly bool MoveNext                               () => this.enumerator.MoveNext();
        [GameMethod(AggressiveInlining)] public readonly void Reset                                  () => this.enumerator.Reset   ();
        [GameMethod(AggressiveInlining)] readonly bool        System.Collections.IEnumerator.MoveNext() => this           .MoveNext();
        [GameMethod(AggressiveInlining)] readonly void        System.Collections.IEnumerator.Reset   () => this           .Reset   ();
        [GameMethod(AggressiveInlining)] readonly void        System.IDisposable.Dispose             () => this           .Dispose ();
      }

      public sealed class ValueCollection : System.Collections.Generic.ICollection<object?>, System.Collections.ICollection {
        private readonly Timeframe sequence;
        int                                System.Collections.Generic.ICollection<object?>.Count      => ((int) this.sequence.Count);
        bool                               System.Collections.Generic.ICollection<object?>.IsReadOnly => false;
        int                                System.Collections.ICollection.Count                       => ((int) this.sequence.Count);
        bool                               System.Collections.ICollection.IsSynchronized              => false;
        object                             System.Collections.ICollection.SyncRoot                    => this;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        internal ValueCollection(Timeframe sequence) => this.sequence = sequence;

        /* … */
        [GameMethod(AggressiveInlining)] private void                                    CopyTo                                                       (System.Array array, uint index) { foreach (object? value in this) array.SetValue(value, index++); }
        [GameMethod(AggressiveInlining)] public Timeframe.ValueEnumerator        GetEnumerator                                                ()                               => new(sequence);
        [GameMethod(NoInlining)]         void                                            System.Collections.Generic.ICollection<object?>.Add          (object? keyframe)               => throw new System.NotSupportedException("UI sequence values are dynamically generated and non-persistent");
        [GameMethod(NoInlining)]         void                                            System.Collections.Generic.ICollection<object?>.Clear        ()                               => throw new System.NotSupportedException("UI sequence values are dynamically generated and non-persistent");
        [GameMethod(NoInlining)]         bool                                            System.Collections.Generic.ICollection<object?>.Contains     (object?   keyframe)             => throw new System.NotSupportedException("UI sequence values are dynamically generated and non-persistent");
        [GameMethod(AggressiveInlining)] void                                            System.Collections.Generic.ICollection<object?>.CopyTo       (object?[] array, int index)     => this.CopyTo(array, (uint) index);
        [GameMethod(NoInlining)]         bool                                            System.Collections.Generic.ICollection<object?>.Remove       (object?   keyframe)             => throw new System.NotSupportedException("UI sequence values are dynamically generated and non-persistent");
        [GameMethod(AggressiveInlining)] System.Collections.Generic.IEnumerator<object?> System.Collections.Generic.IEnumerable<object?>.GetEnumerator()                               => this.GetEnumerator();
        [GameMethod(AggressiveInlining)] void                                            System.Collections.ICollection.CopyTo                        (System.Array array, int index)  => this.CopyTo(array, (uint) index);
        [GameMethod(AggressiveInlining)] System.Collections.IEnumerator                  System.Collections.IEnumerable.GetEnumerator                 ()                               => this.GetEnumerator();
      }

      public new readonly struct ValueEnumerator : System.Collections.Generic.IEnumerator<object?> {
        public  readonly object?                                                  Current => this.sequence[this.enumerator.Current];
        private readonly Game.Collections.Keyframe.KeyEnumerator enumerator;
        private readonly Timeframe                                        sequence;
        readonly object?                                                          System.Collections.Generic.IEnumerator<object?>.Current => this.Current;
        readonly object                                                           System.Collections.IEnumerator.Current                  => this.Current!;

        [GameConstructor, GameMethod(AggressiveInlining)]
        internal ValueEnumerator(Timeframe sequence) => this.enumerator = new Game.Collections.Keyframe.KeyEnumerable(this.sequence = sequence).GetEnumerator();

        [GameMethod(AggressiveInlining)] public readonly void Dispose                                () => this.enumerator.Dispose ();
        [GameMethod(AggressiveInlining)] public readonly bool MoveNext                               () => this.enumerator.MoveNext();
        [GameMethod(AggressiveInlining)] public readonly void Reset                                  () => this.enumerator.Reset   ();
        [GameMethod(AggressiveInlining)] readonly bool        System.Collections.IEnumerator.MoveNext() => this           .MoveNext();
        [GameMethod(AggressiveInlining)] readonly void        System.Collections.IEnumerator.Reset   () => this           .Reset   ();
        [GameMethod(AggressiveInlining)] readonly void        System.IDisposable.Dispose             () => this           .Dispose ();
      }

      /* … */
      public   static readonly System.Collections.Generic.Dictionary<string, object?>                                                                                                                                                                                               Idle           = new(0);
      internal static          System.Collections.Generic.Dictionary<System.ValueTuple<System.Type, System.Type>, System.ValueTuple<(System.Reflection.MethodInfo, System.Reflection.MethodInfo, System.Reflection.MethodInfo), (sbyte, sbyte, sbyte), (System.Type, System.Type)>> Interpolations = new(3);

      Begin;
      End;
      public /* required */ double                                                                                    delay         = 0.0;
      public /* required */ double                                                                                    duration      = 0.0;
      public                double                                                                                    easedProgress { get { double elapsed = UnityEngine.Time.realtimeSinceStartupAsDouble - this.timestamp; return System.Math.Round(this.delay > elapsed ? (elapsed - this.delay) / this.duration : this.duration <= elapsed - this.delay ? 1.0 : this.easing((elapsed - this.delay) / this.duration), 2, System.MidpointRounding.AwayFromZero); } }
      public /* required */ Game.Tweener                                                                      easing        =  Game.Animation.Function.Linear;
      public /* required */ double                                                                                    elapsed       => (UnityEngine.Time.realtimeSinceStartupAsDouble < this.timestamp) ? 0.0 : (UnityEngine.Time.realtimeSinceStartupAsDouble - this.timestamp);
      public /* required */ Game.Interpolator                                                                 interpolator  =  Util.Lerp<object?>;
      public                bool                                                                                      isFinished    => UnityEngine.Time.realtimeSinceStartupAsDouble >= this.delay + this.duration + this.timestamp;
      public                bool                                                                                      isLooped  { get { double duration = this.delay + this.duration; if (0.0 != duration) { if (UnityEngine.Time.realtimeSinceStartupAsDouble > duration + this.timestamp) { this.timestamp += duration * (1uL + (ulong) ((UnityEngine.Time.realtimeSinceStartupAsDouble - (duration + this.timestamp)) / duration)); return true; } return false; } return true; } }
      private               System.Collections.Generic.SortedList<double, Game.Collections.Keyframe> keyframes = new(1);
      public                uint                                                                                      loopCount { get { double duration = this.delay + this.duration; return 0.0 != duration ? UnityEngine.Time.realtimeSinceStartupAsDouble > duration + this.timestamp ? (uint) ((UnityEngine.Time.realtimeSinceStartupAsDouble - (duration + this.timestamp)) / duration) : 0u : uint.MaxValue; } }
      public                double                                                                                    progress                                                                                                       => System.Math.Min(System.Math.Round(((UnityEngine.Time.realtimeSinceStartupAsDouble - this.timestamp) - this.delay) / this.duration, 2, System.MidpointRounding.AwayFromZero), 1.0);
      public                double                                                                                    timestamp                                                                                                      =  0.0;
      int                                                                                                             System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<string, object?>>.Count => ((int) base.Count);
      System.Collections.Generic.IEnumerable<string>                                                                  System.Collections.Generic.IReadOnlyDictionary<string, object?>.Keys                                           => new Game.Collections.Keyframe.KeyEnumerable(this);
      System.Collections.Generic.IEnumerable<object?>                                                                 System.Collections.Generic.IReadOnlyDictionary<string, object?>.Values                                         => new Timeframe.ValueCollection(this);
      int                                                                                                             System.Collections.ICollection.Count                                                                           => ((int) base.Count);
      bool                                                                                                            System.Collections.ICollection.IsSynchronized                                                                  => false;
      object                                                                                                          System.Collections.ICollection.SyncRoot                                                                        => this;
      bool                                                                                                            System.Collections.IDictionary.IsFixedSize                                                                     => false;
      bool                                                                                                            System.Collections.IDictionary.IsReadOnly                                                                      => false;
      System.Collections.ICollection                                                                                  System.Collections.IDictionary.Keys                                                                            => base.Keys;
      System.Collections.ICollection                                                                                  System.Collections.IDictionary.Values                                                                          => new Timeframe.ValueCollection(this);

      /* … ->> `𝑓 Timeframe([optional] name, duration, [optional] delay, [optional] easing, [optional] interpolator, begin, end) { … }` */
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe()                                                                                                                                                                                                                                                            : base(null!, new System.Collections.Generic.Dictionary<string, object?>(), new System.Collections.Generic.Dictionary<string, object?>())                                                              {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration,                                                                                    System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(null!, duration, 0.0,   null!,  null!,        begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration,                                                                                    System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(null!, duration, 0.0,   null!,  null!,        begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration, double delay,                                                                      System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(null!, duration, delay, null!,  null!,        begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration, double delay,                                                                      System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(null!, duration, delay, null!,  null!,        begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration,               Game.Tweener easing,                                         System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(null!, duration, 0.0,   easing, null!,        begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration,               Game.Tweener easing,                                         System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(null!, duration, 0.0,   easing, null!,        begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration, double delay, Game.Tweener easing,                                         System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(null!, duration, delay, easing, null!,        begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration, double delay, Game.Tweener easing,                                         System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(null!, duration, delay, easing, null!,        begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration,                                            Game.Interpolator interpolator, System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(null!, duration, 0.0,   null!,  interpolator, begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration,                                            Game.Interpolator interpolator, System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(null!, duration, 0.0,   null!,  interpolator, begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration, double delay,                              Game.Interpolator interpolator, System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(null!, duration, delay, null!,  interpolator, begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration, double delay,                              Game.Interpolator interpolator, System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(null!, duration, delay, null!,  interpolator, begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration,               Game.Tweener easing, Game.Interpolator interpolator, System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(null!, duration, 0.0,   easing, interpolator, begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration,               Game.Tweener easing, Game.Interpolator interpolator, System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(null!, duration, 0.0,   easing, interpolator, begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration, double delay, Game.Tweener easing, Game.Interpolator interpolator, System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(null!, duration, delay, easing, interpolator, begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe             (double duration, double delay, Game.Tweener easing, Game.Interpolator interpolator, System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(null!, duration, delay, easing, interpolator, begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration,                                                                                    System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(name,  duration, 0.0,   null!,  null!,        begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration,                                                                                    System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(name,  duration, 0.0,   null!,  null!,        begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration, double delay,                                                                      System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(name,  duration, delay, null!,  null!,        begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration, double delay,                                                                      System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(name,  duration, delay, null!,  null!,        begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration,               Game.Tweener easing,                                         System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(name,  duration, 0.0,   easing, null!,        begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration,               Game.Tweener easing,                                         System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(name,  duration, 0.0,   easing, null!,        begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration, double delay, Game.Tweener easing,                                         System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(name,  duration, delay, easing, null!,        begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration, double delay, Game.Tweener easing,                                         System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(name,  duration, delay, easing, null!,        begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration,                                            Game.Interpolator interpolator, System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(name,  duration, 0.0,   null!,  interpolator, begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration,                                            Game.Interpolator interpolator, System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(name,  duration, 0.0,   null!,  interpolator, begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration, double delay,                              Game.Interpolator interpolator, System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(name,  duration, delay, null!,  interpolator, begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration, double delay,                              Game.Interpolator interpolator, System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(name,  duration, delay, null!,  interpolator, begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration,               Game.Tweener easing, Game.Interpolator interpolator, System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(name,  duration, 0.0,   easing, interpolator, begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration,               Game.Tweener easing, Game.Interpolator interpolator, System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : this(name,  duration, 0.0,   easing, interpolator, begin,                                                                    end)                                                                    {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration, double delay, Game.Tweener easing, Game.Interpolator interpolator, System.Collections.Generic.Dictionary         <string, object?> begin, System.Collections.Generic.Dictionary         <string, object?> end) : this(name,  duration, delay, easing, interpolator, begin as System.Collections.Generic.IReadOnlyDictionary<string, object?>, end as System.Collections.Generic.IReadOnlyDictionary<string, object?>) {}
      [GameConstructor, GameMethod(AggressiveInlining)] public Timeframe(string name, double duration, double delay, Game.Tweener easing, Game.Interpolator interpolator, System.Collections.Generic.IReadOnlyDictionary<string, object?> begin, System.Collections.Generic.IReadOnlyDictionary<string, object?> end) : base(name,  begin, end)                                                                                                                                                                              { this.delay = delay; this.duration = duration; this.easing = easing ?? this.easing; this.interpolator = interpolator ?? this.interpolator; this.timestamp = 0.0; }

      /* … ->> `𝑓 Add([optional] keyframe, progress, properties) { … }` */
      [GameMethod(AggressiveInlining)] public          void                                                                             Add                                                                                                                        (double progress, System.Collections.Generic.Dictionary         <string, object?> properties) => this.Add($"#{this.keyframes.Count + 1}", progress, properties);
      [GameMethod(AggressiveInlining)] public          void                                                                             Add                                                                                                                        (double progress, System.Collections.Generic.IReadOnlyDictionary<string, object?> properties) => this.Add($"#{this.keyframes.Count + 1}", progress, properties);
      [GameMethod(AggressiveInlining)] public          void                                                                             Add                                                                                                           (string name, double progress, System.Collections.Generic.Dictionary         <string, object?> properties) => this.Add(name,                           progress, properties as System.Collections.Generic.IReadOnlyDictionary<string, object?>);
      [GameMethod(AggressiveInlining)] public          void                                                                             Add                                                                                                           (string name, double progress, System.Collections.Generic.IReadOnlyDictionary<string, object?> properties) { foreach (System.Collections.Generic.KeyValuePair<double, Game.Collections.Keyframe> enumerated in this.keyframes) { if (enumerated.Key == progress || (name is not null && enumerated.Value.name == name)) return; } this.keyframes.Add(progress, new(name, properties)); } // ->> `System.Collections.Generic.SortedList<…>` keeps `::keyframes` sorted
      [GameMethod(AggressiveInlining)] public          Timeframe                                                                AsCopy                                                                                                        ()                                                                                                         { Timeframe sequence = new(this.name!, this.duration, this.delay, this.easing, this.interpolator, new(), new()); sequence.keyframes = new(this.keyframes, this.keyframes.Comparer); foreach (System.Collections.DictionaryEntry property in this.begin!) sequence.begin!.Add(property.Key, property.Value); foreach (System.Collections.DictionaryEntry property in this.end!) sequence.end!.Add(property.Key, property.Value); return sequence; }
      [GameMethod(AggressiveInlining)] public          void                                                                             Finish                                                                                                        ()                                                                                                         => this.timestamp = 0.0;
      [GameMethod(AggressiveInlining)] public          void                                                                             Reset                                                                                                         ()                                                                                                         => this.Reset(UnityEngine.Time.realtimeSinceStartupAsDouble);
      [GameMethod(AggressiveInlining)] public          void                                                                             Reset                                                                                                         (double timestamp)                                                                                         => this.timestamp = timestamp;
      [GameMethod(AggressiveInlining)] public override string?                                                                          ToString                                                                                                      ()                                                                                                         { uint index = 0u; string[] value = new string[base.begin!.Count]; foreach (string property in base.end!.Keys) { value[index++] = $"{property}: {this[property]?.ToString() ?? string.Empty}"; } return $"{(!string.IsNullOrEmpty(this.name) ? this.name + ' ' : string.Empty)}({(this.progress * 100.0).ToString("F2")}%) [{string.Join(", ", value)}]"; }
      [GameMethod(AggressiveInlining)] System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<string, object?>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, object?>>.GetEnumerator()                                                                                                         => new Timeframe.Enumerator(this);
      [GameMethod(AggressiveInlining)] bool                                                                                             System.Collections.Generic.IReadOnlyDictionary<string, object?>.ContainsKey                                   (string       key)                                                                                         => base.Contains(key);
      [GameMethod(AggressiveInlining)] bool                                                                                             System.Collections.Generic.IReadOnlyDictionary<string, object?>.TryGetValue                                   (string       key,   out object? value)                                                                    { if (base.Contains(key)) { value = this[key]; return true; } value = default; return false; }
      [GameMethod(AggressiveInlining)] void                                                                                             System.Collections.ICollection.CopyTo                                                                         (System.Array array, int         index)                                                                    { foreach (System.Collections.Generic.KeyValuePair<string, object?> property in this) array.SetValue(property, index++); }
      [GameMethod(NoInlining)]         void                                                                                             System.Collections.IDictionary.Add                                                                            (object       key,   object?     value)                                                                    => throw new System.NotSupportedException("UI sequence does not support adding entries; Use `Timeframe::Add(…)` method");
      [GameMethod(AggressiveInlining)] void                                                                                             System.Collections.IDictionary.Clear                                                                          ()                                                                                                         => this.keyframes.Clear();
      [GameMethod(AggressiveInlining)] bool                                                                                             System.Collections.IDictionary.Contains                                                                       (object key)                                                                                               => base.Contains(key);
      [GameMethod(AggressiveInlining)] System.Collections.IDictionaryEnumerator                                                         System.Collections.IDictionary.GetEnumerator                                                                  ()                                                                                                         => new Timeframe.Enumerator(this);
      [GameMethod(NoInlining)]         void                                                                                             System.Collections.IDictionary.Remove                                                                         (object key)                                                                                               => throw new System.NotSupportedException("UI sequence does not support removing entries");
      [GameMethod(AggressiveInlining)] System.Collections.IEnumerator                                                                   System.Collections.IEnumerable.GetEnumerator                                                                  ()                                                                                                         => new Timeframe.Enumerator(this);

      public new object? this[string property] { get {
        System.Collections.Specialized.ListDictionary begin = base.begin!;
        System.Collections.Specialized.ListDictionary end   = base.end!;

        // … ->> Simultaneous (un-)boxing is minimally slow 🐢
        if (begin.Contains(property) && end.Contains(property)) {
          double                                                                       elapsed            = UnityEngine.Time.realtimeSinceStartupAsDouble - this.timestamp;
          System.Collections.Generic.IList<Game.Collections.Keyframe> keyframes          = this.keyframes.Values;
          System.Collections.Generic.IList<double>                                     keyframeProgresses = this.keyframes.Keys;
          double                                                                       progress           = (elapsed - this.delay) / this.duration;
          (double begin, double end)                                                   subprogress        = (Util.Perc(0.0), Util.Perc(100.0));

          // …
          for (int index = this.keyframes.Count; 0     != index--; )                     { if (keyframes[index].Contains(property) && keyframeProgresses[index] <= progress) { begin = keyframes[index]; subprogress.begin = keyframeProgresses[index]; break; } }
          for (int index = 0;                    index != this.keyframes.Count; ++index) { if (keyframes[index].Contains(property) && keyframeProgresses[index] >  progress) { end   = keyframes[index]; subprogress.end   = keyframeProgresses[index]; break; } }

          progress = this.delay > elapsed ? 0.0 : this.duration <= elapsed - this.delay ? 1.0 : this.easing((elapsed - this.delay) / this.duration);
          return this.interpolator((progress - subprogress.begin) / (subprogress.end - subprogress.begin), begin[property], end[property]);
        }

        return null;
      } }

      object? System.Collections.Generic.IReadOnlyDictionary<string, object?>.this[string property] => this[property];
      object? System.Collections.IDictionary.this                                 [object property] { get => this[property]; set => this[property] = value; }
    }

    public struct Vector2Bool : Game.Collections.IRefEquatable<Vector2Bool> {
      public readonly static Vector2Bool down  = new(false, true);
      public readonly static Vector2Bool left  = new(true,  false);
      public readonly static Vector2Bool one   = new(true,  true);
      public readonly static Vector2Bool right = new(true,  false);
      public readonly static Vector2Bool up    = new(false, true);
      public readonly static Vector2Bool zero  = new(false, false);

      public bool x = false;
      public bool y = false;

      /* … */
      [GameMethod(AggressiveInlining)] public Vector2Bool()               {}
      [GameMethod(AggressiveInlining)] public Vector2Bool(bool x, bool y) { this.x = x; this.y = y; }

      /* … */
      [GameMethod(AggressiveInlining)] public          readonly bool        Equals                                                            (in Vector2Bool vector)                          => this.x == vector.x && this.y == vector.y;
      [GameMethod(AggressiveInlining)] public override readonly bool        Equals                                                            (object?        value)                           => value is Vector2Bool vector && this.Equals(vector);
      [GameMethod(AggressiveInlining)] public override readonly int         GetHashCode                                                       ()                                               => System.HashCode.Combine(this.x, this.y);
      [GameMethod(AggressiveInlining)] public static            Vector2Bool Max                                                               (in Vector2Bool vectorA, in Vector2Bool vectorB) => new(vectorA.x || vectorB.x, vectorA.y || vectorB.y);
      [GameMethod(AggressiveInlining)] public static            Vector2Bool Min                                                               (in Vector2Bool vectorA, in Vector2Bool vectorB) => new(vectorA.x && vectorB.x, vectorA.y && vectorB.y);
      [GameMethod(AggressiveInlining)] public                   void        Scale                                                             (in Vector2Bool scale)                           => this.Set(scale.x && this.x, scale.y && this.y);
      [GameMethod(AggressiveInlining)] public static            Vector2Bool Scale                                                             (in Vector2Bool vector, in Vector2Bool scale)    => new(scale.x && vector.x, scale.y && vector.y);
      [GameMethod(AggressiveInlining)] public                   void        Set                                                               (bool           x,      bool           y)        { this.x = x; this.y = y; }
      [GameMethod(AggressiveInlining)] public override readonly string?     ToString                                                          ()                                               => $"({this.x.ToString()}, {this.y.ToString()})";
      [GameMethod(AggressiveInlining)] public          readonly string      ToString                                                          (System.IFormatProvider? provider)               => $"({this.x.ToString(provider)}, {this.y.ToString(provider)})";
      [GameMethod(AggressiveInlining)] readonly bool                        Game.Collections.IRefEquatable<Vector2Bool>.Equals        (ref Vector2Bool         vector)                 => this.Equals(in vector);
      [GameMethod(AggressiveInlining)] readonly bool                        Game.Collections.IRefReadOnlyEquatable<Vector2Bool>.Equals(in  Vector2Bool         vector)                 => this.Equals(in vector);
      [GameMethod(AggressiveInlining)] readonly bool                        System.IEquatable<Vector2Bool>.Equals                             (Vector2Bool             vector)                 => this.Equals(vector);

      [GameMethod(AggressiveInlining)] public static bool        operator false(in Vector2Bool vector)                          => !vector.x || !vector.y;
      [GameMethod(AggressiveInlining)] public static bool        operator true (in Vector2Bool vector)                          =>  vector.x &&  vector.y;
      [GameMethod(AggressiveInlining)] public static Vector2Bool operator +    (in Vector2Bool vector)                          =>  vector;
      [GameMethod(AggressiveInlining)] public static Vector2Bool operator -    (in Vector2Bool vector)                          =>  vector;
      [GameMethod(AggressiveInlining)] public static Vector2Bool operator +    (in Vector2Bool vectorA, in Vector2Bool vectorB) =>  new(vectorA.x || vectorB.x,                           vectorA.y || vectorB.y);
      [GameMethod(AggressiveInlining)] public static Vector2Bool operator -    (in Vector2Bool vectorA, in Vector2Bool vectorB) =>  new(0 != ((vectorA.x ? 1 : 0) ^ (vectorB.x ? 1 : 0)), 0 != ((vectorA.y ? 1 : 0) ^ (vectorB.y ? 1 : 0)));
      [GameMethod(AggressiveInlining)] public static Vector2Bool operator *    (in Vector2Bool vector,  bool           boolean) =>  new(boolean   && vector .x,                           boolean   && vector .y);
      [GameMethod(AggressiveInlining)] public static Vector2Bool operator *    (in Vector2Bool vectorA, in Vector2Bool vectorB) =>  new(vectorA.x && vectorB.x,                           vectorA.y && vectorB.y);
      [GameMethod(AggressiveInlining)] public static Vector2Bool operator /    (in Vector2Bool vector,  bool           boolean) =>  new(boolean   && vector .x,                           boolean   && vector .y);
      [GameMethod(AggressiveInlining)] public static bool        operator ==   (in Vector2Bool vectorA, in Vector2Bool vectorB) =>  vectorA.Equals(in vectorB);
      [GameMethod(AggressiveInlining)] public static bool        operator !=   (in Vector2Bool vectorA, in Vector2Bool vectorB) => !vectorA.Equals(in vectorB);

      [GameMethod(AggressiveInlining)] public static implicit operator bool                                (in Vector2Bool                          vector) => vector.x && vector.y;
      [GameMethod(AggressiveInlining)] public static explicit operator Game.Collections.Vector3Bool(in Vector2Bool                          vector) => new(vector.x,         vector.y);
      [GameMethod(AggressiveInlining)] public static explicit operator UnityEngine.Vector2Int              (in Vector2Bool                          vector) => new(vector.x ? 1 : 0, vector.y ? 1 : 0);
      [GameMethod(AggressiveInlining)] public static explicit operator Vector2Bool                         (in Game.Collections.Vector3Bool vector) => new(vector.x,         vector.y);

      public bool this[uint index] {
        get { switch (index) { case 0u: return this.x;         case 1u: return this.y;         default: throw new System.IndexOutOfRangeException("Invalid `Vector2Bool` index!"); } }
        set { switch (index) { case 0u: this.x = value; break; case 1u: this.y = value; break; default: throw new System.IndexOutOfRangeException("Invalid `Vector2Bool` index!"); } }
      }
    }

    public struct Vector3Bool : Game.Collections.IRefEquatable<Vector3Bool> {
      public readonly static Vector3Bool back    = new(false, false, true);
      public readonly static Vector3Bool down    = new(false, true,  false);
      public readonly static Vector3Bool forward = new(false, false, true);
      public readonly static Vector3Bool left    = new(true,  false, false);
      public readonly static Vector3Bool one     = new(true,  true,  true);
      public readonly static Vector3Bool right   = new(true,  false, false);
      public readonly static Vector3Bool up      = new(false, true,  false);
      public readonly static Vector3Bool zero    = new(false, false, false);

      public bool x = false;
      public bool y = false;
      public bool z = false;

      /* … */
      [GameMethod(AggressiveInlining)] public Vector3Bool()                       {}
      [GameMethod(AggressiveInlining)] public Vector3Bool(bool x, bool y)         { this.x = x; this.y = y; }
      [GameMethod(AggressiveInlining)] public Vector3Bool(bool x, bool y, bool z) { this.x = x; this.y = y; this.z = z; }


      /* … */
      [GameMethod(AggressiveInlining)] public          readonly bool        Equals                                                            (in Vector3Bool vector)                           => this.x == vector.x && this.y == vector.y && this.z == vector.z;
      [GameMethod(AggressiveInlining)] public override readonly bool        Equals                                                            (object?        value)                            => value is Vector3Bool vector && this.Equals(vector);
      [GameMethod(AggressiveInlining)] public override readonly int         GetHashCode                                                       ()                                                => System.HashCode.Combine(this.x, this.y, this.z);
      [GameMethod(AggressiveInlining)] public static            Vector3Bool Max                                                               (in Vector3Bool vectorA, in Vector3Bool vectorB)  => new(vectorA.x || vectorB.x, vectorA.y || vectorB.y, vectorA.z || vectorB.z);
      [GameMethod(AggressiveInlining)] public static            Vector3Bool Min                                                               (in Vector3Bool vectorA, in Vector3Bool vectorB)  => new(vectorA.x && vectorB.x, vectorA.y && vectorB.y, vectorA.z && vectorB.z);
      [GameMethod(AggressiveInlining)] public                   void        Scale                                                             (in Vector3Bool scale)                            => this.Set(scale.x && this.x, scale.y && this.y, scale.z && this.z);
      [GameMethod(AggressiveInlining)] public static            Vector3Bool Scale                                                             (in Vector3Bool vector, in Vector3Bool scale)     => new(scale.x && vector.x, scale.y && vector.y, scale.z && vector.z);
      [GameMethod(AggressiveInlining)] public                   void        Set                                                               (bool           x,      bool           y, bool z) { this.x = x; this.y = y; this.z = z; }
      [GameMethod(AggressiveInlining)] public override readonly string?     ToString                                                          ()                                                => $"({this.x.ToString()}, {this.y.ToString()}, {this.z.ToString()})";
      [GameMethod(AggressiveInlining)] public          readonly string      ToString                                                          (System.IFormatProvider? provider)                => $"({this.x.ToString(provider)}, {this.y.ToString(provider)}, {this.z.ToString(provider)})";
      [GameMethod(AggressiveInlining)] readonly bool                        Game.Collections.IRefEquatable<Vector3Bool>.Equals        (ref Vector3Bool         vector)                  => this.Equals(in vector);
      [GameMethod(AggressiveInlining)] readonly bool                        Game.Collections.IRefReadOnlyEquatable<Vector3Bool>.Equals(in  Vector3Bool         vector)                  => this.Equals(in vector);
      [GameMethod(AggressiveInlining)] readonly bool                        System.IEquatable<Vector3Bool>.Equals                             (Vector3Bool             vector)                  => this.Equals(vector);

      [GameMethod(AggressiveInlining)] public static bool        operator false(in Vector3Bool vector)                          => !vector.x || !vector.y || !vector.z;
      [GameMethod(AggressiveInlining)] public static bool        operator true (in Vector3Bool vector)                          =>  vector.x &&  vector.y &&  vector.z;
      [GameMethod(AggressiveInlining)] public static Vector3Bool operator +    (in Vector3Bool vector)                          =>  vector;
      [GameMethod(AggressiveInlining)] public static Vector3Bool operator -    (in Vector3Bool vector)                          =>  vector;
      [GameMethod(AggressiveInlining)] public static Vector3Bool operator +    (in Vector3Bool vectorA, in Vector3Bool vectorB) =>  new(vectorA.x || vectorB.x,                           vectorA.y || vectorB.y,                           vectorA.z || vectorB.z);
      [GameMethod(AggressiveInlining)] public static Vector3Bool operator -    (in Vector3Bool vectorA, in Vector3Bool vectorB) =>  new(0 != ((vectorA.x ? 1 : 0) ^ (vectorB.x ? 1 : 0)), 0 != ((vectorA.y ? 1 : 0) ^ (vectorB.y ? 1 : 0)), 0 != ((vectorA.z ? 1 : 0) ^ (vectorB.z ? 1 : 0)));
      [GameMethod(AggressiveInlining)] public static Vector3Bool operator *    (in Vector3Bool vector,  bool           boolean) =>  new(boolean   && vector .x,                           boolean   && vector .y,                           boolean   && vector .z);
      [GameMethod(AggressiveInlining)] public static Vector3Bool operator *    (in Vector3Bool vectorA, in Vector3Bool vectorB) =>  new(vectorA.x && vectorB.x,                           vectorA.y && vectorB.y,                           vectorA.z && vectorB.z);
      [GameMethod(AggressiveInlining)] public static Vector3Bool operator /    (in Vector3Bool vector,  bool           boolean) =>  new(boolean   && vector .x,                           boolean   && vector .y,                           boolean   && vector .z);
      [GameMethod(AggressiveInlining)] public static bool        operator ==   (in Vector3Bool vectorA, in Vector3Bool vectorB) =>  vectorA.Equals(in vectorB);
      [GameMethod(AggressiveInlining)] public static bool        operator !=   (in Vector3Bool vectorA, in Vector3Bool vectorB) => !vectorA.Equals(in vectorB);

      [GameMethod(AggressiveInlining)] public static implicit operator bool                  (in Vector3Bool vector) => vector.x && vector.y && vector.z;
      [GameMethod(AggressiveInlining)] public static explicit operator UnityEngine.Vector3Int(in Vector3Bool vector) => new(vector.x ? 1 : 0, vector.y ? 1 : 0, vector.z ? 1 : 0);

      public bool this[uint index] {
        get { switch (index) { case 0u: return this.x;         case 1u: return this.y;         case 2u: return this.z;         default: throw new System.IndexOutOfRangeException("Invalid `Vector3Bool` index!"); } }
        set { switch (index) { case 0u: this.x = value; break; case 1u: this.y = value; break; case 2u: this.z = value; break; default: throw new System.IndexOutOfRangeException("Invalid `Vector3Bool` index!"); } }
      }
    }

    public struct Vector4Bool : Game.Collections.IRefEquatable<Vector4Bool> {
      public readonly static Vector4Bool back    = new(false, false, true,  false);
      public readonly static Vector4Bool down    = new(false, true,  false, false);
      public readonly static Vector4Bool forward = new(false, false, true,  false);
      public readonly static Vector4Bool left    = new(true,  false, false, false);
      public readonly static Vector4Bool one     = new(true,  true,  true,  false);
      public readonly static Vector4Bool right   = new(true,  false, false, false);
      public readonly static Vector4Bool up      = new(false, true,  false, false);
      public readonly static Vector4Bool zero    = new(false, false, false, false);

      public bool x = false;
      public bool y = false;
      public bool z = false;
      public bool w = false;

      /* … */
      [GameMethod(AggressiveInlining)] public Vector4Bool()                               {}
      [GameMethod(AggressiveInlining)] public Vector4Bool(bool x, bool y)                 { this.x = x; this.y = y; }
      [GameMethod(AggressiveInlining)] public Vector4Bool(bool x, bool y, bool z)         { this.x = x; this.y = y; this.z = z; }
      [GameMethod(AggressiveInlining)] public Vector4Bool(bool x, bool y, bool z, bool w) { this.x = x; this.y = y; this.z = z; this.w = w; }


      /* … */
      [GameMethod(AggressiveInlining)] public          readonly bool        Equals                                                            (in Vector4Bool vector)                                   => this.x == vector.x && this.y == vector.y && this.z == vector.z && this.w == vector.w;
      [GameMethod(AggressiveInlining)] public override readonly bool        Equals                                                            (object?        value)                                    => value is Vector4Bool vector && this.Equals(vector);
      [GameMethod(AggressiveInlining)] public override readonly int         GetHashCode                                                       ()                                                        => System.HashCode.Combine(this.x, this.y, this.z, this.w);
      [GameMethod(AggressiveInlining)] public static            Vector4Bool Max                                                               (in Vector4Bool vectorA, in Vector4Bool vectorB)          => new(vectorA.x || vectorB.x, vectorA.y || vectorB.y, vectorA.z || vectorB.z, vectorA.w || vectorB.w);
      [GameMethod(AggressiveInlining)] public static            Vector4Bool Min                                                               (in Vector4Bool vectorA, in Vector4Bool vectorB)          => new(vectorA.x && vectorB.x, vectorA.y && vectorB.y, vectorA.z && vectorB.z, vectorA.w && vectorB.w);
      [GameMethod(AggressiveInlining)] public                   void        Scale                                                             (in Vector4Bool scale)                                    => this.Set(scale.x && this.x, scale.y && this.y, scale.z && this.z, scale.w && this.w);
      [GameMethod(AggressiveInlining)] public static            Vector4Bool Scale                                                             (in Vector4Bool vector, in Vector4Bool scale)             => new(scale.x && vector.x, scale.y && vector.y, scale.z && vector.z, scale.w && vector.w);
      [GameMethod(AggressiveInlining)] public                   void        Set                                                               (bool           x,      bool           y, bool z, bool w) { this.x = x; this.y = y; this.z = z; this.w = w; }
      [GameMethod(AggressiveInlining)] public override readonly string?     ToString                                                          ()                                                        => $"({this.x.ToString()}, {this.y.ToString()}, {this.z.ToString()}, {this.w.ToString()})";
      [GameMethod(AggressiveInlining)] public          readonly string      ToString                                                          (System.IFormatProvider? provider)                        => $"({this.x.ToString(provider)}, {this.y.ToString(provider)}, {this.z.ToString(provider)}, {this.w.ToString(provider)})";
      [GameMethod(AggressiveInlining)] readonly bool                        Game.Collections.IRefEquatable<Vector4Bool>.Equals        (ref Vector4Bool         vector)                          => this.Equals(in vector);
      [GameMethod(AggressiveInlining)] readonly bool                        Game.Collections.IRefReadOnlyEquatable<Vector4Bool>.Equals(in  Vector4Bool         vector)                          => this.Equals(in vector);
      [GameMethod(AggressiveInlining)] readonly bool                        System.IEquatable<Vector4Bool>.Equals                             (Vector4Bool             vector)                          => this.Equals(vector);

      [GameMethod(AggressiveInlining)] public static bool        operator false(in Vector4Bool vector)                          => !vector.x || !vector.y || !vector.z || !vector.w;
      [GameMethod(AggressiveInlining)] public static bool        operator true (in Vector4Bool vector)                          =>  vector.x &&  vector.y &&  vector.z &&  vector.w;
      [GameMethod(AggressiveInlining)] public static Vector4Bool operator +    (in Vector4Bool vector)                          =>  vector;
      [GameMethod(AggressiveInlining)] public static Vector4Bool operator -    (in Vector4Bool vector)                          =>  vector;
      [GameMethod(AggressiveInlining)] public static Vector4Bool operator +    (in Vector4Bool vectorA, in Vector4Bool vectorB) =>  new(vectorA.x || vectorB.x,                           vectorA.y || vectorB.y,                           vectorA.z || vectorB.z,                           vectorA.w || vectorB.w);
      [GameMethod(AggressiveInlining)] public static Vector4Bool operator -    (in Vector4Bool vectorA, in Vector4Bool vectorB) =>  new(0 != ((vectorA.x ? 1 : 0) ^ (vectorB.x ? 1 : 0)), 0 != ((vectorA.y ? 1 : 0) ^ (vectorB.y ? 1 : 0)), 0 != ((vectorA.z ? 1 : 0) ^ (vectorB.z ? 1 : 0)), 0 != ((vectorA.w ? 1 : 0) ^ (vectorB.w ? 1 : 0)));
      [GameMethod(AggressiveInlining)] public static Vector4Bool operator *    (in Vector4Bool vector,  bool           boolean) =>  new(boolean   && vector .x,                           boolean   && vector .y,                           boolean   && vector .z,                           boolean   && vector .z);
      [GameMethod(AggressiveInlining)] public static Vector4Bool operator *    (in Vector4Bool vectorA, in Vector4Bool vectorB) =>  new(vectorA.x && vectorB.x,                           vectorA.y && vectorB.y,                           vectorA.z && vectorB.z,                           vectorA.w && vectorB.w);
      [GameMethod(AggressiveInlining)] public static Vector4Bool operator /    (in Vector4Bool vector,  bool           boolean) =>  new(boolean   && vector .x,                           boolean   && vector .y,                           boolean   && vector .z,                           boolean   && vector .w);
      [GameMethod(AggressiveInlining)] public static bool        operator ==   (in Vector4Bool vectorA, in Vector4Bool vectorB) =>  vectorA.Equals(in vectorB);
      [GameMethod(AggressiveInlining)] public static bool        operator !=   (in Vector4Bool vectorA, in Vector4Bool vectorB) => !vectorA.Equals(in vectorB);

      [GameMethod(AggressiveInlining)] public static implicit operator bool                                (in Vector4Bool                          vector) => vector.x && vector.y && vector.z && vector.w;
      [GameMethod(AggressiveInlining)] public static explicit operator Game.Collections.Vector2Bool(in Vector4Bool                          vector) => new(vector.x, vector.y);
      [GameMethod(AggressiveInlining)] public static explicit operator Game.Collections.Vector3Bool(in Vector4Bool                          vector) => new(vector.x, vector.y, vector.z);
      [GameMethod(AggressiveInlining)] public static explicit operator Vector4Bool                         (in Game.Collections.Vector2Bool vector) => new(vector.x, vector.y);
      [GameMethod(AggressiveInlining)] public static explicit operator Vector4Bool                         (in Game.Collections.Vector3Bool vector) => new(vector.x, vector.y, vector.z);

      public bool this[uint index] {
        get { switch (index) { case 0u: return this.x;         case 1u: return this.y;         case 2u: return this.z;         case 3u: return this.w;         default: throw new System.IndexOutOfRangeException("Invalid `Vector4Bool` index!"); } }
        set { switch (index) { case 0u: this.x = value; break; case 1u: this.y = value; break; case 2u: this.z = value; break; case 3u: this.w = value; break; default: throw new System.IndexOutOfRangeException("Invalid `Vector4Bool` index!"); } }
      }
    }

    internal /* readonly */ struct WaitInfo : Game.Collections.IRefEquatable<WaitInfo> /* ->> Considered `UnityEngine.MonoBehaviour::Invoke[Repeating](nameof(𝑓) or ((System.Delegate) 𝑓).Method.Name, delay[, interval])` */ {
      internal readonly       UnityEngine.Coroutine?                                               coroutine = null;
      internal /* readonly */ Game.Collections.EventHandler<Game.Events.WaitEvent> events    = new(); // ->> Information actually stored within its `::WaitEvent`s

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)] public   WaitInfo()                                {}
      [GameConstructor, GameMethod(AggressiveInlining)] internal WaitInfo(UnityEngine.Coroutine coroutine) => this.coroutine = coroutine;

      /* … */
      [GameMethod(AggressiveInlining)] public          readonly bool Equals                                                         (in  WaitInfo wait)  => wait.events == this.events;
      [GameMethod(AggressiveInlining)] public override readonly bool Equals                                                         (object?      value) => value is WaitInfo wait && this.Equals(wait);
      [GameMethod(AggressiveInlining)] public override readonly int  GetHashCode                                                    ()                   => this.events.GetHashCode();
      [GameMethod(AggressiveInlining)] readonly bool                 Game.Collections.IRefEquatable<WaitInfo>.Equals        (ref WaitInfo wait)  => this.Equals(in wait);
      [GameMethod(AggressiveInlining)] readonly bool                 Game.Collections.IRefReadOnlyEquatable<WaitInfo>.Equals(in  WaitInfo wait)  => this.Equals(in wait);
      [GameMethod(AggressiveInlining)] readonly bool                 System.IEquatable<WaitInfo>.Equals                             (WaitInfo     wait)  => this.Equals(wait);
    }

    #if UNITY_EDITOR
      [UnityEditor.CustomPropertyDrawer(typeof(Game.ReadOnlyInInspectorAttribute))]
      public class ReadOnlyInInspectorDrawer : UnityEditor.PropertyDrawer {
        [GameMethod(AggressiveInlining)]
        public override float GetPropertyHeight(UnityEditor.SerializedProperty property, UnityEngine.GUIContent label) => UnityEditor.EditorGUI.GetPropertyHeight(property, label, true);

        [GameMethod(AggressiveInlining)]
        public override void OnGUI(UnityEngine.Rect position, UnityEditor.SerializedProperty property, UnityEngine.GUIContent label) {
          // bool isJobReadOnly = property.serializedObject.targetObject.GetType().GetField(property.name)?.IsDefined(typeof(Unity.Collections.ReadOnlyAttribute), true) ?? false;

          // …
          UnityEngine.GUI.enabled = false;

          using (new UnityEditor.EditorGUI.DisabledScope(true)) // ->> Should have been sufficient on its own
            UnityEditor.EditorGUI.PropertyField(position, property, label, true);

          UnityEngine.GUI.enabled = true;
        }
      }

      public class RefDictionaryDrawer<TKey, TValue> : UnityEditor.PropertyDrawer {
        private static readonly Game.GUIField? ValueGUIField = Util.UI.DelegateGUIField<TValue>();
        private static readonly Game.GUIField? KeyGUIField   = Util.UI.DelegateGUIField<TKey>  ();
        private static readonly bool                   IsDrawable    = RefDictionaryDrawer<TKey, TValue>.KeyGUIField is not null && RefDictionaryDrawer<TKey, TValue>.ValueGUIField is not null;

        private bool foldout = true;

        /* … */
        [GameMethod(AggressiveInlining)]
        private System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> Ensure(ref UnityEditor.SerializedProperty property) {
          System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> enumerable = this.fieldInfo.GetValue(property.serializedObject.targetObject) switch {
            System.Collections.Generic.IDictionary        <TKey, TValue> dictionary => dictionary,
            System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> dictionary => dictionary,
            _                                                               => Game.Collections.RefReadOnlyDictionary<TKey, TValue>.Empty
          };

          this.fieldInfo.SetValue(property.serializedObject.targetObject, enumerable);
          return enumerable;
        }

        [GameMethod(AggressiveInlining)]
        public override float GetPropertyHeight(UnityEditor.SerializedProperty property, UnityEngine.GUIContent label) => base.GetPropertyHeight(property, label) * (RefDictionaryDrawer<TKey, TValue>.IsDrawable && (this.foldout || UnityEditor.EditorPrefs.GetBool(label.text)) ? System.Math.Max(Util.Enumerable.Count(this.Ensure(ref property)), 1) + 1 : 1);

        [GameMethod(AggressiveInlining)]
        public override void OnGUI(UnityEngine.Rect position, UnityEditor.SerializedProperty property, UnityEngine.GUIContent label) {
          UnityEngine.Color                                                                             color      = default;
          System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> enumerable = this.Ensure(ref property);
          System.Collections.Generic.IDictionary<TKey, TValue>?                                         dictionary = enumerable as System.Collections.Generic.IDictionary<TKey, TValue>;
          bool                                                                                          immutable  = dictionary?.IsReadOnly ?? true;
          float                                                                                         size       = position.height = base.GetPropertyHeight(property, label);
          (UnityEngine.Rect add, UnityEngine.Rect clear, UnityEngine.Rect foldout)                      positions  = (
            add    : new(position.x + (position.width - Util.PercOf(size, 200.0f)), position.y, size,                                       position.height),
            clear  : new(position.x + (position.width - Util.PercOf(size, 100.0f)), position.y, size,                                       position.height),
            foldout: new(position.x,                                                position.y, position.width - Util.PercOf(size, 200.0f), position.height)
          );

          // …
          if ((!RefDictionaryDrawer<TKey, TValue>.IsDrawable)) {
            base.OnGUI(position, property, label);
            return;
          }

          UnityEditor.EditorGUI.BeginChangeCheck();
            color                 = UnityEngine.GUI.color;
            UnityEngine.GUI.color = new(UnityEngine.GUI.color.r, UnityEngine.GUI.color.g, UnityEngine.GUI.color.b, UnityEngine.GUI.color.a * 0.5f);
            UnityEngine.GUI.Label(positions.foldout, new string('＿', label.text.Length) + (!string.IsNullOrEmpty(label.text.Trim()) ? " " : string.Empty) + $"({Util.Enumerable.Count(enumerable).ToString()})");
            UnityEngine.GUI.color = color;

            this.foldout = UnityEditor.EditorPrefs.GetBool(label.text);
            this.foldout = UnityEditor.EditorGUI.  Foldout(positions.foldout, this.foldout, label, true);
          if (UnityEditor.EditorGUI.EndChangeCheck()) UnityEditor.EditorPrefs.SetBool(label.text, this.foldout);

          if (!immutable) {
            if (UnityEngine.GUI.Button(positions.add, new UnityEngine.GUIContent("+", "Add field"), UnityEditor.EditorStyles.miniButton)) {
              dictionary!.TryAdd(typeof(TKey) == typeof(string) ? (TKey) (object) string.Empty : System.Activator.CreateInstance<TKey>(), typeof(TValue) == typeof(string) ? (TValue) (object) string.Empty : Traits.IsValueType<TValue>() ? System.Activator.CreateInstance<TValue>() : (TValue) (null as object)!);
              Util.Game.AskToSave();
            }

            if (UnityEngine.GUI.Button(positions.clear, new UnityEngine.GUIContent("×", "Clear dictionary"), UnityEditor.EditorStyles.miniButtonRight)) {
              dictionary!.Clear();
              Util.Game.AskToSave();
            }
          }

          if (this.foldout) {
            if (enumerable.IsEmpty()) {
              color                 = UnityEngine.GUI.color;
              UnityEngine.GUI.color = new(UnityEngine.GUI.color.r, UnityEngine.GUI.color.g, UnityEngine.GUI.color.b, UnityEngine.GUI.color.a * 0.5f);
              UnityEngine.GUI.Label(new(position.x, position.y + position.height, position.width, position.height), "Dictionary is empty");
              UnityEngine.GUI.color = color;

              return;
            }

            foreach (System.Collections.Generic.KeyValuePair<TKey, TValue> element in enumerable)
            if (element.Key is not null) {
              (TKey key, TValue value)                                                            = (element.Key, element.Value);
              string                                                                 formattedKey = typeof(TKey) == typeof(string) ? System.Globalization.CultureInfo.InvariantCulture.TextInfo.ToTitleCase(key.ToString()) : key.ToString();
              (UnityEngine.Rect key, UnityEngine.Rect value, UnityEngine.Rect clear) subpositions = (
                key  : new(position.x + Util.PercOf(position.width - size,   2.0f) + (immutable ? size : 0.0f), position.y += position.height, Util.PercOf(position.width - size, 38.0f), position.height),
                value: new(position.x + Util.PercOf(position.width - size,  40.0f) + (immutable ? size : 0.0f), position.y,                    Util.PercOf(position.width - size, 60.0f), position.height),
                clear: new(position.x + Util.PercOf(position.width - size, 100.0f),                             position.y,                    size,                                      position.height)
              );

              // …
              if (immutable || typeof(TKey) == typeof(string)) UnityEngine.GUI.Label(subpositions.key, formattedKey);
              else {
                UnityEditor.EditorGUI.BeginChangeCheck();
                  key = (TKey) RefDictionaryDrawer<TKey, TValue>.KeyGUIField!(subpositions.key, key);
                if (UnityEditor.EditorGUI.EndChangeCheck()) {
                  dictionary!.Remove(element.Key);
                  dictionary!.Add   (key, value);

                  Util.Game.AskToSave();
                  break;
                }
              }

              UnityEditor.EditorGUI.BeginChangeCheck();
                value = (TValue) RefDictionaryDrawer<TKey, TValue>.ValueGUIField!(subpositions.value, value!);
              if (UnityEditor.EditorGUI.EndChangeCheck()) {
                switch (enumerable) {
                  case Game.Collections.RefReadOnlyDictionary<TKey, TValue> subdictionary: subdictionary.SetValue(value, subdictionary.GetValue(key)); break;
                  default:                                                                         dictionary![key] = value;                                   break;
                }

                Util.Game.AskToSave();
                break;
              }

              if (!immutable)
              if (UnityEngine.GUI.Button(subpositions.clear, new UnityEngine.GUIContent("-", "Clear item"), UnityEditor.EditorStyles.miniButtonRight)) {
                dictionary!.Remove(key);

                Util.Game.AskToSave();
                break;
              }
            }
          }
        }
      }
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.AnimationCurveDictionary))]         public class AnimationCurveDictionaryDrawer         : Game.Collections.RefDictionaryDrawer<string, UnityEngine.AnimationCurve> {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.AnimationCurveReadOnlyDictionary))] public class AnimationCurveReadOnlyDictionaryDrawer : Game.Collections.RefDictionaryDrawer<string, UnityEngine.AnimationCurve> {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.BooleanDictionary))]                public class BooleanDictionaryDrawer                : Game.Collections.RefDictionaryDrawer<string, System     .Boolean>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.BooleanReadOnlyDictionary))]        public class BooleanReadOnlyDictionaryDrawer        : Game.Collections.RefDictionaryDrawer<string, System     .Boolean>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.BoundsDictionary))]                 public class BoundsDictionaryDrawer                 : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Bounds>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.BoundsReadOnlyDictionary))]         public class BoundsReadOnlyDictionaryDrawer         : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Bounds>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.BoundsIntDictionary))]              public class BoundsIntDictionaryDrawer              : Game.Collections.RefDictionaryDrawer<string, UnityEngine.BoundsInt>      {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.BoundsIntReadOnlyDictionary))]      public class BoundsIntReadOnlyDictionaryDrawer      : Game.Collections.RefDictionaryDrawer<string, UnityEngine.BoundsInt>      {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.CanvasRendererDictionary))]         public class CanvasRendererDictionaryDrawer         : Game.Collections.RefDictionaryDrawer<string, UnityEngine.CanvasRenderer> {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.CanvasRendererReadOnlyDictionary))] public class CanvasRendererReadOnlyDictionaryDrawer : Game.Collections.RefDictionaryDrawer<string, UnityEngine.CanvasRenderer> {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.ColorDictionary))]                  public class ColorDictionaryDrawer                  : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Color>          {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.ColorReadOnlyDictionary))]          public class ColorReadOnlyDictionaryDrawer          : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Color>          {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.DoubleDictionary))]                 public class DoubleDictionaryDrawer                 : Game.Collections.RefDictionaryDrawer<string, System     .Double>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.DoubleReadOnlyDictionary))]         public class DoubleReadOnlyDictionaryDrawer         : Game.Collections.RefDictionaryDrawer<string, System     .Double>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.FloatDictionary))]                  public class FloatDictionaryDrawer                  : Game.Collections.RefDictionaryDrawer<string, System     .Single>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.FloatReadOnlyDictionary))]          public class FloatReadOnlyDictionaryDrawer          : Game.Collections.RefDictionaryDrawer<string, System     .Single>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.GameObjectDictionary))]             public class GameObjectDictionaryDrawer             : Game.Collections.RefDictionaryDrawer<string, UnityEngine.GameObject>     {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.GameObjectReadOnlyDictionary))]     public class GameObjectReadOnlyDictionaryDrawer     : Game.Collections.RefDictionaryDrawer<string, UnityEngine.GameObject>     {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.GradientDictionary))]               public class GradientDictionaryDrawer               : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Gradient>       {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.GradientReadOnlyDictionary))]       public class GradientReadOnlyDictionaryDrawer       : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Gradient>       {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.IntDictionary))]                    public class IntDictionaryDrawer                    : Game.Collections.RefDictionaryDrawer<string, System     .Int32>          {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.IntReadOnlyDictionary))]            public class IntReadOnlyDictionaryDrawer            : Game.Collections.RefDictionaryDrawer<string, System     .Int32>          {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.LongDictionary))]                   public class LongDictionaryDrawer                   : Game.Collections.RefDictionaryDrawer<string, System     .Int64>          {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.LongReadOnlyDictionary))]           public class LongReadOnlyDictionaryDrawer           : Game.Collections.RefDictionaryDrawer<string, System     .Int64>          {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.RectDictionary))]                   public class RectDictionaryDrawer                   : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Rect>           {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.RectReadOnlyDictionary))]           public class RectReadOnlyDictionaryDrawer           : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Rect>           {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.RectIntDictionary))]                public class RectIntDictionaryDrawer                : Game.Collections.RefDictionaryDrawer<string, UnityEngine.RectInt>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.RectIntReadOnlyDictionary))]        public class RectIntReadOnlyDictionaryDrawer        : Game.Collections.RefDictionaryDrawer<string, UnityEngine.RectInt>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.StringDictionary))]                 public class StringDictionaryDrawer                 : Game.Collections.RefDictionaryDrawer<string, System     .String>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.StringReadOnlyDictionary))]         public class StringReadOnlyDictionaryDrawer         : Game.Collections.RefDictionaryDrawer<string, System     .String>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.UIntDictionary))]                   public class UIntDictionaryDrawer                   : Game.Collections.RefDictionaryDrawer<string, System     .UInt32>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.UIntReadOnlyDictionary))]           public class UIntReadOnlyDictionaryDrawer           : Game.Collections.RefDictionaryDrawer<string, System     .UInt32>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.ULongDictionary))]                  public class ULongDictionaryDrawer                  : Game.Collections.RefDictionaryDrawer<string, System     .UInt64>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.ULongReadOnlyDictionary))]          public class ULongReadOnlyDictionaryDrawer          : Game.Collections.RefDictionaryDrawer<string, System     .UInt64>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector2Dictionary))]                public class Vector2DictionaryDrawer                : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Vector2>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector2ReadOnlyDictionary))]        public class Vector2ReadOnlyDictionaryDrawer        : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Vector2>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector2IntDictionary))]             public class Vector2IntDictionaryDrawer             : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Vector2Int>     {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector2IntReadOnlyDictionary))]     public class Vector2IntReadOnlyDictionaryDrawer     : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Vector2Int>     {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector3Dictionary))]                public class Vector3DictionaryDrawer                : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Vector3>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector3ReadOnlyDictionary))]        public class Vector3ReadOnlyDictionaryDrawer        : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Vector3>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector3IntDictionary))]             public class Vector3IntDictionaryDrawer             : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Vector3Int>     {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector3IntReadOnlyDictionary))]     public class Vector3IntReadOnlyDictionaryDrawer     : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Vector3Int>     {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector4Dictionary))]                public class Vector4DictionaryDrawer                : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Vector4>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector4ReadOnlyDictionary))]        public class Vector4ReadOnlyDictionaryDrawer        : Game.Collections.RefDictionaryDrawer<string, UnityEngine.Vector4>        {}

      public class RefListDrawer<T> : UnityEditor.PropertyDrawer {
        private static readonly Game.GUIField? GUIField   = Util.UI.DelegateGUIField<T>();
        private static readonly bool                   IsDrawable = RefListDrawer<T>.GUIField is not null;

        private bool foldout = true;

        /* … */
        [GameMethod(AggressiveInlining)]
        private System.Collections.Generic.IEnumerable<T> Ensure(ref UnityEditor.SerializedProperty property) {
          System.Collections.Generic.IEnumerable<T> enumerable = this.fieldInfo.GetValue(property.serializedObject.targetObject) switch {
            System.Collections.Generic.IList        <T> list => list,
            System.Collections.Generic.IReadOnlyList<T> list => list,
            _                                                => Game.Collections.RefReadOnlyList<T>.Empty
          };

          this.fieldInfo.SetValue(property.serializedObject.targetObject, enumerable);
          return enumerable;
        }

        [GameMethod(AggressiveInlining)]
        public override float GetPropertyHeight(UnityEditor.SerializedProperty property, UnityEngine.GUIContent label) => base.GetPropertyHeight(property, label) * (RefListDrawer<T>.IsDrawable && (this.foldout || UnityEditor.EditorPrefs.GetBool(label.text)) ? System.Math.Max(Util.Enumerable.Count(this.Ensure(ref property)), 1) + 1 : 1);

        [GameMethod(AggressiveInlining)]
        public override void OnGUI(UnityEngine.Rect position, UnityEditor.SerializedProperty property, UnityEngine.GUIContent label) {
          UnityEngine.Color                                                        color      = default;
          System.Collections.Generic.IEnumerable<T>                                enumerable = this.Ensure(ref property);
          System.Collections.Generic.IList      <T>?                               list       = enumerable as System.Collections.Generic.IList<T>;
          bool                                                                     immutable  = list?.IsReadOnly ?? true;
          float                                                                    size       = position.height = base.GetPropertyHeight(property, label);
          (UnityEngine.Rect add, UnityEngine.Rect clear, UnityEngine.Rect foldout) positions  = (
            add    : new(position.x + (position.width - Util.PercOf(size, 200.0f)), position.y, size,                                       position.height),
            clear  : new(position.x + (position.width - Util.PercOf(size, 100.0f)), position.y, size,                                       position.height),
            foldout: new(position.x,                                                position.y, position.width - Util.PercOf(size, 200.0f), position.height)
          );

          // …
          if (!RefListDrawer<T>.IsDrawable) {
            base.OnGUI(position, property, label);
            return;
          }

          UnityEditor.EditorGUI.BeginChangeCheck();
            color                 = UnityEngine.GUI.color;
            UnityEngine.GUI.color = new(UnityEngine.GUI.color.r, UnityEngine.GUI.color.g, UnityEngine.GUI.color.b, UnityEngine.GUI.color.a * 0.5f);
            UnityEngine.GUI.Label(positions.foldout, new string('＿', label.text.Length) + (!string.IsNullOrEmpty(label.text.Trim()) ? " " : string.Empty) + $"({Util.Enumerable.Count(enumerable).ToString()})");
            UnityEngine.GUI.color = color;

            this.foldout = UnityEditor.EditorPrefs.GetBool(label.text);
            this.foldout = UnityEditor.EditorGUI  .Foldout(positions.foldout, this.foldout, label, true);
          if (UnityEditor.EditorGUI.EndChangeCheck()) UnityEditor.EditorPrefs.SetBool(label.text, this.foldout);

          if (!immutable) {
            if (UnityEngine.GUI.Button(positions.add, new UnityEngine.GUIContent("+", "Add item"), UnityEditor.EditorStyles.miniButton)) {
              list!.Add(typeof(T) == typeof(string) ? (T) (object) string.Empty : Traits.IsValueType<T>() ? System.Activator.CreateInstance<T>() : (T) (null as object)!);
              Util.Game.AskToSave();
            }

            if (UnityEngine.GUI.Button(positions.clear, new UnityEngine.GUIContent("×", "Clear list"), UnityEditor.EditorStyles.miniButtonRight)) {
              list!.Clear();
              Util.Game.AskToSave();
            }
          }

          if (this.foldout) {
            if (enumerable.IsEmpty()) {
              color                 = UnityEngine.GUI.color;
              UnityEngine.GUI.color = new(UnityEngine.GUI.color.r, UnityEngine.GUI.color.g, UnityEngine.GUI.color.b, UnityEngine.GUI.color.a * 0.5f);
              UnityEngine.GUI.Label(new(position.x, position.y + position.height, position.width, position.height), "List is empty");
              UnityEngine.GUI.color = color;

              return;
            }

            using (System.Collections.Generic.IEnumerator<T> enumerator = enumerable.GetEnumerator())
            for (int index = 0; enumerator.MoveNext(); ++index) {
              T element = enumerator.Current;
              (UnityEngine.Rect element, UnityEngine.Rect clear) subpositions = (
                element: new(position.x + Util.PercOf(position.width - size,   2.0f) + (immutable ? size : 0.0f), position.y += position.height, Util.PercOf(position.width - size, 98.0f), position.height),
                clear  : new(position.x + Util.PercOf(position.width - size, 100.0f),                             position.y,                    size,                                      position.height)
              );

              // …
              UnityEditor.EditorGUI.BeginChangeCheck();
                element = (T) RefListDrawer<T>.GUIField!(subpositions.element, element!);
              if (UnityEditor.EditorGUI.EndChangeCheck()) {
                switch (enumerable) {
                  case Game.Collections.RefReadOnlyList<T> sublist: sublist.SetValue(element, (uint) index); break;
                  default:                                                  list![index] = element;                  break;
                }

                Util.Game.AskToSave();
                break;
              }

              if (!immutable)
              if (UnityEngine.GUI.Button(subpositions.clear, new UnityEngine.GUIContent("-", "Clear item"), UnityEditor.EditorStyles.miniButtonRight)) {
                list!.RemoveAt(index);

                Util.Game.AskToSave();
                break;
              }
            }
          }
        }
      }
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.AnimationCurveList))]         public class AnimationCurveListDrawer         : Game.Collections.RefListDrawer<UnityEngine.AnimationCurve> {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.AnimationCurveReadOnlyList))] public class AnimationCurveReadOnlyListDrawer : Game.Collections.RefListDrawer<UnityEngine.AnimationCurve> {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.BooleanList))]                public class BooleanListDrawer                : Game.Collections.RefListDrawer<System     .Boolean>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.BooleanReadOnlyList))]        public class BooleanReadOnlyListDrawer        : Game.Collections.RefListDrawer<System     .Boolean>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.BoundsList))]                 public class BoundsListDrawer                 : Game.Collections.RefListDrawer<UnityEngine.Bounds>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.BoundsReadOnlyList))]         public class BoundsReadOnlyListDrawer         : Game.Collections.RefListDrawer<UnityEngine.Bounds>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.BoundsIntList))]              public class BoundsIntListDrawer              : Game.Collections.RefListDrawer<UnityEngine.BoundsInt>      {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.BoundsIntReadOnlyList))]      public class BoundsIntReadOnlyListDrawer      : Game.Collections.RefListDrawer<UnityEngine.BoundsInt>      {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.ColorList))]                  public class ColorListDrawer                  : Game.Collections.RefListDrawer<UnityEngine.Color>          {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.ColorReadOnlyList))]          public class ColorReadOnlyListDrawer          : Game.Collections.RefListDrawer<UnityEngine.Color>          {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.DoubleList))]                 public class DoubleListDrawer                 : Game.Collections.RefListDrawer<System     .Double>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.DoubleReadOnlyList))]         public class DoubleReadOnlyListDrawer         : Game.Collections.RefListDrawer<System     .Double>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.FloatList))]                  public class FloatListDrawer                  : Game.Collections.RefListDrawer<System     .Single>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.FloatReadOnlyList))]          public class FloatReadOnlyListDrawer          : Game.Collections.RefListDrawer<System     .Single>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.GameObjectList))]             public class GameObjectListDrawer             : Game.Collections.RefListDrawer<UnityEngine.GameObject>     {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.GameObjectReadOnlyList))]     public class GameObjectReadOnlyListDrawer     : Game.Collections.RefListDrawer<UnityEngine.GameObject>     {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.GradientList))]               public class GradientListDrawer               : Game.Collections.RefListDrawer<UnityEngine.Gradient>       {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.GradientReadOnlyList))]       public class GradientReadOnlyListDrawer       : Game.Collections.RefListDrawer<UnityEngine.Gradient>       {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.IntList))]                    public class IntListDrawer                    : Game.Collections.RefListDrawer<System     .Int32>          {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.IntReadOnlyList))]            public class IntReadOnlyListDrawer            : Game.Collections.RefListDrawer<System     .Int32>          {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.LongList))]                   public class LongListDrawer                   : Game.Collections.RefListDrawer<System     .Int64>          {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.LongReadOnlyList))]           public class LongReadOnlyListDrawer           : Game.Collections.RefListDrawer<System     .Int64>          {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.RectList))]                   public class RectListDrawer                   : Game.Collections.RefListDrawer<UnityEngine.Rect>           {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.RectReadOnlyList))]           public class RectReadOnlyListDrawer           : Game.Collections.RefListDrawer<UnityEngine.Rect>           {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.RectIntList))]                public class RectIntListDrawer                : Game.Collections.RefListDrawer<UnityEngine.RectInt>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.RectIntReadOnlyList))]        public class RectIntReadOnlyListDrawer        : Game.Collections.RefListDrawer<UnityEngine.RectInt>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.StringList))]                 public class StringListDrawer                 : Game.Collections.RefListDrawer<System     .String>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.StringReadOnlyList))]         public class StringReadOnlyListDrawer         : Game.Collections.RefListDrawer<System     .String>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.UIntList))]                   public class UIntListDrawer                   : Game.Collections.RefListDrawer<System     .UInt32>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.UIntReadOnlyList))]           public class UIntReadOnlyListDrawer           : Game.Collections.RefListDrawer<System     .UInt32>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.ULongList))]                  public class ULongListDrawer                  : Game.Collections.RefListDrawer<System     .UInt64>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.ULongReadOnlyList))]          public class ULongReadOnlyListDrawer          : Game.Collections.RefListDrawer<System     .UInt64>         {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector2List))]                public class Vector2ListDrawer                : Game.Collections.RefListDrawer<UnityEngine.Vector2>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector2ReadOnlyList))]        public class Vector2ReadOnlyListDrawer        : Game.Collections.RefListDrawer<UnityEngine.Vector2>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector2IntList))]             public class Vector2IntListDrawer             : Game.Collections.RefListDrawer<UnityEngine.Vector2Int>     {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector2IntReadOnlyList))]     public class Vector2IntReadOnlyListDrawer     : Game.Collections.RefListDrawer<UnityEngine.Vector2Int>     {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector3List))]                public class Vector3ListDrawer                : Game.Collections.RefListDrawer<UnityEngine.Vector3>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector3ReadOnlyList))]        public class Vector3ReadOnlyListDrawer        : Game.Collections.RefListDrawer<UnityEngine.Vector3>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector3IntList))]             public class Vector3IntListDrawer             : Game.Collections.RefListDrawer<UnityEngine.Vector3Int>     {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector3IntReadOnlyList))]     public class Vector3IntReadOnlyListDrawer     : Game.Collections.RefListDrawer<UnityEngine.Vector3Int>     {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector4List))]                public class Vector4ListDrawer                : Game.Collections.RefListDrawer<UnityEngine.Vector4>        {}
        [UnityEditor.CustomPropertyDrawer(typeof(Game.Collections.Vector4ReadOnlyList))]        public class Vector4ReadOnlyListDrawer        : Game.Collections.RefListDrawer<UnityEngine.Vector4>        {}

      [UnityEditor.CustomPropertyDrawer(typeof(Game.ReadWriteInInspectorAttribute))]
      public class ReadWriteInInspectorDrawer : UnityEditor.PropertyDrawer {
        [GameMethod(AggressiveInlining)] public override float GetPropertyHeight(UnityEditor.SerializedProperty property, UnityEngine.GUIContent         label)                                  => UnityEditor.EditorGUI.GetPropertyHeight(property, label, true);
        [GameMethod(AggressiveInlining)] public override void  OnGUI            (UnityEngine.Rect               position, UnityEditor.SerializedProperty property, UnityEngine.GUIContent label) => UnityEditor.EditorGUI.PropertyField    (position, property, label, true);
      }
    #endif
  }

  public interface Events /* ->> Based on `System.EventArgs`; See `https://web.archive.org/web/20130916192216/https://developer.mozilla.org/en-US/docs/Web/API/Event` for naming scheme used (or `https://web.archive.org/web/20250117180031/https://learn.microsoft.com/en-us/dotnet/api/system.threading.manualresetevent?view=net-9.0` for an example) */ {
    public struct LoadEvent : Game.Events {
      public static readonly LoadEvent Default = new() {data = (0u, 1u, false, 0.0, new(string.Empty, System.UriKind.Relative), null), callback = [GameMethod(AggressiveInlining)] static (object? _, in LoadEvent _) => {}};

      public readonly uint                                                                                         attempts                        => this.data.attempts;        // ->> Track persistent `LoadUri*(…)` `retries`
      public readonly uint                                                                                         attemptsAllowed                 => this.data.attemptsAllowed; //    ^^
      public readonly bool                                                                                         cached                          => this.data.cached;
      public Game.Handler<LoadEvent>                                                                       callback { get; internal set; } =  LoadEvent.Default.callback;
      public (uint attempts, uint attemptsAllowed, bool cached, double duration, System.Uri path, object? payload) data                            =  LoadEvent.Default.data;
      public readonly double                                                                                       duration                        => this.data.duration; // ->> Time since load till payload
      public double                                                                                                epoch    { get; internal set; } =  UnityEngine.Time.realtimeSinceStartupAsDouble;
      public object?                                                                                               metadata { get;          set; } =  null;
      public readonly System.Uri                                                                                   path                            => this.data.path;
      public readonly object?                                                                                      payload                         => this.data.payload;
      System.Delegate                                                                                              Game.Events.callback { get => this.callback; set => this.callback = (Game.Handler<LoadEvent>)                 value!; }
      object?                                                                                                      Game.Events.data     { get => this.data;     set => this.data     = ((uint, uint, bool, double, System.Uri, object?)) value!; }
      double                                                                                                       Game.Events.epoch    { get => this.epoch;    set => this.epoch    = value; }
      object?                                                                                                      Game.Events.metadata { get => this.metadata; set => this.metadata = value; }

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)]
      public LoadEvent() {}

      /* … */
      [GameMethod(AggressiveInlining)] public readonly          void    Deconstruct(out System.Uri path,     out object? payload)                                                                                           { path = this.path; payload = this.payload; }
      [GameMethod(AggressiveInlining)] public readonly          void    Deconstruct(out System.Uri path,     out object? payload,         out bool   cached)                                                                { this.Deconstruct(out path, out payload); cached   = this.cached; }
      [GameMethod(AggressiveInlining)] public readonly          void    Deconstruct(out System.Uri path,     out object? payload,         out double duration)                                                              { this.Deconstruct(out path, out payload); duration = this.duration; }
      [GameMethod(AggressiveInlining)] public readonly          void    Deconstruct(out uint       attempts, out uint    attemptsAllowed, out bool   cached, out double duration, out System.Uri path, out object? payload) { this.Deconstruct(out path, out payload); attempts = this.attempts; attemptsAllowed = this.attemptsAllowed; cached = this.cached; duration = this.duration; }
      [GameMethod(AggressiveInlining)] public readonly override string? ToString   ()                                                                                                                                       => $"(attempts: {this.attempts}/{this.attemptsAllowed}, cached: {this.cached}, duration: {this.duration}secs, path: {this.path}, payload: {this.payload is not null})";
    }

    public struct WaitEvent : Game.Events {
      public static readonly WaitEvent Default = new() {data = (0.0, 0.0, false), callback = [GameMethod(AggressiveInlining)] static (object? _, in WaitEvent _) => {}};

      public Game.Handler<WaitEvent>                  callback { get; internal set; } =  WaitEvent.Default.callback;
      public (double delay, double timestamp, bool repeating) data                            =  WaitEvent.Default.data;
      public readonly double                                  delay                           => this.data.delay; // ->> Specified delay
      public double                                           epoch    { get; internal set; } =  UnityEngine.Time.realtimeSinceStartupAsDouble;
      public object?                                          metadata { get;          set; } =  null;
      public readonly bool                                    repeating                       => this.data.repeating;
      public readonly double                                  timestamp                       => this.data.timestamp; // ->> Next available timestamp to signal a `Wait` event (which could be in the past chronologically)
      System.Delegate                                         Game.Events.callback { get => this.callback; set => this.callback = (Game.Handler<WaitEvent>) value; }
      object?                                                 Game.Events.data     { get => this.data;     set => this.data     = ((double, double, bool))          value!; }
      double                                                  Game.Events.epoch    { get => this.epoch;    set => this.epoch    = value; }
      object?                                                 Game.Events.metadata { get => this.metadata; set => this.metadata = value; }

      /* … */
      [GameConstructor, GameMethod(AggressiveInlining)]
      public WaitEvent() {}

      /* … */
      [GameMethod(AggressiveInlining)] public readonly          void    Deconstruct(out double delay, out double timestamp)                     { delay = this.delay; timestamp = this.timestamp; }
      [GameMethod(AggressiveInlining)] public readonly          void    Deconstruct(out double delay, out double timestamp, out bool repeating) { this.Deconstruct(out delay, out timestamp); repeating = this.repeating; }
      [GameMethod(AggressiveInlining)] public readonly override string? ToString   ()                                                           => $"(delay: {this.delay}secs, repeating: {this.repeating}, waiting: {UnityEngine.Time.realtimeSinceStartupAsDouble < this.timestamp})";
    }

    /* … */
    public System.Delegate callback { get; internal set; }
    public object?         data     { get; internal set; }
    public double          epoch    { get; internal set; }
    public object?         metadata { get;          set; }

    /* … */
    internal static Game.Handler<T> ToMetadataHandler<T>(System.Action<object?> callback) where T : struct, Game.Events => callback is not null ? ([GameMethod(AggressiveInlining)] (object? _, in T data) => callback(data.metadata)) : null!;
  }

  /* … */
  public        delegate void           ArrayCopier <T>                    (T[]                        sourceArray, uint       sourceIndex, T[] destinationArray, uint destinationIndex, uint count); // ->> See `𝑓 Util.Array    <T>.Copy        (…)`
  public        delegate ref T          ArrayIndexer<T>                    (T[]                        array,       uint       index);                                                                // ->> See `𝑓 Util.Reference<T>.ArrayAtValue(…)`
  public        delegate object         GUIField                           (in UnityEngine.Rect        position,    object     value);                                                                // ->> Determines how `RefDictionary<…>` (and `RefReadOnlyDictionary<…>`) elements are drawn by the Inspector
  public        delegate void           Handler<T>                         (object?                    target,      in T       data) where T : Game.Events;                                           // ->> Handles completed `Load`, `Wait`, … operations i.e. `System.EventHandler`
  public        delegate object?        Interpolator                       (double                     progress,    in object? a, in object? b);                                                      // ->> Interpolates `::begin` and `::end` properties in `Game.Collections.Keyframe["…"]`
  public        delegate T              Interpolator                 <T>   (double                     progress,    in T       a, in T       b);                                                      //    ^^
  public        delegate ref readonly T ReadOnlySpanIndexer          <T>   (in  System.ReadOnlySpan<T> span, int index);                                                                              // ->> See `𝑓 Util.Reference<T>.ReadOnlySpanAtValue(…)`
  public        delegate void           RefAction                    <T>   (ref T                      value);                                                                                        // ->> Based on `System.Action<T>`
  public unsafe delegate void*          RefAddresser                 <T>   (ref T                      value);                                                                                        // ->> Address of i.e. `&value`
  public        delegate int            RefComparison                <T>   (ref T                      a, ref T b);                                                                                   // ->> Based on `System.Comparison<T>`; See `𝑓 RefComparer<T>.CompareValue(…)`
  public        delegate U              RefConverter                 <T, U>(ref T                      value);                                                                                        // ->> Based on `System.Converter<T, U>`
  public        delegate bool           RefEqualityComparison        <T>   (ref T                      a, ref T b);                                                                                   // ->> See `𝑓 RefEqualityComparer<T>.EqualsValue(…)`
  public        delegate ref T          Referrer                     <T>   ();                                                                                                                        //
  public        delegate int            RefHasher                    <T>   (ref T                      value);                                                                                        //
  public        delegate bool           RefPredicate                 <T>   (ref T                      value);                                                                                        // ->> Based on `System.Predicate<T>`
  public        delegate void           RefReadOnlyAction            <T>   (in  T                      value);                                                                                        // ->> Based on `System.Action<T>`
  public unsafe delegate void*          RefReadOnlyAddresser         <T>   (in  T                      value);                                                                                        // ->> Address of i.e. `&value`
  public        delegate int            RefReadOnlyComparison        <T>   (in  T                      a, in  T b);                                                                                   // ->> Based on `System.Comparison<T>`; See `𝑓 RefReadOnlyComparer<T>.CompareValue(…)`
  public        delegate U              RefReadOnlyConverter         <T, U>(in  T                      value);                                                                                        // ->> Based on `System.Converter<T, U>`
  public        delegate bool           RefReadOnlyEqualityComparison<T>   (in  T                      a, in T b);                                                                                    // ->> See `𝑓 RefReadOnlyEqualityComparer<T>.EqualsValue(…)`
  public        delegate int            RefReadOnlyHasher            <T>   (in  T                      value);                                                                                        //
  public        delegate bool           RefReadOnlyPredicate         <T>   (in  T                      value);                                                                                        // ->> Based on `System.Predicate<T>`
  public        delegate ref readonly T RefReadOnlyTransformer       <T>   (in  T                      value);                                                                                        // ->> Based on `System.Func<T, T>`
  public        delegate ref T          RefTransformer               <T>   (ref T                      value);                                                                                        // ->> Based on `System.Func<T, T>`
  public        delegate ref T          SpanIndexer                  <T>   (in  System.Span<T>         span, int index);                                                                              // ->> See `𝑓 Util.Reference<T>.SpanAtValue(…)`
  public        delegate double         Tweener                            (double                     time);                                                                                         // ->> Adjusts interpolation be-tween `Interpolator(…)`’s `progress` from `a` to `b`

  [System.AttributeUsage(System.AttributeTargets.All, AllowMultiple = false, Inherited = false)] // ->> Display property in Unity Inspector as “read-only”
  public sealed class ReadOnlyInInspectorAttribute : UnityEngine.PropertyAttribute /* ->> `System.Attribute`, `Unity.Collections.ReadOnlyAttribute` */ {}

  [System.AttributeUsage(System.AttributeTargets.All, AllowMultiple = false, Inherited = false)] // ->> Display property in Unity Inspector as “read-write”
  public sealed class ReadWriteInInspectorAttribute : UnityEngine.PropertyAttribute /* ->> `System.Attribute` */ {}

  public readonly ref struct Void { /* ->> “error CS0590: UsEr-DeFiNeD oPeRaToRs CaNnOt ReTuRn VoId” */ }
}

namespace Game /* ->> …everything else */ {
  public static class Animation {
    public static partial class Function {
      [GameMethod(AggressiveInlining)] public static double CubicBézier    (double time, double p0, double p1, double p2, double p3) { return (p0 * System.Math.Pow(1.0 - time, 3.0)) + (p1 * time * 3.0 * System.Math.Pow(1.0 - time, 2.0)) + (p2 * (1.0 - time) * 3.0 * System.Math.Pow(time, 2.0)) + (p3 * System.Math.Pow(time, 3.0)); }
      [GameMethod(AggressiveInlining)] public static double QuadraticBézier(double time, double p0, double p1, double p2)            { return (p0 * System.Math.Pow(1.0 - time, 2.0)) + (p1 * time * 2.0 * System.Math.Pow(1.0 - time, 1.0))                                                          + (p2 * System.Math.Pow(time, 2.0)); }

      [GameMethod(AggressiveInlining)] public static double Ease                (double time) { return Game.Animation.Function.CubicBézier(time, 0.25, 0.10, 0.25, 1.00); }
      [GameMethod(AggressiveInlining)] public static double EaseIn              (double time) { return Game.Animation.Function.CubicBézier(time, 0.42, 0.00, 1.00, 1.00); }
      [GameMethod(AggressiveInlining)] public static double EaseInBack          (double time) { return (System.Math.Pow(time, 3.0) * 2.70158) - (System.Math.Pow(time, 2.0) * 1.70158); }
      [GameMethod(AggressiveInlining)] public static double EaseInBounce        (double time) { return 1.0 - Game.Animation.Function.EaseOutBounce(1.0 - time); }
      [GameMethod(AggressiveInlining)] public static double EaseInCircular      (double time) { return 1.0 - System.Math.Sqrt(1.0 - System.Math.Pow(time, 2.0)); }
      [GameMethod(AggressiveInlining)] public static double EaseInCubic         (double time) { return System.Math.Pow(time, 3.0); }
      [GameMethod(AggressiveInlining)] public static double EaseInElastic       (double time) { return time != 0.0 && time != 1.0 ? -System.Math.Pow(2.0, (time * 10.0) - 10.0) * System.Math.Sin(((time * 10.0) - 10.75) * ((System.Math.PI * 2.0) / 3.0)) : time; }
      [GameMethod(AggressiveInlining)] public static double EaseInExponential   (double time) { return time != 0.0 ? System.Math.Pow(2.0, (time * 10.0) - 10.0) : 0.0; }
      [GameMethod(AggressiveInlining)] public static double EaseInOut           (double time) { return Game.Animation.Function.CubicBézier(time, 0.42, 0.00, 0.58, 1.00); }
      [GameMethod(AggressiveInlining)] public static double EaseInOutBack       (double time) { return (time < 0.5 ? System.Math.Pow(time * 2.0, 2.0) * ((7.189819f * time) - 2.5949095) : ((System.Math.Pow((time * 2.0) - 2.0, 2.0) * ((((time * 2.0) - 2.0) * 3.5949095) + 2.5949095)) + 2.0)) / 2.0; }
      [GameMethod(AggressiveInlining)] public static double EaseInOutBounce     (double time) { return (time < 0.5 ? (1.0 - Game.Animation.Function.EaseOutBounce(1.0 - (time * 2.0))) : (1.0 + Game.Animation.Function.EaseOutBounce((time * 2.0) - 1.0))) / 2.0; }
      [GameMethod(AggressiveInlining)] public static double EaseInOutCircular   (double time) { return (time < 0.5 ? (1.0 - System.Math.Sqrt(1.0 - System.Math.Pow(time * 2.0, 2.0))) : (1.0 + System.Math.Sqrt(1.0 - System.Math.Pow((time * -2.0) + 2.0, 2.0)))) / 2.0; }
      [GameMethod(AggressiveInlining)] public static double EaseInOutCubic      (double time) { return time < 0.5 ? 4.0 * System.Math.Pow(time, 3.0) : (1.0 - (System.Math.Pow((time * -2.0) + 2.0, 3.0) / 2.0)); }
      [GameMethod(AggressiveInlining)] public static double EaseInOutElastic    (double time) { return time != 0.0 && time != 1.0 ? time < 0.5 ? -(System.Math.Pow(2.0, (time * 20.0) - 10.0) * System.Math.Sin(((time * 20.0) - 11.125) * ((System.Math.PI * 2.0) / 4.5))) / 2.0 : ((System.Math.Pow(2.0, (time * -20.0) + 10.0) * System.Math.Sin(((time * 20.0) - 11.125) * ((System.Math.PI * 2.0) / 4.5))) / 2.0 + 1.0) : time; }
      [GameMethod(AggressiveInlining)] public static double EaseInOutExponential(double time) { return time != 0.0 && time != 1.0 ? (time < 0.5 ? System.Math.Pow(2.0, (time * 20.0) - 10.0) : (2.0 - System.Math.Pow(2.0, (time * -20.0) + 10.0))) / 2.0 : time; }
      [GameMethod(AggressiveInlining)] public static double EaseInOutQuadratic  (double time) { return time < 0.5 ?  2.0 * System.Math.Pow(time, 2.0) : (1.0 - (System.Math.Pow((time * -2.0) + 2.0, 2.0) / 2.0)); }
      [GameMethod(AggressiveInlining)] public static double EaseInOutQuartic    (double time) { return time < 0.5 ?  8.0 * System.Math.Pow(time, 4.0) : (1.0 - (System.Math.Pow((time * -2.0) + 2.0, 4.0) / 2.0)); }
      [GameMethod(AggressiveInlining)] public static double EaseInOutQuintic    (double time) { return time < 0.5 ? 16.0 * System.Math.Pow(time, 5.0) : (1.0 - (System.Math.Pow((time * -2.0) + 2.0, 5.0) / 2.0)); }
      [GameMethod(AggressiveInlining)] public static double EaseInOutSine       (double time) { return -(System.Math.Cos(System.Math.PI * time) - 1.0) / 2.0; }
      [GameMethod(AggressiveInlining)] public static double EaseInQuadratic     (double time) { return System.Math.Pow(time, 2.0); }
      [GameMethod(AggressiveInlining)] public static double EaseInQuartic       (double time) { return System.Math.Pow(time, 4.0); }
      [GameMethod(AggressiveInlining)] public static double EaseInQuintic       (double time) { return System.Math.Pow(time, 5.0); }
      [GameMethod(AggressiveInlining)] public static double EaseInSine          (double time) { return 1.0 - System.Math.Cos((System.Math.PI * time) / 2.0); }
      [GameMethod(AggressiveInlining)] public static double EaseOut             (double time) { return Game.Animation.Function.CubicBézier(time, 0.00, 0.00, 0.58, 1.00); }
      [GameMethod(AggressiveInlining)] public static double EaseOutBack         (double time) { return 1.0 + (2.70158 * System.Math.Pow(time - 1.0, 3.0)) + (System.Math.Pow(time - 1.0, 2.0) * 1.70158); }
      [GameMethod(AggressiveInlining)] public static double EaseOutBounce       (double time) { return time < 1.0 / 2.75 ? System.Math.Pow(time, 2.0) * 7.5625 : time < 2.0 / 2.75 ? (System.Math.Pow(time - (1.5 / 2.75), 2.0) * 7.5625) + 0.75 : time < 2.5 / 2.75 ? (System.Math.Pow(time - (2.25 / 2.75), 2.0) * 7.5625) + 0.9375 : (System.Math.Pow(time - (2.625 / 2.75), 2.0) * 7.5625) + 0.984375; }
      [GameMethod(AggressiveInlining)] public static double EaseOutCircular     (double time) { return System.Math.Sqrt(1.0 - System.Math.Pow(time - 1.0, 2.0)); }
      [GameMethod(AggressiveInlining)] public static double EaseOutCubic        (double time) { return 1.0 - System.Math.Pow(1.0 - time, 3.0); }
      [GameMethod(AggressiveInlining)] public static double EaseOutElastic      (double time) { return time != 0.0 && time != 1.0 ? (System.Math.Pow(2.0, time * -10.0) * System.Math.Sin(((time * 10.0) - 0.75) * ((System.Math.PI * 2.0) / 3.0))) + 1.0 : time; }
      [GameMethod(AggressiveInlining)] public static double EaseOutExponential  (double time) { return time != 1.0 ? 1.0 - System.Math.Pow(2.0, time * -10.0) : 1.0; }
      [GameMethod(AggressiveInlining)] public static double EaseOutQuadratic    (double time) { return 1.0 - System.Math.Pow(1.0 - time, 2.0); }
      [GameMethod(AggressiveInlining)] public static double EaseOutQuartic      (double time) { return 1.0 - System.Math.Pow(1.0 - time, 4.0); }
      [GameMethod(AggressiveInlining)] public static double EaseOutQuintic      (double time) { return 1.0 - System.Math.Pow(1.0 - time, 5.0); }
      [GameMethod(AggressiveInlining)] public static double EaseOutSine         (double time) { return System.Math.Sin((System.Math.PI * time) / 2.0); }
      [GameMethod(AggressiveInlining)] public static double Linear              (double time) { return time; }
    }
  }

  public static class Extensions /* ->> Method extensions e.g. `System.Array.Add(this …)` */ {
    private static readonly UnityEngine.Vector3[] GetRectSizeWorldCorners = new UnityEngine.Vector3[4];

    /* … */
    [GameMethod(AggressiveInlining)] public static void Add              (this System.Collections.Queue                             queue,      object?                                               element) { if (queue      is not null) queue     .Enqueue(element); }                    // ->> Intended for initializer lists only i.e. `new() {…}`
    [GameMethod(AggressiveInlining)] public static void Add<T>           (this System.Collections.Queue                             queue,      T                                                     element) { if (queue      is not null) queue     .Enqueue(element); }                    //    ^^
    [GameMethod(AggressiveInlining)] public static void Add<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> dictionary, System.Collections.Generic.KeyValuePair<TKey, TValue> element) { if (dictionary is not null) dictionary.Add    (element.Key, element.Value); } //
    [GameMethod(AggressiveInlining)] public static void Add<T>           (this System.Collections.Generic.Queue      <T>            queue,      T                                                     element) { if (queue      is not null) queue     .Enqueue(element); }                    // ->> Intended for initializer lists only i.e. `new() {…}`
    [GameMethod(AggressiveInlining)] public static void Add<T>           (this System.Collections.Generic.Stack      <T>            stack,      T                                                     element) { if (stack      is not null) stack     .Push   (element); }                    //    ^^
    [GameMethod(AggressiveInlining)] public static void Add              (this System.Collections.Stack                             stack,      object?                                               element) { if (stack      is not null) stack     .Push   (element); }                    //
    [GameMethod(AggressiveInlining)] public static void Add<T>           (this System.Collections.Stack                             stack,      T                                                     element) { if (stack      is not null) stack     .Push   (element); }                    //

    [GameMethod(AggressiveInlining)] public static void AddRange<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> dictionary, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> enumerable) { if (dictionary is not null) foreach (System.Collections.Generic.KeyValuePair<TKey, TValue> element in dictionary) dictionary.Add(element.Key, element.Value); }
    [GameMethod(AggressiveInlining)] public static void AddRange<T>           (this System.Collections.Generic.IList      <T>            list,       System.Collections.Generic.IEnumerable<T>                                                     enumerable) { if (list       is not null) foreach (T                                                     value   in enumerable) list      .Add(value); }

    [GameMethod(AggressiveInlining)] public static ref readonly object? Append   (this System.Collections.ArrayList             arrayList, in object? value) { if (arrayList is not null) { arrayList.Add    (value); return ref value; } return ref Util.Reference<object?>.Null; }
    [GameMethod(AggressiveInlining)] public static ref readonly T       Append<T>(this System.Collections.ArrayList             arrayList, in T       value) { if (arrayList is not null) { arrayList.Add    (value); return ref value; } return ref Util.Reference<T>      .Null; }
    [GameMethod(AggressiveInlining)] public static ref readonly T       Append<T>(this System.Collections.Generic.LinkedList<T> list,      in T       value) { if (list      is not null) { list     .AddLast(value); return ref value; } return ref Util.Reference<T>      .Null; }
    [GameMethod(AggressiveInlining)] public static ref readonly T       Append<T>(this System.Collections.Generic.List      <T> list,      in T       value) { if (list      is not null) { list     .Add    (value); return ref value; } return ref Util.Reference<T>      .Null; }

    [GameMethod(AggressiveInlining)] public static T[]                                                                       AsCopy<T>           (this    T[]                                                                       array)                            => array is not null ? (T[])          array.Clone() : Util.Reference<T[]>         .Null;
    [GameMethod(AggressiveInlining)] public static System.Array                                                              AsCopy              (this    System.Array                                                              array)                            => array is not null ? (System.Array) array.Clone() : Util.Reference<System.Array>.Null;
    [GameMethod(AggressiveInlining)] public static System.ArraySegment<T>                                                    AsCopy<T>           (in this System.ArraySegment<T>                                                    arraySegment)                     => new(Util.Array<T>.From(arraySegment));
    [GameMethod(AggressiveInlining)] public static System.ArraySegment<T>?                                                   AsCopy<T>           (this    System.ArraySegment<T>?                                                   arraySegment)                     => new(Util.Array<T>.From(arraySegment));
    [GameMethod(AggressiveInlining)] public static System.Collections.ArrayList                                              AsCopy              (this    System.Collections.ArrayList                                              arrayList)                        =>    arrayList        is not null ? (System.Collections.ArrayList) arrayList.Clone()                                                                                                                                                                                  : Util.Reference<System.Collections.ArrayList>                                   .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.BitArray                                               AsCopy              (this    System.Collections.BitArray                                               bits)                             =>    bits             is not null ? (System.Collections.BitArray)  bits     .Clone()                                                                                                                                                                                  : Util.Reference<System.Collections.BitArray>                                    .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Queue                                                  AsCopy              (this    System.Collections.Queue                                                  queue)                            =>    queue            is not null ? (System.Collections.Queue)     queue    .Clone()                                                                                                                                                                                  : Util.Reference<System.Collections.Queue>                                       .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Generic.Dictionary      <TKey, TValue>                 AsCopy<TKey, TValue>(this    System.Collections.Generic.Dictionary      <TKey, TValue>                 dictionary)                       =>    dictionary       is not null ? new(dictionary, dictionary.Comparer)                                                                                                                                                                                              : Util.Reference<System.Collections.Generic.Dictionary<TKey, TValue>>            .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Generic.HashSet         <T>                            AsCopy<T>           (this    System.Collections.Generic.HashSet         <T>                            hashset)                          =>    hashset          is not null ? new(hashset,    hashset   .Comparer)                                                                                                                                                                                              : Util.Reference<System.Collections.Generic.HashSet<T>>                          .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Generic.LinkedList      <T>                            AsCopy<T>           (this    System.Collections.Generic.LinkedList      <T>                            list)                             =>    list             is not null ? new(list)                                                                                                                                                                                                                         : Util.Reference<System.Collections.Generic.LinkedList<T>>                       .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Generic.List            <T>                            AsCopy<T>           (this    System.Collections.Generic.List            <T>                            list)                             =>    list             is not null ? new(list)                                                                                                                                                                                                                         : Util.Reference<System.Collections.Generic.List<T>>                             .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Generic.Queue           <T>                            AsCopy<T>           (this    System.Collections.Generic.Queue           <T>                            queue)                            =>    queue            is not null ? new(queue)                                                                                                                                                                                                                        : Util.Reference<System.Collections.Generic.Queue<T>>                            .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Generic.SortedDictionary<TKey, TValue>                 AsCopy<TKey, TValue>(this    System.Collections.Generic.SortedDictionary<TKey, TValue>                 sortedDictionary)                 =>    sortedDictionary is not null ? new(sortedDictionary, sortedDictionary.Comparer)                                                                                                                                                                                  : Util.Reference<System.Collections.Generic.SortedDictionary<TKey, TValue>>      .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Generic.SortedList      <TKey, TValue>                 AsCopy<TKey, TValue>(this    System.Collections.Generic.SortedList      <TKey, TValue>                 sortedList)                       =>    sortedList       is not null ? new(sortedList,       sortedList      .Comparer)                                                                                                                                                                                  : Util.Reference<System.Collections.Generic.SortedList<TKey, TValue>>            .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Generic.SortedSet       <T>                            AsCopy<T>           (this    System.Collections.Generic.SortedSet       <T>                            sortedSet)                        =>    sortedSet        is not null ? new(sortedSet,        sortedSet       .Comparer)                                                                                                                                                                                  : Util.Reference<System.Collections.Generic.SortedSet<T>>                        .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Generic.Stack           <T>                            AsCopy<T>           (this    System.Collections.Generic.Stack           <T>                            stack)                            =>    stack            is not null ? new(stack)                                                                                                                                                                                                                        : Util.Reference<System.Collections.Generic.Stack<T>>                            .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Hashtable                                              AsCopy              (this    System.Collections.Hashtable                                              hashtable)                        =>    hashtable        is not null ? (System.Collections.Hashtable) hashtable.Clone() /* ->> `new(hashtable, hashtable.EqualityComparer)` */                                                                                                                            : Util.Reference<System.Collections.Hashtable>                                   .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.ObjectModel.Collection                  <T>            AsCopy<T>           (this    System.Collections.ObjectModel.Collection                  <T>            collection)                       =>    collection       is not null ? new(collection)                                                                                                                                                                                                                   : Util.Reference<System.Collections.ObjectModel.Collection<T>>                   .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.ObjectModel.ObservableCollection        <T>            AsCopy<T>           (this    System.Collections.ObjectModel.ObservableCollection        <T>            collection)                       =>    collection       is not null ? new(collection)                                                                                                                                                                                                                   : Util.Reference<System.Collections.ObjectModel.ObservableCollection<T>>         .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.ObjectModel.ReadOnlyCollection          <T>            AsCopy<T>           (this    System.Collections.ObjectModel.ReadOnlyCollection          <T>            collection)                       =>    collection       is not null ? new(new System.Collections.Generic.List                    <T>           (collection))                                                                                                                                            : Util.Reference<System.Collections.ObjectModel.ReadOnlyCollection<T>>           .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.ObjectModel.ReadOnlyDictionary          <TKey, TValue> AsCopy<TKey, TValue>(this    System.Collections.ObjectModel.ReadOnlyDictionary          <TKey, TValue> dictionary)                       =>    dictionary       is not null ? new(new System.Collections.Generic.Dictionary              <TKey, TValue>(dictionary))                                                                                                                                            : Util.Reference<System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>>.Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.ObjectModel.ReadOnlyObservableCollection<T>            AsCopy<T>           (this    System.Collections.ObjectModel.ReadOnlyObservableCollection<T>            collection)                       =>    collection       is not null ? new(new System.Collections.ObjectModel.ObservableCollection<T>           (collection))                                                                                                                                            : Util.Reference<System.Collections.ObjectModel.ReadOnlyObservableCollection<T>> .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.SortedList                                             AsCopy              (this    System.Collections.SortedList                                             sortedList)                       =>    sortedList       is not null ? (System.Collections.SortedList) sortedList.Clone()                                                                                                                                                                                : Util.Reference<System.Collections.SortedList>                                  .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Specialized.HybridDictionary                           AsCopy              (this    System.Collections.Specialized.HybridDictionary                           dictionary)                       =>    dictionary       is not null ? dictionary.AsCopy(false)                                                                                                                                                                                                          : Util.Reference<System.Collections.Specialized.HybridDictionary>                .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Specialized.HybridDictionary                           AsCopy              (this    System.Collections.Specialized.HybridDictionary                           dictionary, bool caseInsensitive) { if (dictionary       is not null) { System.Collections.Specialized.HybridDictionary copy = new(dictionary.Count, caseInsensitive); foreach (System.Collections.DictionaryEntry element in dictionary) { copy.Add(element.Key, element.Value); } return copy; }  return Util.Reference<System.Collections.Specialized.HybridDictionary>                .Null; }
    [GameMethod(AggressiveInlining)] public static System.Collections.Specialized.ListDictionary                             AsCopy              (this    System.Collections.Specialized.ListDictionary                             dictionary)                       { if (dictionary       is not null) { System.Collections.Specialized.ListDictionary   copy = new();                                  foreach (System.Collections.DictionaryEntry element in dictionary) { copy.Add(element.Key, element.Value); } return copy; }  return Util.Reference<System.Collections.Specialized.ListDictionary>                  .Null; }
    [GameMethod(AggressiveInlining)] public static System.Collections.Specialized.NameValueCollection                        AsCopy              (this    System.Collections.Specialized.NameValueCollection                        collection)                       =>    collection       is not null ? new(collection)                                                                                                                                                                                                                   : Util.Reference<System.Collections.Specialized.NameValueCollection>             .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Specialized.OrderedDictionary                          AsCopy              (this    System.Collections.Specialized.OrderedDictionary                          dictionary)                       { if (dictionary       is not null) { System.Collections.Specialized.OrderedDictionary copy = new(dictionary.Count); foreach (System.Collections.DictionaryEntry element in dictionary) { copy.Add(element.Key, element.Value); }    return copy; }               return Util.Reference<System.Collections.Specialized.OrderedDictionary>               .Null; }
    [GameMethod(AggressiveInlining)] public static System.Collections.Specialized.StringCollection                           AsCopy              (this    System.Collections.Specialized.StringCollection                           collection)                       { if (collection       is not null) { System.Collections.Specialized.StringCollection  copy = new(); string[] subcopy = new string[collection.Count]; collection.CopyTo(subcopy, 0); copy.AddRange(subcopy);                         return copy; }               return Util.Reference<System.Collections.Specialized.StringCollection>                .Null; }
    [GameMethod(AggressiveInlining)] public static System.Collections.Specialized.StringDictionary                           AsCopy              (this    System.Collections.Specialized.StringDictionary                           dictionary)                       { if (dictionary       is not null) { System.Collections.Specialized.StringDictionary  copy = new(); foreach (System.Collections.DictionaryEntry element in dictionary) { copy.Add((string) element.Key, element.Value as string); } return copy; }               return Util.Reference<System.Collections.Specialized.StringDictionary>                .Null; }
    [GameMethod(AggressiveInlining)] public static System.Collections.Stack                                                  AsCopy              (this    System.Collections.Stack                                                  stack)                            =>    stack            is not null ? new(stack)                                                                                                                                                                                                                        : Util.Reference<System.Collections.Stack>                                       .Null;
    [GameMethod(AggressiveInlining)] public static System.IO.MemoryStream                                                    AsCopy              (this    System.IO.MemoryStream                                                    stream)                           { if (stream           is not null) { try { return new(stream.GetBuffer(), 0, (int) stream.Length, stream.CanWrite, true); } catch (System.UnauthorizedAccessException) {} return new(Util.Array.From(stream), 0, (int) stream.Length, stream.CanWrite, false); } return Util.Reference<System.IO.MemoryStream>                                         .Null; }
    [GameMethod(AggressiveInlining)] public static System.Memory        <T>                                                  AsCopy<T>           (in this System.Memory        <T>                                                  memory)                           => memory.Slice(0);
    [GameMethod(AggressiveInlining)] public static System.Memory        <T>?                                                 AsCopy<T>           (this    System.Memory        <T>?                                                 memory)                           => memory is not null ? memory?.Slice(0) : Util.Reference<System.Memory<T>>.Null;
    [GameMethod(AggressiveInlining)] public static System.ReadOnlyMemory<T>                                                  AsCopy<T>           (in this System.ReadOnlyMemory<T>                                                  memory)                           => memory.Slice(0);
    [GameMethod(AggressiveInlining)] public static System.ReadOnlyMemory<T>?                                                 AsCopy<T>           (this    System.ReadOnlyMemory<T>?                                                 memory)                           => memory is not null ? memory?.Slice(0) : Util.Reference<System.ReadOnlyMemory<T>>.Null;
    [GameMethod(AggressiveInlining)] public static System.ReadOnlySpan  <T>                                                  AsCopy<T>           (in this System.ReadOnlySpan  <T>                                                  span)                             => span.Slice(0);
    [GameMethod(AggressiveInlining)] public static System.Span          <T>                                                  AsCopy<T>           (in this System.Span          <T>                                                  span)                             => span.Slice(0);
    #if NET9_0 || NET9_0_OR_GREATER
      [GameMethod(AggressiveInlining)]
      public static System.Collections.ObjectModel.ReadOnlyCollection<T> AsCopy<T>(this System.Collections.ObjectModel.ReadOnlySet<T> set) => set is not null ? new(new System.Collections.Generic.HashSet<T>(set)) : Util.Reference<System.Collections.ObjectModel.Set<T>>.Null;
    #endif

    [GameMethod(AggressiveInlining)] public static System.Collections.ObjectModel.ReadOnlyCollection<T>            AsReadOnly<T>           (this T[]                                                  array)      =>    array      is not null ? System.Array.AsReadOnly<T>(array)                                                                                                                                                                                                                                                                  : Util.Reference<System.Collections.ObjectModel.ReadOnlyCollection<T>>           .Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue> AsReadOnly<TKey, TValue>(this System.Collections.Generic.Dictionary <TKey, TValue> dictionary) =>    dictionary is not null ? new System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>(dictionary)                                                                                                                                                                                                                    : Util.Reference<System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>>.Null;
    [GameMethod(AggressiveInlining)] public static System.Collections.Generic.IReadOnlyDictionary   <TKey, TValue> AsReadOnly<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> dictionary) { if (dictionary is not null) { (dictionary as System.Collections.Generic.Dictionary<TKey, TValue>)?.TrimExcess(); return dictionary is Game.Collections.RefDictionary<TKey, TValue> subdictionary ? subdictionary.AsReadOnly() : new System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>(dictionary); } return Util.Reference<System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>>   .Null; } // ->> `System.Collections.Generic.CollectionExtensions.AsReadOnly<TKey, TValue>(dictionary);`
    [GameMethod(AggressiveInlining)] public static System.Collections.Generic.IReadOnlyList         <T>            AsReadOnly<T>           (this System.Collections.Generic.IList      <T>            list)       { if (list       is not null) { (list       as System.Collections.Generic.List      <T>)           ?.TrimExcess(); return list       is Game.Collections.RefList      <T>            sublist       ? sublist      .AsReadOnly() : new System.Collections.ObjectModel.ReadOnlyCollection<T>           (list); }       return Util.Reference<System.Collections.Generic.IReadOnlyList<T>>                    .Null; } // ->> `System.Collections.Generic.CollectionExtensions.AsReadOnly<T>           (list);`
    [GameMethod(AggressiveInlining)] public static System.Collections.ObjectModel.ReadOnlyCollection<T>            AsReadOnly<T>           (this System.Collections.Generic.List       <T>            list)       =>    list       is not null ? new System.Collections.ObjectModel.ReadOnlyCollection<T>(list)                                                                                                                                                                                                                                     : Util.Reference<System.Collections.ObjectModel.ReadOnlyCollection<T>>           .Null;

    [GameMethod(AggressiveInlining)] public static int BinarySearch   (this System.Array array,                        object? element)                                                    => array is not null ? System.Array.BinarySearch(array, element)                          : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int BinarySearch   (this System.Array array,                        object? element, System.Collections.IComparer? comparer)            => array is not null ? System.Array.BinarySearch(array, element, comparer)                : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int BinarySearch   (this System.Array array, int index, int length, object? element)                                                    => array is not null ? System.Array.BinarySearch(array, index, length, element)           : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int BinarySearch   (this System.Array array, int index, int length, object? element, System.Collections.IComparer? comparer)            => array is not null ? System.Array.BinarySearch(array, index, length, element, comparer) : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int BinarySearch<T>(this T[]          array,                        in T    element)                                                    => array is not null ? System.Array.BinarySearch(array, element)                          : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int BinarySearch<T>(this T[]          array,                        in T    element, System.Collections.Generic.IComparer<T>? comparer) => array is not null ? System.Array.BinarySearch(array, element, comparer)                : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int BinarySearch<T>(this T[]          array, int index, int length, in T    element)                                                    => array is not null ? System.Array.BinarySearch(array, index, length, element)           : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int BinarySearch<T>(this T[]          array, int index, int length, in T    element, System.Collections.Generic.IComparer<T>? comparer) => array is not null ? System.Array.BinarySearch(array, index, length, element, comparer) : Util.Reference<int>.Null;

    [GameMethod(AggressiveInlining)] public static void Clear              (this System.Array                                         array)                        => array?.Clear(0, array.Length);
    [GameMethod(AggressiveInlining)] public static void Clear              (this System.Array                                         array, int index, int length) { if (array      is not null) System.Array.Clear(array, index, length); }
    [GameMethod(AggressiveInlining)] public static void Clear<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> dictionary)                   { if (dictionary is not null) foreach (TKey key in dictionary.Keys) dictionary.Remove(key); } // ->> `::Capacity` remains unchanged

    [GameMethod(AggressiveInlining)] public static bool Contains   (this System.Array array, object value)                                                            => array?.Contains(value, null as System.Collections.IEqualityComparer)                                                                                                                                                                                                ?? Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool Contains   (this System.Array array, object value, System.Collections.IEqualityComparer? comparer)            { if (array is not null) { for (System.Collections.IEnumerator enumerator = array.GetEnumerator(); enumerator.MoveNext(); ) { if (comparer?.Equals(enumerator.Current, value) ?? object.ReferenceEquals(enumerator.Current, value)) return true; } return false; } return Util.Reference<bool>.Null; }
    [GameMethod(AggressiveInlining)] public static bool Contains<T>(this T[]          array, in T   value)                                                            => array?.Contains<T>(value, null as System.Collections.Generic.IEqualityComparer<T>)                                                                                                         ?? Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool Contains<T>(this T[]          array, in T   value, System.Collections.Generic.IEqualityComparer<T>? comparer) { if (array is not null) { foreach (T element in array) { if ((comparer ?? System.Collections.Generic.EqualityComparer<T>.Default).Equals(element, value)) return true; } return false; } return Util.Reference<bool>.Null; } // ->> Benefits from devirtualization and likely inlining

    [GameMethod(AggressiveInlining)]
    public static bool ContainsValue<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> dictionary, in TValue value) {
      if (dictionary is not null) {
        foreach (TValue dictionaryValue in dictionary.Values) {
          if (System.Collections.Generic.EqualityComparer<TValue>.Default.Equals(value, dictionaryValue))
          return true;
        }

        return false;
      }

      return Util.Reference<bool>.Null;
    }

    [GameMethod(AggressiveInlining)] public static U[]  ConvertAll<T, U>(this T[]                                       array,      System.Converter<T, U> converter) => array is not null ? System.Array.ConvertAll<T, U>(array, converter) : Util.Reference<U[]>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountAll        (this System.Collections.IEnumerable            enumerable, System.Delegate        predicate) { if (enumerable is not null) { uint count = 0u; System.Collections.IEnumerator enumerator = enumerable.GetEnumerator(); while (enumerator.MoveNext()) { count += (bool) predicate.DynamicInvoke(new[] {enumerator.Current}) ? 1u : 0u; } (enumerable as System.IDisposable)?.Dispose(); return count; } return Util.Reference<uint>.Null; }
    [GameMethod(AggressiveInlining)] public static uint CountAll<T>     (this System.Collections.Generic.IEnumerable<T> enumerable, System.Predicate<T>    predicate) => ((System.Collections.IEnumerable) enumerable).CountAll(predicate);

    [GameMethod(AggressiveInlining)] public static uint CountChildren(this UnityEngine.Component  component)  => null != component  ? component.CountChildrenByComponent(component.GetType()) : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountChildren(this UnityEngine.GameObject gameObject) => null != gameObject ? (uint) gameObject.transform.childCount                  : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountChildren(this UnityEngine.Transform  transform)  => null != transform  ? transform.gameObject.CountChildren()                    : Util.Reference<uint>.Null;

    [GameMethod(AggressiveInlining)] public static uint CountChildrenByComponent<T>(this UnityEngine.Component  component)                    =>    null != component  ? component.gameObject.CountChildrenByComponent<T>()                                                                                                                       : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountChildrenByComponent<T>(this UnityEngine.GameObject gameObject)                   =>    null != gameObject ? gameObject          .CountChildrenByComponent   (typeof(T))                                                                                                              : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountChildrenByComponent   (this UnityEngine.Component  component,  System.Type type) =>    null != component  ? component.gameObject.CountChildrenByComponent   (type)                                                                                                                   : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountChildrenByComponent   (this UnityEngine.GameObject gameObject, System.Type type) { if (null != gameObject) { uint count = 0u; foreach (UnityEngine.GameObject child in gameObject.EnumerateChildren()) { count += null != child.GetComponent(type) ? 1u : 0u; } return count; } return Util.Reference<uint>.Null; }

    [GameMethod(AggressiveInlining)] public static uint CountChildrenByName(this UnityEngine.Component  component,  string name) =>    null != component ? component.gameObject.CountChildrenByName(name)                                                                                                              : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountChildrenByName(this UnityEngine.GameObject gameObject, string name) { if (null != gameObject) { uint count = 0u; foreach (UnityEngine.GameObject child in gameObject.EnumerateChildren()) { count += child.name == name ? 1u : 0u; } return count; } return Util.Reference<uint>.Null; }

    [GameMethod(AggressiveInlining)] public static uint CountChildrenByTag(this UnityEngine.Component  component,  string tag) =>    null != component ? component.gameObject.CountChildrenByTag(tag)                                                                                                              : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountChildrenByTag(this UnityEngine.GameObject gameObject, string tag) { if (null != gameObject) { uint count = 0u; foreach (UnityEngine.GameObject child in gameObject.EnumerateChildren()) { count += child.tag == tag ? 1u : 0u; } return count; } return Util.Reference<uint>.Null; }

    [GameMethod(AggressiveInlining)] public static uint CountDescendants(this UnityEngine.Component  component)  => null != component  ? component.CountDescendantsByComponent(component.GetType()) : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountDescendants(this UnityEngine.GameObject gameObject) => null != gameObject ? (uint) gameObject.transform.hierarchyCount - 1             : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountDescendants(this UnityEngine.Transform  transform)  => null != transform  ? transform.gameObject.CountDescendants()                    : Util.Reference<uint>.Null;

    [GameMethod(AggressiveInlining)] public static uint CountDescendantsByComponent<T>(this UnityEngine.Component  component)                    =>    null != component  ? component.gameObject.CountDescendantsByComponent<T>()                                                                                                                                 : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountDescendantsByComponent<T>(this UnityEngine.GameObject gameObject)                   =>    null != gameObject ? gameObject          .CountDescendantsByComponent   (typeof(T))                                                                                                                        : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountDescendantsByComponent   (this UnityEngine.Component  component,  System.Type type) =>    null != component  ? component.gameObject.CountDescendantsByComponent   (type)                                                                                                                             : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountDescendantsByComponent   (this UnityEngine.GameObject gameObject, System.Type type) { if (null != gameObject) { uint count = 0u; foreach (UnityEngine.GameObject descendant in gameObject.EnumerateDescendants()) { count += null != descendant.GetComponent(type) ? 1u : 0u; } return count; } return Util.Reference<uint>.Null; }

    [GameMethod(AggressiveInlining)] public static uint CountDescendantsByName(this UnityEngine.Component  component,  string name) =>    null != component ? component.gameObject.CountDescendantsByName(name)                                                                                                                        : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountDescendantsByName(this UnityEngine.GameObject gameObject, string name) { if (null != gameObject) { uint count = 0u; foreach (UnityEngine.GameObject descendant in gameObject.EnumerateDescendants()) { count += descendant.name == name ? 1u : 0u; } return count; } return Util.Reference<uint>.Null; }

    [GameMethod(AggressiveInlining)] public static uint CountDescendantsByTag(this UnityEngine.Component  component,  string tag) =>    null != component ? component.gameObject.CountDescendantsByTag(tag)                                                                                                                        : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountDescendantsByTag(this UnityEngine.GameObject gameObject, string tag) { if (null != gameObject) { uint count = 0u; foreach (UnityEngine.GameObject descendant in gameObject.EnumerateDescendants()) { count += descendant.tag == tag ? 1u : 0u; } return count; } return Util.Reference<uint>.Null; }

    [GameMethod(AggressiveInlining)] public static uint CountHierarchy(this UnityEngine.Component  component)  => null != component  ? component.gameObject.CountHierarchyByComponent(component.GetType()) : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountHierarchy(this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject          .CountDescendants         () + 1u               : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountHierarchy(this UnityEngine.Transform  transform)  => null != transform  ? transform.gameObject.CountHierarchy           ()                    : Util.Reference<uint>.Null;

    [GameMethod(AggressiveInlining)] public static uint CountHierarchyByComponent<T>(this UnityEngine.Component  component)                    => null != component  ? component.gameObject.CountHierarchyByComponent<T>()                                                         : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountHierarchyByComponent<T>(this UnityEngine.GameObject gameObject)                   => null != gameObject ? gameObject          .CountHierarchyByComponent   (typeof(T))                                                : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountHierarchyByComponent   (this UnityEngine.Component  component,  System.Type type) => null != component  ? component.gameObject.CountHierarchyByComponent   (type)                                                     : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountHierarchyByComponent   (this UnityEngine.GameObject gameObject, System.Type type) => null != gameObject ? gameObject          .CountDescendantsByComponent (type) + (null != gameObject.GetComponent(type) ? 1u : 0u) : Util.Reference<uint>.Null;

    [GameMethod(AggressiveInlining)] public static uint CountHierarchyByName(this UnityEngine.Component  component,  string name) => null != component  ? component.gameObject.CountHierarchyByName  (name)                                       : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountHierarchyByName(this UnityEngine.GameObject gameObject, string name) => null != gameObject ? gameObject          .CountDescendantsByName(name) + (gameObject.name == name ? 1u : 0u) : Util.Reference<uint>.Null;

    [GameMethod(AggressiveInlining)] public static uint CountHierarchyByTag(this UnityEngine.Component  component,  string tag) => null != component  ? component.gameObject.CountHierarchyByTag  (tag)                                     : Util.Reference<uint>.Null;
    [GameMethod(AggressiveInlining)] public static uint CountHierarchyByTag(this UnityEngine.GameObject gameObject, string tag) => null != gameObject ? gameObject          .CountDescendantsByTag(tag) + (gameObject.tag == tag ? 1u : 0u) : Util.Reference<uint>.Null;

    [GameMethod(AggressiveInlining)]
    public static uint CountInvocationList(this System.Delegate delegated) => delegated is not null ? (uint) delegated.GetInvocationList().Length : Util.Reference<uint>.Null;

    [GameMethod(AggressiveInlining)] public static void Deconstruct<T>(this T[] array, out T itemA, out T itemB)                                                                  { itemA = Util.Array.At(array, 0u); itemB = Util.Array.At(array, 1u); }                                                                                                                                                                           // ->> Minimum of two `System.ValueTuple<…>` elements
    [GameMethod(AggressiveInlining)] public static void Deconstruct<T>(this T[] array, out T itemA, out T itemB, out T itemC)                                                     { itemA = Util.Array.At(array, 0u); itemB = Util.Array.At(array, 1u); itemC = Util.Array.At(array, 2u); }                                                                                                                                         //
    [GameMethod(AggressiveInlining)] public static void Deconstruct<T>(this T[] array, out T itemA, out T itemB, out T itemC, out T itemD)                                        { itemA = Util.Array.At(array, 0u); itemB = Util.Array.At(array, 1u); itemC = Util.Array.At(array, 2u); itemD = Util.Array.At(array, 3u); }                                                                                                       //
    [GameMethod(AggressiveInlining)] public static void Deconstruct<T>(this T[] array, out T itemA, out T itemB, out T itemC, out T itemD, out T itemE)                           { itemA = Util.Array.At(array, 0u); itemB = Util.Array.At(array, 1u); itemC = Util.Array.At(array, 2u); itemD = Util.Array.At(array, 3u); itemE = Util.Array.At(array, 4u); }                                                                     //
    [GameMethod(AggressiveInlining)] public static void Deconstruct<T>(this T[] array, out T itemA, out T itemB, out T itemC, out T itemD, out T itemE, out T itemF)              { itemA = Util.Array.At(array, 0u); itemB = Util.Array.At(array, 1u); itemC = Util.Array.At(array, 2u); itemD = Util.Array.At(array, 3u); itemE = Util.Array.At(array, 4u); itemF = Util.Array.At(array, 5u); }                                   //
    [GameMethod(AggressiveInlining)] public static void Deconstruct<T>(this T[] array, out T itemA, out T itemB, out T itemC, out T itemD, out T itemE, out T itemF, out T itemG) { itemA = Util.Array.At(array, 0u); itemB = Util.Array.At(array, 1u); itemC = Util.Array.At(array, 2u); itemD = Util.Array.At(array, 3u); itemE = Util.Array.At(array, 4u); itemF = Util.Array.At(array, 5u); itemG = Util.Array.At(array, 6u); } // ->> After this point, the possibly deconstructed `System.ValueTuple<…>` begins to recurse

    [GameMethod(AggressiveInlining)] public static void Die(this UnityEngine.Component  component)  { if (null != component) { UnityEngine.Object.Destroy(component); component.gameObject.Die(); } }
    [GameMethod(AggressiveInlining)] public static void Die(this UnityEngine.GameObject gameObject) { if (null != gameObject)  UnityEngine.Object.Destroy(gameObject); }

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectIterator EnumerateChildren   (this UnityEngine.GameObject gameObject) => null != gameObject ? new(GameObjectIterator.Kind.Children,    gameObject.transform) : Util.Reference<Game.Collections.GameObjectIterator>.Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectIterator EnumerateDescendants(this UnityEngine.GameObject gameObject) => null != gameObject ? new(GameObjectIterator.Kind.Descendants, gameObject.transform) : Util.Reference<Game.Collections.GameObjectIterator>.Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectIterator EnumerateHierarchy  (this UnityEngine.GameObject gameObject) => null != gameObject ? new(GameObjectIterator.Kind.Hierarchy,   gameObject.transform) : Util.Reference<Game.Collections.GameObjectIterator>.Null;

    [GameMethod(AggressiveInlining)] public static T                     EnsureComponent<T>(this UnityEngine.Component  component)  where T : UnityEngine.Component => null != component  ?     component.gameObject.EnsureComponent<T>()                                                                : Util.Reference<T>                    .Null;
    [GameMethod(AggressiveInlining)] public static T                     EnsureComponent<T>(this UnityEngine.GameObject gameObject) where T : UnityEngine.Component => null != gameObject ? (T) gameObject          .EnsureComponent   (typeof(T))                                                       : Util.Reference<T>                    .Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Component EnsureComponent   (this UnityEngine.Component  component,  System.Type type)               => null != component  ?     component.gameObject.EnsureComponent   (type)                                                            : Util.Reference<UnityEngine.Component>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Component EnsureComponent   (this UnityEngine.GameObject gameObject, System.Type type)               => null != gameObject ? gameObject.GetComponent(type) is UnityEngine.Component component ? component : gameObject.AddComponent(type) : Util.Reference<UnityEngine.Component>.Null;

    [GameMethod(AggressiveInlining)]
    public static bool Exists<T>(this T[] array, System.Predicate<T> predicate) => array is not null ? System.Array.Exists<T>(array, predicate) : Util.Reference<bool>.Null;

    [GameMethod(AggressiveInlining)]
    public static void Fill<T>(this T[] array, in T element) {
      if (array is not null) {
        #if NET5_0 || NET5_0_OR_GREATER || NETCOREAPP2_1 || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_0 || NETSTANDARD2_0_OR_GREATER
          new System.Span<T>(array).Fill(element);
          return;
        #endif

        #pragma warning disable CS8500
          if (!array.IsEmpty()) unsafe {
            Util.Reference<T>.First(array) = element;

            for (uint filled = 1u; array.Length > filled; filled <<= 1)
            Util.Array<T>.Copy(array, 0, array, filled, System.Math.Min(filled, (uint) array.Length - filled));
          }
        #pragma warning restore CS8500
      }
    }

    [GameMethod(AggressiveInlining)]
    public static void Fill<T>(this System.Collections.Generic.IList<T> list, in T element) {
      if (list is not null) {
        for (int index = list.Count; 0 != index--; )
        list[index] = element;
      }
    }

    [GameMethod(AggressiveInlining)] public static T?  Find   <T>(this T[] array, System.Predicate<T> predicate) => (array is not null ? System.Array.Find   <T>(array, predicate) : Util.Reference<T?> .Null);
    [GameMethod(AggressiveInlining)] public static T[] FindAll<T>(this T[] array, System.Predicate<T> predicate) => (array is not null ? System.Array.FindAll<T>(array, predicate) : Util.Reference<T[]>.Null);

    [GameMethod(AggressiveInlining)] public static UnityEngine.Component?  FindChild   (this UnityEngine.Component  component,  System.Predicate<UnityEngine.Component>  predicate)                                 =>   (null != component ? component.gameObject.FindChild<UnityEngine.Component>(predicate)                                                                                                                               : Util.Reference<UnityEngine.Component?> .Null);
    [GameMethod(AggressiveInlining)] public static T?                      FindChild<T>(this UnityEngine.Component  component,  System.Predicate<T>                      predicate) where T : UnityEngine.Component =>   (null != component ? component.gameObject.FindChild<T>                    (predicate)                                                                                                                               : Util.Reference<T?>                     .Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject? FindChild   (this UnityEngine.GameObject gameObject, System.Predicate<UnityEngine.GameObject> predicate)                                 { if (null != gameObject) { foreach (UnityEngine.GameObject child in gameObject.EnumerateChildren()) {                                         if                      (predicate(child))     return child; } }     return Util.Reference<UnityEngine.GameObject?>.Null; }
    [GameMethod(AggressiveInlining)] public static T?                      FindChild<T>(this UnityEngine.GameObject gameObject, System.Predicate<T>                      predicate) where T : UnityEngine.Component { if (null != gameObject) { foreach (UnityEngine.GameObject child in gameObject.EnumerateChildren()) { T? component = child.GetComponent<T>(); if (null != component && predicate(component)) return component; } } return Util.Reference<T?>                     .Null; }

    [GameMethod(AggressiveInlining)] public static T?                     FindChildByComponent<T>(this UnityEngine.Component  component)  where T : UnityEngine.Component =>   (null != component  ? component.gameObject.FindChildByComponent<T>()                                                                                                                                             : Util.Reference<T?>                    .Null);
    [GameMethod(AggressiveInlining)] public static T?                     FindChildByComponent<T>(this UnityEngine.GameObject gameObject) where T : UnityEngine.Component =>   (null != gameObject ? gameObject          .FindChildByComponent   (typeof(T)) as T                                                                                                                               : Util.Reference<T?>                    .Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.Component? FindChildByComponent   (this UnityEngine.Component  component,  System.Type type)               =>   (null != component  ? component.gameObject.FindChildByComponent   (type)                                                                                                                                         : Util.Reference<UnityEngine.Component?>.Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.Component? FindChildByComponent   (this UnityEngine.GameObject gameObject, System.Type type)               { if (null != gameObject) { foreach (UnityEngine.GameObject child in gameObject.EnumerateChildren()) { UnityEngine.Component? component = child.GetComponent(type); if (null != component) return component; } } return Util.Reference<UnityEngine.Component?>.Null; }

    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject? FindChildByIndex(this UnityEngine.Component  component,  uint index) =>   (null != component ? component.gameObject.FindChildByIndex(index)                                                                                                                                                                    : Util.Reference<UnityEngine.GameObject?>.Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject? FindChildByIndex(this UnityEngine.GameObject gameObject, uint index) { if (null != gameObject) { for (System.Collections.IEnumerator enumerator = gameObject.transform.GetEnumerator(); enumerator.MoveNext(); ) { if (0u == index--) return ((UnityEngine.Transform) enumerator.Current).gameObject; } } return Util.Reference<UnityEngine.GameObject?>.Null; }

    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject? FindChildByName(this UnityEngine.Component  component,  string name) =>   (null != component ? component.gameObject.FindChildByName(name)                                                                                  : Util.Reference<UnityEngine.GameObject?>.Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject? FindChildByName(this UnityEngine.GameObject gameObject, string name) { if (null != gameObject) { foreach (UnityEngine.GameObject child in gameObject.EnumerateChildren()) { if (child.name == name) return child; } } return Util.Reference<UnityEngine.GameObject?>.Null; }

    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject? FindChildByTag(this UnityEngine.Component  component,  string tag) =>   (null != component ? component.gameObject.FindChildByTag(tag)                                                                                  : Util.Reference<UnityEngine.GameObject?>.Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject? FindChildByTag(this UnityEngine.GameObject gameObject, string tag) { if (null != gameObject) { foreach (UnityEngine.GameObject child in gameObject.EnumerateChildren()) { if (child.tag == tag) return child; } } return Util.Reference<UnityEngine.GameObject?>.Null; }

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.Component>  FindChildren   (this UnityEngine.Component  component,  System.Predicate<UnityEngine.Component>  predicate)                                 =>    null != component ? component.gameObject.FindChildren<UnityEngine.Component>(predicate)                                                                                                                                                                                                                                                                           : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.Component>> .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                      FindChildren<T>(this UnityEngine.Component  component,  System.Predicate<T>                      predicate) where T : UnityEngine.Component =>    null != component ? component.gameObject.FindChildren<T>                    (predicate)                                                                                                                                                                                                                                                                           : Util.Reference<Game.Collections.GameObjectSharedList<T>>                     .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindChildren   (this UnityEngine.GameObject gameObject, System.Predicate<UnityEngine.GameObject> predicate)                                 { if (null != gameObject) { GameObjectSharedList<UnityEngine.GameObject> children = new((uint) gameObject.transform.childCount); children.Clear(); foreach (UnityEngine.GameObject child in gameObject.EnumerateChildren()) {                                         if                      (predicate(child))     children.Add(child); }     return children; } return Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null; }
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                      FindChildren<T>(this UnityEngine.GameObject gameObject, System.Predicate<T>                      predicate) where T : UnityEngine.Component { if (null != gameObject) { GameObjectSharedList<T>                      children = new((uint) gameObject.transform.childCount); children.Clear(); foreach (UnityEngine.GameObject child in gameObject.EnumerateChildren()) { T? component = child.GetComponent<T>(); if (null != component && predicate(component)) children.Add(component); } return children; } return Util.Reference<Game.Collections.GameObjectSharedList<T>>                     .Null; }

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                     FindChildrenByComponent<T>(this UnityEngine.Component  component)  where T : UnityEngine.Component =>    null != component  ? component.gameObject.FindChildrenByComponent<T>()                                                                                                                                                                                                                                                                                        : Util.Reference<Game.Collections.GameObjectSharedList<T>>                    .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                     FindChildrenByComponent<T>(this UnityEngine.GameObject gameObject) where T : UnityEngine.Component =>    null != gameObject ? gameObject          .FindChildrenByComponent   (typeof(T)).ConvertAll([GameMethod(AggressiveInlining)] static (child) => (T) child)                                                                                                                                                                                                     : Util.Reference<Game.Collections.GameObjectSharedList<T>>                    .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.Component> FindChildrenByComponent   (this UnityEngine.Component  component,  System.Type type)               =>    null != component  ? component.gameObject.FindChildrenByComponent   (type)                                                                                                                                                                                                                                                                                    : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.Component>>.Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.Component> FindChildrenByComponent   (this UnityEngine.GameObject gameObject, System.Type type)               { if (null != gameObject) { GameObjectSharedList<UnityEngine.Component> children = new((uint) gameObject.transform.childCount); children.Clear(); foreach (UnityEngine.GameObject child in gameObject.EnumerateChildren()) { UnityEngine.Component? component = child.GetComponent(type); if (null != component) children.Add(component); } return children; } return Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.Component>>.Null; }

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindChildrenByName(this UnityEngine.Component  component,  string name) =>    null != component ? component.gameObject.FindChildrenByName(name)                                                                                                                                                                                                                                                       : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindChildrenByName(this UnityEngine.GameObject gameObject, string name) { if (null != gameObject) { Game.Collections.GameObjectSharedList<UnityEngine.GameObject> children = new((uint) gameObject.transform.childCount); children.Clear(); foreach (UnityEngine.GameObject child in gameObject.EnumerateChildren()) { if (child.name == name) children.Add(child); } return children; } return Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null; }

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindChildrenByTag(this UnityEngine.Component  component,  string tag) =>    null != component ? component.gameObject.FindChildrenByTag(tag)                                                                                                                                                                                                                                                       : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindChildrenByTag(this UnityEngine.GameObject gameObject, string tag) { if (null != gameObject) { Game.Collections.GameObjectSharedList<UnityEngine.GameObject> children = new((uint) gameObject.transform.childCount); children.Clear(); foreach (UnityEngine.GameObject child in gameObject.EnumerateChildren()) { if (child.tag == tag) children.Add(child); } return children; } return Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null; }

    [GameMethod(AggressiveInlining)] public static UnityEngine.Component?  FindDescendant   (this UnityEngine.Component  component,  System.Predicate<UnityEngine.Component>  predicate)                                 =>   (null != component ? component.gameObject.FindDescendant<UnityEngine.Component>(predicate)                                                                                                                             : Util.Reference<UnityEngine.Component?> .Null);
    [GameMethod(AggressiveInlining)] public static T?                      FindDescendant<T>(this UnityEngine.Component  component,  System.Predicate<T>                      predicate) where T : UnityEngine.Component =>   (null != component ? component.gameObject.FindDescendant<T>                    (predicate)                                                                                                                             : Util.Reference<T?>                     .Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject? FindDescendant   (this UnityEngine.GameObject gameObject, System.Predicate<UnityEngine.GameObject> predicate)                                 { if (null != gameObject) { foreach (UnityEngine.GameObject child in gameObject.EnumerateDescendants()) {                                         if                      (predicate(child))     return child; } }     return Util.Reference<UnityEngine.GameObject?>.Null; }
    [GameMethod(AggressiveInlining)] public static T?                      FindDescendant<T>(this UnityEngine.GameObject gameObject, System.Predicate<T>                      predicate) where T : UnityEngine.Component { if (null != gameObject) { foreach (UnityEngine.GameObject child in gameObject.EnumerateDescendants()) { T? component = child.GetComponent<T>(); if (null != component && predicate(component)) return component; } } return Util.Reference<T?>                     .Null; }

    [GameMethod(AggressiveInlining)] public static T?                     FindDescendantByComponent<T>(this UnityEngine.Component  component)  where T : UnityEngine.Component =>   (null != component  ? component.gameObject.FindDescendantByComponent<T>()                                                                                                                                           : Util.Reference<T?>                    .Null);
    [GameMethod(AggressiveInlining)] public static T?                     FindDescendantByComponent<T>(this UnityEngine.GameObject gameObject) where T : UnityEngine.Component =>   (null != gameObject ? gameObject          .FindDescendantByComponent   (typeof(T)) as T                                                                                                                             : Util.Reference<T?>                    .Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.Component? FindDescendantByComponent   (this UnityEngine.Component  component,  System.Type type)               =>   (null != component  ? component.gameObject.FindDescendantByComponent   (type)                                                                                                                                       : Util.Reference<UnityEngine.Component?>.Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.Component? FindDescendantByComponent   (this UnityEngine.GameObject gameObject, System.Type type)               { if (null != gameObject) { foreach (UnityEngine.GameObject child in gameObject.EnumerateDescendants()) { UnityEngine.Component? component = child.GetComponent(type); if (null != component) return component; } } return Util.Reference<UnityEngine.Component?>.Null; }

    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject? FindDescendantByIndex(this UnityEngine.Component  component,  uint index) =>   (null != component ? component.gameObject.FindDescendantByIndex(index)                                                                                                                                                               : Util.Reference<UnityEngine.GameObject?>.Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject? FindDescendantByIndex(this UnityEngine.GameObject gameObject, uint index) { if (null != gameObject) { for (System.Collections.IEnumerator enumerator = gameObject.transform.GetEnumerator(); enumerator.MoveNext(); ) { if (0u == index--) return ((UnityEngine.Transform) enumerator.Current).gameObject; } } return Util.Reference<UnityEngine.GameObject?>.Null; }

    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject? FindDescendantByName(this UnityEngine.Component  component,  string name) =>   (null != component ? component.gameObject.FindDescendantByName(name)                                                                                : Util.Reference<UnityEngine.GameObject?>.Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject? FindDescendantByName(this UnityEngine.GameObject gameObject, string name) { if (null != gameObject) { foreach (UnityEngine.GameObject child in gameObject.EnumerateDescendants()) { if (child.name == name) return child; } } return Util.Reference<UnityEngine.GameObject?>.Null; }

    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject? FindDescendantByTag(this UnityEngine.Component  component,  string tag) =>   (null != component ? component.gameObject.FindDescendantByTag(tag)                                                                                : Util.Reference<UnityEngine.GameObject?>.Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject? FindDescendantByTag(this UnityEngine.GameObject gameObject, string tag) { if (null != gameObject) { foreach (UnityEngine.GameObject child in gameObject.EnumerateDescendants()) { if (child.tag == tag) return child; } } return Util.Reference<UnityEngine.GameObject?>.Null; }

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.Component>  FindDescendants   (this UnityEngine.Component  component,  System.Predicate<UnityEngine.Component>  predicate)                                 =>    null != component ? component.gameObject.FindDescendants<UnityEngine.Component>(predicate)                                                                                                                                                                                                                                                                                                   : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.Component>> .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                      FindDescendants<T>(this UnityEngine.Component  component,  System.Predicate<T>                      predicate) where T : UnityEngine.Component =>    null != component ? component.gameObject.FindDescendants<T>                    (predicate)                                                                                                                                                                                                                                                                                                   : Util.Reference<Game.Collections.GameObjectSharedList<T>>                     .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindDescendants   (this UnityEngine.GameObject gameObject, System.Predicate<UnityEngine.GameObject> predicate)                                 { if (null != gameObject) { GameObjectSharedList<UnityEngine.GameObject> descendants = new((uint) gameObject.transform.childCount); descendants.Clear(); foreach (UnityEngine.GameObject descendant in gameObject.EnumerateDescendants()) {                                              if                      (predicate(descendant)) descendants.Add(descendant); } return descendants; } return Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null; }
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                      FindDescendants<T>(this UnityEngine.GameObject gameObject, System.Predicate<T>                      predicate) where T : UnityEngine.Component { if (null != gameObject) { GameObjectSharedList<T>                      descendants = new((uint) gameObject.transform.childCount); descendants.Clear(); foreach (UnityEngine.GameObject descendant in gameObject.EnumerateDescendants()) { T? component = descendant.GetComponent<T>(); if (null != component && predicate(component))  descendants.Add(component); }  return descendants; } return Util.Reference<Game.Collections.GameObjectSharedList<T>>                     .Null; }

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                     FindDescendantsByComponent<T>(this UnityEngine.Component  component)  where T : UnityEngine.Component =>    null != component  ? component.gameObject.FindDescendantsByComponent<T>()                                                                                                                                                                                                                                                                                                              : Util.Reference<Game.Collections.GameObjectSharedList<T>>                    .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                     FindDescendantsByComponent<T>(this UnityEngine.GameObject gameObject) where T : UnityEngine.Component =>    null != gameObject ? gameObject          .FindDescendantsByComponent   (typeof(T)).ConvertAll([GameMethod(AggressiveInlining)] static (descendant) => (T) descendant)                                                                                                                                                                                                                 : Util.Reference<Game.Collections.GameObjectSharedList<T>>                    .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.Component> FindDescendantsByComponent   (this UnityEngine.Component  component,  System.Type type)               =>    null != component  ? component.gameObject.FindDescendantsByComponent   (type)                                                                                                                                                                                                                                                                                                          : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.Component>>.Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.Component> FindDescendantsByComponent   (this UnityEngine.GameObject gameObject, System.Type type)               { if (null != gameObject) { GameObjectSharedList<UnityEngine.Component> descendants = new((uint) gameObject.transform.childCount); descendants.Clear(); foreach (UnityEngine.GameObject descendant in gameObject.EnumerateDescendants()) { UnityEngine.Component? component = descendant.GetComponent(type); if (null != component) descendants.Add(component); } return descendants; } return Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.Component>>.Null; }

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindDescendantsByName(this UnityEngine.Component  component,  string name) =>    null != component ? component.gameObject.FindDescendantsByName(name)                                                                                                                                                                                                                                                                                  : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindDescendantsByName(this UnityEngine.GameObject gameObject, string name) { if (null != gameObject) { Game.Collections.GameObjectSharedList<UnityEngine.GameObject> descendants = new((uint) gameObject.transform.childCount); descendants.Clear(); foreach (UnityEngine.GameObject descendant in gameObject.EnumerateDescendants()) { if (descendant.name == name) descendants.Add(descendant); } return descendants; } return Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null; }

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindDescendantsByTag(this UnityEngine.Component  component,  string tag) =>    null != component ? component.gameObject.FindDescendantsByTag(tag)                                                                                                                                                                                                                                                                                  : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindDescendantsByTag(this UnityEngine.GameObject gameObject, string tag) { if (null != gameObject) { Game.Collections.GameObjectSharedList<UnityEngine.GameObject> descendants = new((uint) gameObject.transform.childCount); descendants.Clear(); foreach (UnityEngine.GameObject descendant in gameObject.EnumerateDescendants()) { if (descendant.tag == tag) descendants.Add(descendant); } return descendants; } return Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null; }

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.Component>  FindHierarchy   (this UnityEngine.Component  component,  System.Predicate<UnityEngine.Component>  predicate)                                 =>    null != component ? component.gameObject.FindHierarchy<UnityEngine.Component>(predicate)                                                                                                                                                                                                                                                                               : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.Component>> .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                      FindHierarchy<T>(this UnityEngine.Component  component,  System.Predicate<T>                      predicate) where T : UnityEngine.Component =>    null != component ? component.gameObject.FindHierarchy<T>                    (predicate)                                                                                                                                                                                                                                                                               : Util.Reference<Game.Collections.GameObjectSharedList<T>>                     .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindHierarchy   (this UnityEngine.GameObject gameObject, System.Predicate<UnityEngine.GameObject> predicate)                                 { if (null != gameObject) { GameObjectSharedList<UnityEngine.GameObject> hierarchy = new((uint) gameObject.transform.childCount); hierarchy.Clear(); foreach (UnityEngine.GameObject child in gameObject.EnumerateHierarchy()) {                                         if                      (predicate(child))     hierarchy.Add(child); }     return hierarchy; } return Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null; }
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                      FindHierarchy<T>(this UnityEngine.GameObject gameObject, System.Predicate<T>                      predicate) where T : UnityEngine.Component { if (null != gameObject) { GameObjectSharedList<T>                      hierarchy = new((uint) gameObject.transform.childCount); hierarchy.Clear(); foreach (UnityEngine.GameObject child in gameObject.EnumerateHierarchy()) { T? component = child.GetComponent<T>(); if (null != component && predicate(component)) hierarchy.Add(component); } return hierarchy; } return Util.Reference<Game.Collections.GameObjectSharedList<T>>                     .Null; }

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                     FindHierarchyByComponent<T>(this UnityEngine.Component  component)  where T : UnityEngine.Component =>    null != component  ? component.gameObject.FindHierarchyByComponent<T>()                                                                                                                                                                                                                                                                                            : Util.Reference<Game.Collections.GameObjectSharedList<T>>                    .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                     FindHierarchyByComponent<T>(this UnityEngine.GameObject gameObject) where T : UnityEngine.Component =>    null != gameObject ? gameObject          .FindHierarchyByComponent   (typeof(T)).ConvertAll([GameMethod(AggressiveInlining)] static (_) => (T) _)                                                                                                                                                                                                                 : Util.Reference<Game.Collections.GameObjectSharedList<T>>                    .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.Component> FindHierarchyByComponent   (this UnityEngine.Component  component,  System.Type type)               =>    null != component  ? component.gameObject.FindHierarchyByComponent   (type)                                                                                                                                                                                                                                                                                        : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.Component>>.Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.Component> FindHierarchyByComponent   (this UnityEngine.GameObject gameObject, System.Type type)               { if (null != gameObject) { GameObjectSharedList<UnityEngine.Component> hierarchy = new((uint) gameObject.transform.childCount); hierarchy.Clear(); foreach (UnityEngine.GameObject child in gameObject.EnumerateHierarchy()) { UnityEngine.Component? component = child.GetComponent(type); if (null != component) hierarchy.Add(component); } return hierarchy; } return Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.Component>>.Null; }

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindHierarchyByName(this UnityEngine.Component  component,  string name) =>    null != component ? component.gameObject.FindHierarchyByName(name)                                                                                                                                                                                                                                                           : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindHierarchyByName(this UnityEngine.GameObject gameObject, string name) { if (null != gameObject) { Game.Collections.GameObjectSharedList<UnityEngine.GameObject> hierarchy = new((uint) gameObject.transform.childCount); hierarchy.Clear(); foreach (UnityEngine.GameObject child in gameObject.EnumerateHierarchy()) { if (child.name == name) hierarchy.Add(child); } return hierarchy; } return Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null; }

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindHierarchyByTag(this UnityEngine.Component  component,  string tag) =>    null != component ? component.gameObject.FindHierarchyByTag(tag)                                                                                                                                                                                                                                                           : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> FindHierarchyByTag(this UnityEngine.GameObject gameObject, string tag) { if (null != gameObject) { Game.Collections.GameObjectSharedList<UnityEngine.GameObject> hierarchy = new((uint) gameObject.transform.childCount); hierarchy.Clear(); foreach (UnityEngine.GameObject child in gameObject.EnumerateHierarchy()) { if (child.tag == tag) hierarchy.Add(child); } return hierarchy; } return Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null; }

    [GameMethod(AggressiveInlining)] public static int  FindIndex    <T>(this T[] array,                                    System.Predicate<T> predicate) =>   (array is not null ? System.Array.FindIndex    <T>(array,               predicate) : Util.Reference<int>.Null);
    [GameMethod(AggressiveInlining)] public static int  FindIndex    <T>(this T[] array, int              index,            System.Predicate<T> predicate) =>   (array is not null ? System.Array.FindIndex    <T>(array, index,        predicate) : Util.Reference<int>.Null);
    [GameMethod(AggressiveInlining)] public static int  FindIndex    <T>(this T[] array, int              index, int count, System.Predicate<T> predicate) =>   (array is not null ? System.Array.FindIndex    <T>(array, index, count, predicate) : Util.Reference<int>.Null);
    [GameMethod(AggressiveInlining)] public static T?   FindLast     <T>(this T[] array,                                    System.Predicate<T> predicate) =>   (array is not null ? System.Array.FindLast     <T>(array,               predicate) : Util.Reference<T?> .Null);
    [GameMethod(AggressiveInlining)] public static int  FindLastIndex<T>(this T[] array,                                    System.Predicate<T> predicate) =>   (array is not null ? System.Array.FindLastIndex<T>(array,               predicate) : Util.Reference<int>.Null);
    [GameMethod(AggressiveInlining)] public static int  FindLastIndex<T>(this T[] array, int              index,            System.Predicate<T> predicate) =>   (array is not null ? System.Array.FindLastIndex<T>(array, index,        predicate) : Util.Reference<int>.Null);
    [GameMethod(AggressiveInlining)] public static int  FindLastIndex<T>(this T[] array, int              index, int count, System.Predicate<T> predicate) =>   (array is not null ? System.Array.FindLastIndex<T>(array, index, count, predicate) : Util.Reference<int>.Null);
    [GameMethod(AggressiveInlining)] public static void ForEach      <T>(this T[] array, System.Action<T> action)                                          { if (array is not null)  System.Array.ForEach      <T>(array, action); }

    [GameMethod(AggressiveInlining)] public static float GetAlpha(this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.UI.Graphic>()?.GetAlpha() ?? 1.0f : Util.Reference<float>.Null;
    [GameMethod(AggressiveInlining)] public static float GetAlpha(this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.UI.Graphic>()?.GetAlpha() ?? 1.0f : Util.Reference<float>.Null;
    [GameMethod(AggressiveInlining)] public static float GetAlpha(this UnityEngine.UI.Graphic graphic)    => null != graphic    ? graphic.color.a                                                       : Util.Reference<float>.Null;
    [GameMethod(AggressiveInlining)] public static float GetAlpha(this TMPro.TextMeshProUGUI  text)       => null != text       ? text.alpha                                                            : Util.Reference<float>.Null;

    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetAnchoredPosition(this UnityEngine.Component     component,  bool fallback = false) => null != component  ? component .transform.GetAnchoredPosition(fallback)                                                                                                                                               : Util.Reference<UnityEngine.Vector2>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetAnchoredPosition(this UnityEngine.GameObject    gameObject, bool fallback = false) => null != gameObject ? gameObject.transform.GetAnchoredPosition(fallback)                                                                                                                                               : Util.Reference<UnityEngine.Vector2>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetAnchoredPosition(this UnityEngine.RectTransform transform,  bool fallback = false) => null != transform  ? transform.anchoredPosition                                                                                                                                                                       : Util.Reference<UnityEngine.Vector2>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetAnchoredPosition(this UnityEngine.Transform     transform,  bool fallback = false) { if (null != transform) { if (transform is UnityEngine.RectTransform rectTransform) return rectTransform.GetAnchoredPosition(fallback); else if (fallback) return (UnityEngine.Vector2) transform.localPosition; } return Util.Reference<UnityEngine.Vector2>.Null; }

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.Component>  GetChildren   (this UnityEngine.Component  component)                                  => null != component  ? component .FindChildrenByComponent   (component.GetType())                                      : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.Component>> .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                      GetChildren<T>(this UnityEngine.Component  component) where T : UnityEngine.Component  => null != component  ? component .FindChildrenByComponent<T>()                                                         : Util.Reference<Game.Collections.GameObjectSharedList<T>>                     .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> GetChildren   (this UnityEngine.GameObject gameObject)                                 => null != gameObject ? gameObject.FindChildren              ([GameMethod(AggressiveInlining)] static (child) => true) : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                      GetChildren<T>(this UnityEngine.GameObject gameObject) where T : UnityEngine.Component => null != gameObject ? gameObject.FindChildren<T>           ([GameMethod(AggressiveInlining)] static (child) => true) : Util.Reference<Game.Collections.GameObjectSharedList<T>>                     .Null;

    [GameMethod(AggressiveInlining)] public static UnityEngine.Bounds  GetColliderBounds  (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.Collider>().GetColliderBounds() : Util.Reference<UnityEngine.Bounds> .Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Bounds  GetColliderBounds  (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.Collider>().GetColliderBounds() : Util.Reference<UnityEngine.Bounds> .Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Bounds  GetColliderBounds  (this UnityEngine.Collider   collider)   => null != collider   ? collider.bounds                                                     : Util.Reference<UnityEngine.Bounds> .Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetColliderCenter  (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.Collider>().GetColliderCenter() : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetColliderCenter  (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.Collider>().GetColliderCenter() : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetColliderCenter  (this UnityEngine.Collider   collider)   => null != collider   ? collider  .GetColliderBounds().center                               : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static float               GetColliderHeight  (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.Collider>().GetColliderHeight() : Util.Reference<float>              .Null;
    [GameMethod(AggressiveInlining)] public static float               GetColliderHeight  (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.Collider>().GetColliderHeight() : Util.Reference<float>              .Null;
    [GameMethod(AggressiveInlining)] public static float               GetColliderHeight  (this UnityEngine.Collider   collider)   => collider.GetColliderSize().y;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetColliderPosition(this UnityEngine.Component  component)  => null != component  ? component .transform.GetColliderPosition()                         : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetColliderPosition(this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.transform.GetColliderPosition()                         : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetColliderPosition(this UnityEngine.Transform  transform)  => null != transform  ? transform.position                                                 : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetColliderSize    (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.Collider>().GetColliderSize()  : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetColliderSize    (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.Collider>().GetColliderSize()  : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetColliderSize    (this UnityEngine.Collider   collider)   => null != collider   ? collider  .GetColliderBounds().size                                : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static float               GetColliderWidth   (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.Collider>().GetColliderWidth() : Util.Reference<float>              .Null;
    [GameMethod(AggressiveInlining)] public static float               GetColliderWidth   (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.Collider>().GetColliderWidth() : Util.Reference<float>              .Null;
    [GameMethod(AggressiveInlining)] public static float               GetColliderWidth   (this UnityEngine.Collider   collider)   => collider.GetColliderSize().x;

    [GameMethod(AggressiveInlining)] public static UnityEngine.Color? GetColor(this UnityEngine.Component  component)  => (null != component  ? component .GetComponent<UnityEngine.UI.Graphic>()?.GetColor() : Util.Reference<UnityEngine.Color?>.Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.Color? GetColor(this UnityEngine.GameObject gameObject) => (null != gameObject ? gameObject.GetComponent<UnityEngine.UI.Graphic>()?.GetColor() : Util.Reference<UnityEngine.Color?>.Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.Color? GetColor(this UnityEngine.UI.Graphic graphic)    => (null != graphic    ? graphic.color                                                 : Util.Reference<UnityEngine.Color?>.Null);

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.Component>  GetDescendants   (this UnityEngine.Component  component)                                  => null != component  ? component .FindDescendantsByComponent   (component.GetType())                                      : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.Component>> .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                      GetDescendants<T>(this UnityEngine.Component  component) where T : UnityEngine.Component  => null != component  ? component .FindDescendantsByComponent<T>()                                                         : Util.Reference<Game.Collections.GameObjectSharedList<T>>                     .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> GetDescendants   (this UnityEngine.GameObject gameObject)                                 => null != gameObject ? gameObject.FindDescendants              ([GameMethod(AggressiveInlining)] static (child) => true) : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                      GetDescendants<T>(this UnityEngine.GameObject gameObject) where T : UnityEngine.Component => null != gameObject ? gameObject.FindDescendants<T>           ([GameMethod(AggressiveInlining)] static (child) => true) : Util.Reference<Game.Collections.GameObjectSharedList<T>>                     .Null;

    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.Component>  GetHierarchy   (this UnityEngine.Component  component)                                  => null != component  ? component .FindHierarchyByComponent   (component.GetType())                                      : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.Component>> .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                      GetHierarchy<T>(this UnityEngine.Component  component) where T : UnityEngine.Component  => null != component  ? component .FindHierarchyByComponent<T>()                                                         : Util.Reference<Game.Collections.GameObjectSharedList<T>>                     .Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<UnityEngine.GameObject> GetHierarchy   (this UnityEngine.GameObject gameObject)                                 => null != gameObject ? gameObject.FindHierarchy              ([GameMethod(AggressiveInlining)] static (child) => true) : Util.Reference<Game.Collections.GameObjectSharedList<UnityEngine.GameObject>>.Null;
    [GameMethod(AggressiveInlining)] public static Game.Collections.GameObjectSharedList<T>                      GetHierarchy<T>(this UnityEngine.GameObject gameObject) where T : UnityEngine.Component => null != gameObject ? gameObject.FindHierarchy<T>           ([GameMethod(AggressiveInlining)] static (child) => true) : Util.Reference<Game.Collections.GameObjectSharedList<T>>                     .Null;

    [GameMethod(AggressiveInlining)] public static UnityEngine.Bounds  GetMeshBounds  (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.MeshFilter>().GetMeshBounds()                                                           : Util.Reference<UnityEngine.Bounds> .Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Bounds  GetMeshBounds  (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.MeshFilter>().GetMeshBounds()                                                           : Util.Reference<UnityEngine.Bounds> .Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Bounds  GetMeshBounds  (this UnityEngine.MeshFilter meshFilter) => null != meshFilter ? new(meshFilter.mesh.bounds.center, UnityEngine.Vector3.Scale(meshFilter.mesh.bounds.size, meshFilter.transform.lossyScale)) : Util.Reference<UnityEngine.Bounds> .Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetMeshCenter  (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.MeshFilter>().GetMeshCenter()                                                           : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetMeshCenter  (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.MeshFilter>().GetMeshCenter()                                                           : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetMeshCenter  (this UnityEngine.MeshFilter meshFilter) => null != meshFilter ? meshFilter.GetMeshBounds().center                                                                                           : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static float               GetMeshHeight  (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.MeshFilter>().GetMeshHeight()                                                           : Util.Reference<float>              .Null;
    [GameMethod(AggressiveInlining)] public static float               GetMeshHeight  (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.MeshFilter>().GetMeshHeight()                                                           : Util.Reference<float>              .Null;
    [GameMethod(AggressiveInlining)] public static float               GetMeshHeight  (this UnityEngine.MeshFilter meshFilter) => meshFilter.GetMeshSize().y;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetMeshPosition(this UnityEngine.Component  component)  => null != component  ? component .transform.GetMeshPosition()                           : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetMeshPosition(this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.transform.GetMeshPosition()                           : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetMeshPosition(this UnityEngine.Transform  transform)  => null != transform  ? transform.position                                               : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetMeshSize    (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.MeshFilter>().GetMeshSize()  : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetMeshSize    (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.MeshFilter>().GetMeshSize()  : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetMeshSize    (this UnityEngine.MeshFilter meshFilter) => null != meshFilter ? meshFilter.GetMeshBounds().size                                  : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static float               GetMeshWidth   (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.MeshFilter>().GetMeshWidth() : Util.Reference<float>              .Null;
    [GameMethod(AggressiveInlining)] public static float               GetMeshWidth   (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.MeshFilter>().GetMeshWidth() : Util.Reference<float>              .Null;
    [GameMethod(AggressiveInlining)] public static float               GetMeshWidth   (this UnityEngine.MeshFilter meshFilter) => meshFilter.GetMeshSize().x;

    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject GetParent(this UnityEngine.Component  component)  => null != component  ? component .transform.GetParent()?.gameObject! : Util.Reference<UnityEngine.GameObject>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject GetParent(this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.transform.GetParent()?.gameObject! : Util.Reference<UnityEngine.GameObject>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Transform  GetParent(this UnityEngine.Transform  transform)  => null != transform  ? transform.parent                              : Util.Reference<UnityEngine.Transform> .Null;

    [GameMethod(AggressiveInlining)] public static System.Uri GetPath(this UnityEngine.Component  component)  => null != component  ? component .transform.GetPath()                                                                                                                                                                                                                                                                        : Util.Reference<System.Uri>.Null;
    [GameMethod(AggressiveInlining)] public static System.Uri GetPath(this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.transform.GetPath()                                                                                                                                                                                                                                                                        : Util.Reference<System.Uri>.Null;
    [GameMethod(AggressiveInlining)] public static System.Uri GetPath(this UnityEngine.Transform  transform)  { string path = string.Empty; if (null != transform) { for (UnityEngine.Transform? subtransform = transform; subtransform is not null; subtransform = subtransform!.GetParent()) { path = subtransform!.name + (!string.IsNullOrEmpty(path) ? '/' + path : string.Empty); } return new(path, System.UriKind.Relative); } return Util.Reference<System.Uri>.Null; }

    [GameMethod(AggressiveInlining)] public static UnityEngine.Rect    GetRect        (this UnityEngine.Component     component,  UnityEngine.Canvas? canvas = null) => null != component  ? new(component .transform.GetRectPosition(canvas), component .transform.GetRectSize(canvas)) : Util.Reference<UnityEngine.Rect>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Rect    GetRect        (this UnityEngine.GameObject    gameObject, UnityEngine.Canvas? canvas = null) => null != gameObject ? new(gameObject.transform.GetRectPosition(canvas), gameObject.transform.GetRectSize(canvas)) : Util.Reference<UnityEngine.Rect>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetRectCenter  (this UnityEngine.Component     component,  UnityEngine.Canvas? canvas = null) => null != component  ? component .transform.GetRectCenter(canvas)                                                  : Util.Reference<UnityEngine.Vector2>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetRectCenter  (this UnityEngine.GameObject    gameObject, UnityEngine.Canvas? canvas = null) => null != gameObject ? gameObject.transform.GetRectCenter(canvas)                                                  : Util.Reference<UnityEngine.Vector2>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetRectCenter  (this UnityEngine.RectTransform transform,  UnityEngine.Canvas? canvas = null) => null != transform  ? transform.GetRectPosition(canvas) + (transform.GetRectSize(canvas) * 0.5f)                  : Util.Reference<UnityEngine.Vector2>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetRectCenter  (this UnityEngine.Transform     transform,  UnityEngine.Canvas? canvas = null) => (transform as UnityEngine.RectTransform)!.GetRectCenter(canvas);
    [GameMethod(AggressiveInlining)] public static float               GetRectHeight  (this UnityEngine.Component     component,  UnityEngine.Canvas? canvas = null) => null != component  ? component .transform.GetRectHeight(canvas) : Util.Reference<float>.Null;
    [GameMethod(AggressiveInlining)] public static float               GetRectHeight  (this UnityEngine.GameObject    gameObject, UnityEngine.Canvas? canvas = null) => null != gameObject ? gameObject.transform.GetRectHeight(canvas) : Util.Reference<float>.Null;
    [GameMethod(AggressiveInlining)] public static float               GetRectHeight  (this UnityEngine.RectTransform transform,  UnityEngine.Canvas? canvas = null) => transform.GetRectSize(canvas).y;
    [GameMethod(AggressiveInlining)] public static float               GetRectHeight  (this UnityEngine.Transform     transform,  UnityEngine.Canvas? canvas = null) => (transform as UnityEngine.RectTransform)!.GetRectHeight(canvas);
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetRectPosition(this UnityEngine.Component     component,  UnityEngine.Canvas? canvas = null) => null != component  ? component .transform.GetRectPosition(canvas)                                                                                                                                         : Util.Reference<UnityEngine.Vector2>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetRectPosition(this UnityEngine.GameObject    gameObject, UnityEngine.Canvas? canvas = null) => null != gameObject ? gameObject.transform.GetRectPosition(canvas)                                                                                                                                         : Util.Reference<UnityEngine.Vector2>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetRectPosition(this UnityEngine.RectTransform transform,  UnityEngine.Canvas? canvas = null) { if (null != transform) { transform.GetWorldCorners(Extensions.GetRectSizeWorldCorners); return (UnityEngine.Vector2) Util.Reference<UnityEngine.Vector3>.First(Extensions.GetRectSizeWorldCorners); } return Util.Reference<UnityEngine.Vector2>.Null; }
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetRectPosition(this UnityEngine.Transform     transform,  UnityEngine.Canvas? canvas = null) => (transform as UnityEngine.RectTransform)!.GetRectPosition(canvas);
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetRectSize    (this UnityEngine.Component     component,  UnityEngine.Canvas? canvas = null) => null != component  ? component .transform.GetRectSize(canvas)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            : Util.Reference<UnityEngine.Vector2>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetRectSize    (this UnityEngine.GameObject    gameObject, UnityEngine.Canvas? canvas = null) => null != gameObject ? gameObject.transform.GetRectSize(canvas)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            : Util.Reference<UnityEngine.Vector2>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetRectSize    (this UnityEngine.RectTransform transform,  UnityEngine.Canvas? canvas = null) { if (null != transform) { if (null != canvas) { return UnityEngine.RectTransformUtility.PixelAdjustRect(transform, canvas).size; } transform.GetWorldCorners(Extensions.GetRectSizeWorldCorners); return new(UnityEngine.Vector3.Distance(Util.Reference<UnityEngine.Vector3>.First(Extensions.GetRectSizeWorldCorners), Util.Reference<UnityEngine.Vector3>.At(Extensions.GetRectSizeWorldCorners, 3u)), UnityEngine.Vector3.Distance(Util.Reference<UnityEngine.Vector3>.First(Extensions.GetRectSizeWorldCorners), Util.Reference<UnityEngine.Vector3>.At(Extensions.GetRectSizeWorldCorners, 1u))); /* ->> `transform.rect.size * (UnityEngine.Vector2) transform.lossyScale` */ } return Util.Reference<UnityEngine.Vector2>.Null; }
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2 GetRectSize    (this UnityEngine.Transform     transform,  UnityEngine.Canvas? canvas = null) => (transform as UnityEngine.RectTransform)!.GetRectSize(canvas);
    [GameMethod(AggressiveInlining)] public static float               GetRectWidth   (this UnityEngine.Component     component,  UnityEngine.Canvas? canvas = null) => null != component  ? component .transform.GetRectWidth(canvas) : Util.Reference<float>.Null;
    [GameMethod(AggressiveInlining)] public static float               GetRectWidth   (this UnityEngine.GameObject    gameObject, UnityEngine.Canvas? canvas = null) => null != gameObject ? gameObject.transform.GetRectWidth(canvas) : Util.Reference<float>.Null;
    [GameMethod(AggressiveInlining)] public static float               GetRectWidth   (this UnityEngine.RectTransform transform,  UnityEngine.Canvas? canvas = null) => transform.GetRectSize(canvas).x;
    [GameMethod(AggressiveInlining)] public static float               GetRectWidth   (this UnityEngine.Transform     transform,  UnityEngine.Canvas? canvas = null) => (transform as UnityEngine.RectTransform)!.GetRectWidth(canvas);

    [GameMethod(AggressiveInlining)] public static UnityEngine.Bounds  GetRenderedBounds  (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.Renderer>().GetRenderedBounds() : Util.Reference<UnityEngine.Bounds> .Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Bounds  GetRenderedBounds  (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.Renderer>().GetRenderedBounds() : Util.Reference<UnityEngine.Bounds> .Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Bounds  GetRenderedBounds  (this UnityEngine.Renderer   renderer)   => null != renderer   ? renderer.bounds                                                     : Util.Reference<UnityEngine.Bounds> .Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetRenderedCenter  (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.Renderer>().GetRenderedCenter() : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetRenderedCenter  (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.Renderer>().GetRenderedCenter() : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetRenderedCenter  (this UnityEngine.Renderer   renderer)   => null != renderer   ? renderer  .GetRenderedBounds().center                               : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static float               GetRenderedHeight  (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.Renderer>().GetRenderedHeight() : Util.Reference<float>              .Null;
    [GameMethod(AggressiveInlining)] public static float               GetRenderedHeight  (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.Renderer>().GetRenderedHeight() : Util.Reference<float>              .Null;
    [GameMethod(AggressiveInlining)] public static float               GetRenderedHeight  (this UnityEngine.Renderer   renderer)   => renderer.GetRenderedSize().y;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetRenderedPosition(this UnityEngine.Component  component)  => null != component  ? component .transform.GetRenderedPosition()                         : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetRenderedPosition(this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.transform.GetRenderedPosition()                         : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetRenderedPosition(this UnityEngine.Transform  transform)  => null != transform  ? transform.position                                                 : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetRenderedSize    (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.Renderer>().GetRenderedSize()  : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetRenderedSize    (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.Renderer>().GetRenderedSize()  : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3 GetRenderedSize    (this UnityEngine.Renderer   renderer)   => null != renderer   ? renderer  .GetRenderedBounds().size                                : Util.Reference<UnityEngine.Vector3>.Null;
    [GameMethod(AggressiveInlining)] public static float               GetRenderedWidth   (this UnityEngine.Component  component)  => null != component  ? component .GetComponent<UnityEngine.Renderer>().GetRenderedWidth() : Util.Reference<float>              .Null;
    [GameMethod(AggressiveInlining)] public static float               GetRenderedWidth   (this UnityEngine.GameObject gameObject) => null != gameObject ? gameObject.GetComponent<UnityEngine.Renderer>().GetRenderedWidth() : Util.Reference<float>              .Null;
    [GameMethod(AggressiveInlining)] public static float               GetRenderedWidth   (this UnityEngine.Renderer   renderer)   => renderer.GetRenderedSize().x;

    [GameMethod(AggressiveInlining)] public static UnityEngine.Texture? GetTexture(this UnityEngine.Component  component)  => (null != component  ? component .GetComponent<UnityEngine.UI.Graphic>()?.GetTexture() : Util.Reference<UnityEngine.Texture?>.Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.Texture? GetTexture(this UnityEngine.GameObject gameObject) => (null != gameObject ? gameObject.GetComponent<UnityEngine.UI.Graphic>()?.GetTexture() : Util.Reference<UnityEngine.Texture?>.Null);
    [GameMethod(AggressiveInlining)] public static UnityEngine.Texture  GetTexture(this UnityEngine.UI.Graphic graphic)    => (null != graphic    ? graphic.mainTexture                                             : Util.Reference<UnityEngine.Texture> .Null);

    [GameMethod(AggressiveInlining)] public static bool HasChild(this UnityEngine.Component  component,  UnityEngine.Component  child)  =>    null != component  ? component.gameObject.HasChild(child)                                                                                                 : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool HasChild(this UnityEngine.Component  component,  UnityEngine.GameObject child)  =>    null != component  ? component.gameObject.HasChild(child)                                                                                                 : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool HasChild(this UnityEngine.GameObject gameObject, UnityEngine.Component  child)  =>    null != gameObject ? gameObject          .HasChild(child.gameObject)                                                                                      : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool HasChild(this UnityEngine.GameObject gameObject, UnityEngine.GameObject target) { if (null != gameObject) { foreach (UnityEngine.GameObject child in gameObject.EnumerateChildren()) { if (child == target) return true; } return false; } return Util.Reference<bool>.Null; }

    [GameMethod(AggressiveInlining)] public static bool HasComponent<T>(this UnityEngine.Component  component) where T : UnityEngine.Component  => null != component  ? component.gameObject.HasComponent<T>()          : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool HasComponent<T>(this UnityEngine.GameObject gameObject) where T : UnityEngine.Component => null != gameObject ? gameObject          .HasComponent   (typeof(T)) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool HasComponent   (this UnityEngine.Component  component,  System.Type type)               => null != component  ? component.gameObject.HasComponent   (type)      : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool HasComponent   (this UnityEngine.GameObject gameObject, System.Type type)               => null != gameObject ? gameObject.GetComponent(type) is not null       : Util.Reference<bool>.Null;

    [GameMethod(AggressiveInlining)] public static bool HasDescendant(this UnityEngine.Component  component,  UnityEngine.Component  child)  => null != component  ? component.gameObject.HasDescendant(child)            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool HasDescendant(this UnityEngine.Component  component,  UnityEngine.GameObject child)  => null != component  ? component.gameObject.HasDescendant(child)            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool HasDescendant(this UnityEngine.GameObject gameObject, UnityEngine.Component  child)  => null != gameObject ? gameObject          .HasDescendant(child.gameObject) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool HasDescendant(this UnityEngine.GameObject gameObject, UnityEngine.GameObject target) { if (null != gameObject) { foreach (UnityEngine.GameObject child in gameObject.EnumerateDescendants()) { if (child == target) return true; } return false; } return Util.Reference<bool>.Null; }

    [GameMethod(AggressiveInlining)] public static int IndexOf   (this System.Array array, object? value)                       => array is not null ? System.Array.IndexOf   (array, value)               : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int IndexOf   (this System.Array array, object? value, int index)            => array is not null ? System.Array.IndexOf   (array, value, index)        : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int IndexOf   (this System.Array array, object? value, int index, int count) => array is not null ? System.Array.IndexOf   (array, value, index, count) : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int IndexOf<T>(this T[]          array, T       value)                       => array is not null ? System.Array.IndexOf<T>(array, value)               : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int IndexOf<T>(this T[]          array, T       value, int index)            => array is not null ? System.Array.IndexOf<T>(array, value, index)        : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int IndexOf<T>(this T[]          array, T       value, int index, int count) => array is not null ? System.Array.IndexOf<T>(array, value, index, count) : Util.Reference<int>.Null;

    [GameMethod(AggressiveInlining)] public static bool IsAncestor(this UnityEngine.Component  component,  UnityEngine.Component  ancestor) => null != component  ? component .transform.IsAncestor(ancestor) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsAncestor(this UnityEngine.Component  component,  UnityEngine.GameObject ancestor) => null != component  ? component .transform.IsAncestor(ancestor) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsAncestor(this UnityEngine.GameObject gameObject, UnityEngine.Component  ancestor) => null != gameObject ? gameObject.transform.IsAncestor(ancestor) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsAncestor(this UnityEngine.GameObject gameObject, UnityEngine.GameObject ancestor) => null != gameObject ? gameObject.transform.IsAncestor(ancestor) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsAncestor(this UnityEngine.Transform  transform,  UnityEngine.Component  ancestor) => transform.IsAncestor(ancestor.transform);
    [GameMethod(AggressiveInlining)] public static bool IsAncestor(this UnityEngine.Transform  transform,  UnityEngine.GameObject ancestor) => transform.IsAncestor(ancestor.transform);
    [GameMethod(AggressiveInlining)] public static bool IsAncestor(this UnityEngine.Transform  transform,  UnityEngine.Transform  ancestor) => null != transform ? transform.IsChildOf(ancestor) : Util.Reference<bool>.Null;

    [GameMethod(AggressiveInlining)] public static bool IsChild(this UnityEngine.Component  component,  UnityEngine.Component  child) => null != component  ? component .transform.IsChild(child) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsChild(this UnityEngine.Component  component,  UnityEngine.GameObject child) => null != component  ? component .transform.IsChild(child) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsChild(this UnityEngine.GameObject gameObject, UnityEngine.Component  child) => null != gameObject ? gameObject.transform.IsChild(child) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsChild(this UnityEngine.GameObject gameObject, UnityEngine.GameObject child) => null != gameObject ? gameObject.transform.IsChild(child) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsChild(this UnityEngine.Transform  transform,  UnityEngine.Component  child) => transform.IsChild(child.transform);
    [GameMethod(AggressiveInlining)] public static bool IsChild(this UnityEngine.Transform  transform,  UnityEngine.GameObject child) => transform.IsChild(child.transform);
    [GameMethod(AggressiveInlining)] public static bool IsChild(this UnityEngine.Transform  transform,  UnityEngine.Transform  child) => null != transform ? child.parent == transform : Util.Reference<bool>.Null;

    [GameMethod(AggressiveInlining)] public static bool IsDescendant(this UnityEngine.Component  component,  UnityEngine.Component  descendant) => null != component  ? component .transform.IsDescendant(descendant) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsDescendant(this UnityEngine.Component  component,  UnityEngine.GameObject descendant) => null != component  ? component .transform.IsDescendant(descendant) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsDescendant(this UnityEngine.GameObject gameObject, UnityEngine.Component  descendant) => null != gameObject ? gameObject.transform.IsDescendant(descendant) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsDescendant(this UnityEngine.GameObject gameObject, UnityEngine.GameObject descendant) => null != gameObject ? gameObject.transform.IsDescendant(descendant) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsDescendant(this UnityEngine.Transform  transform,  UnityEngine.Component  descendant) => transform.IsDescendant(descendant.transform);
    [GameMethod(AggressiveInlining)] public static bool IsDescendant(this UnityEngine.Transform  transform,  UnityEngine.GameObject descendant) => transform.IsDescendant(descendant.transform);
    [GameMethod(AggressiveInlining)] public static bool IsDescendant(this UnityEngine.Transform  transform,  UnityEngine.Transform  descendant) => null != transform ? descendant.IsChildOf(transform) : Util.Reference<bool>.Null;

    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    string                                                                    value)            => value is not null ? 0 == value.Length : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    T[]                                                                       array)            => array is not null ? 0 == array.Length : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (in this UnityEngine.InputSystem.Utilities.ReadOnlyArray<T>                        array)            => 0 == array.Count;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    UnityEngine.InputSystem.Utilities.ReadOnlyArray<T>?                       array)            => array is not null ? ((UnityEngine.InputSystem.Utilities.ReadOnlyArray<T>) array).IsEmpty() : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Array                                                              array)            => array is not null ? 0 == array.Length                                                      : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (in this System.ArraySegment<T>                                                    arraySegment)     => 0 == arraySegment.Count;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    System.ArraySegment<T>?                                                   arraySegment)     => arraySegment     is not null ? ((System.ArraySegment<T>) arraySegment).IsEmpty() : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Collections.ArrayList                                              arrayList)        => arrayList        is not null ? 0 == arrayList       .Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Collections.BitArray                                               bits)             => bits             is not null ? 0 == bits            .Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Collections.Queue                                                  queue)            => queue            is not null ? 0 == queue           .Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<TKey, TValue>(this    System.Collections.Generic.Dictionary      <TKey, TValue>                 dictionary)       => dictionary       is not null ? 0 == dictionary      .Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    System.Collections.Generic.HashSet         <T>                            hashset)          => hashset          is not null ? 0 == hashset         .Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    System.Collections.Generic.ICollection     <T>                            collection)       => collection       is not null ? 0 == collection      .Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    System.Collections.Generic.LinkedList      <T>                            list)             => list             is not null ? 0 == list            .Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    System.Collections.Generic.List            <T>                            list)             => list             is not null ? 0 == list            .Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    System.Collections.Generic.Queue           <T>                            queue)            => queue            is not null ? 0 == queue           .Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<TKey, TValue>(this    System.Collections.Generic.SortedDictionary<TKey, TValue>                 sortedDictionary) => sortedDictionary is not null ? 0 == sortedDictionary.Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<TKey, TValue>(this    System.Collections.Generic.SortedList      <TKey, TValue>                 sortedList)       => sortedList       is not null ? 0 == sortedList      .Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    System.Collections.Generic.SortedSet       <T>                            sortedSet)        => sortedSet        is not null ? 0 == sortedSet       .Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    System.Collections.Generic.Stack           <T>                            stack)            => stack            is not null ? 0 == stack           .Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Collections.Hashtable                                              hashtable)        => hashtable        is not null ? 0 == hashtable       .Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Collections.ICollection                                            collection)       => collection       is not null ? 0 == collection      .Count                       : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Collections.IEnumerable                                            enumerable)       => enumerable       is not null ? Util.Enumerable.IsEmpty(enumerable)               : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    System.Collections.ObjectModel.Collection                  <T>            collection)       => collection       is not null ? 0  == collection.Count                            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    System.Collections.ObjectModel.ObservableCollection        <T>            collection)       => collection       is not null ? 0  == collection.Count                            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    System.Collections.ObjectModel.ReadOnlyCollection          <T>            collection)       => collection       is not null ? 0  == collection.Count                            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<TKey, TValue>(this    System.Collections.ObjectModel.ReadOnlyDictionary          <TKey, TValue> dictionary)       => dictionary       is not null ? 0  == dictionary.Count                            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    System.Collections.ObjectModel.ReadOnlyObservableCollection<T>            collection)       => collection       is not null ? 0  == collection.Count                            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Collections.SortedList                                             sortedList)       => sortedList       is not null ? 0  == sortedList.Count                            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Collections.Specialized.HybridDictionary                           dictionary)       => dictionary       is not null ? 0  == dictionary.Count                            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Collections.Specialized.ListDictionary                             dictionary)       => dictionary       is not null ? 0  == dictionary.Count                            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Collections.Specialized.NameValueCollection                        collection)       => collection       is not null ? 0  == collection.Count                            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Collections.Specialized.OrderedDictionary                          dictionary)       => dictionary       is not null ? 0  == dictionary.Count                            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Collections.Specialized.StringCollection                           collection)       => collection       is not null ? 0  == collection.Count                            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Collections.Specialized.StringDictionary                           dictionary)       => dictionary       is not null ? 0  == dictionary.Count                            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.Collections.Stack                                                  stack)            => stack            is not null ? 0  == stack     .Count                            : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty              (this    System.IO.Stream                                                          stream)           => stream           is not null ? 0L == stream    .Length                           : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (in this System.Memory        <T>                                                  memory)           => 0 == memory.Length;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    System.Memory        <T>?                                                 memory)           => memory is not null ? ((System.Memory<T>) memory).IsEmpty() : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (in this System.ReadOnlyMemory<T>                                                  memory)           => 0 == memory.Length;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (this    System.ReadOnlyMemory<T>?                                                 memory)           => memory is not null ? ((System.ReadOnlyMemory<T>) memory).IsEmpty() : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (in this System.ReadOnlySpan  <T>                                                  span)             => 0 == span.Length;
    [GameMethod(AggressiveInlining)] public static bool IsEmpty<T>           (in this System.Span          <T>                                                  span)             => 0 == span.Length;
    #if NET9_0 || NET9_0_OR_GREATER
      [GameMethod(AggressiveInlining)]
      public static bool IsEmpty<T>(this System.Collections.ObjectModel.ReadOnlySet<T> set) => set is not null ? 0 == set.Count : Util.Reference<bool>.Null;
    #endif

    [GameMethod(AggressiveInlining)] public static bool IsParent(this UnityEngine.Component  component,  UnityEngine.Component  parent) => null != component  ? component .transform.IsParent(parent) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsParent(this UnityEngine.Component  component,  UnityEngine.GameObject parent) => null != component  ? component .transform.IsParent(parent) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsParent(this UnityEngine.GameObject gameObject, UnityEngine.Component  parent) => null != gameObject ? gameObject.transform.IsParent(parent) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsParent(this UnityEngine.GameObject gameObject, UnityEngine.GameObject parent) => null != gameObject ? gameObject.transform.IsParent(parent) : Util.Reference<bool>.Null;
    [GameMethod(AggressiveInlining)] public static bool IsParent(this UnityEngine.Transform  transform,  UnityEngine.Component  parent) => transform.IsParent(parent.transform);
    [GameMethod(AggressiveInlining)] public static bool IsParent(this UnityEngine.Transform  transform,  UnityEngine.GameObject parent) => transform.IsParent(parent.transform);
    [GameMethod(AggressiveInlining)] public static bool IsParent(this UnityEngine.Transform  transform,  UnityEngine.Transform  parent) => null != transform ? parent == transform.parent : Util.Reference<bool>.Null;

    [GameMethod(AggressiveInlining)] public static int LastIndexOf   (this System.Array array, object? value)                       => array is not null ? System.Array.LastIndexOf   (array, value)               : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int LastIndexOf   (this System.Array array, object? value, int index)            => array is not null ? System.Array.LastIndexOf   (array, value, index)        : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int LastIndexOf   (this System.Array array, object? value, int index, int count) => array is not null ? System.Array.LastIndexOf   (array, value, index, count) : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int LastIndexOf<T>(this T[]          array, T       value)                       => array is not null ? System.Array.LastIndexOf<T>(array, value)               : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int LastIndexOf<T>(this T[]          array, T       value, int index)            => array is not null ? System.Array.LastIndexOf<T>(array, value, index)        : Util.Reference<int>.Null;
    [GameMethod(AggressiveInlining)] public static int LastIndexOf<T>(this T[]          array, T       value, int index, int count) => array is not null ? System.Array.LastIndexOf<T>(array, value, index, count) : Util.Reference<int>.Null;

    [GameMethod(AggressiveInlining)]
    public static bool NextBoolean(this System.Random random, double probability = 0.5) => random is not null ? random.NextDouble() < probability : Util.Reference<bool>.Null;

    [GameMethod(AggressiveInlining)] public static ref readonly object? Prepend   (this System.Collections.ArrayList             arrayList, in object? value) { if (arrayList is not null) { arrayList.Insert  (0, value); return ref value; } return ref Util.Reference<object?>.Null; }
    [GameMethod(AggressiveInlining)] public static ref readonly T       Prepend<T>(this System.Collections.ArrayList             arrayList, in T       value) { if (arrayList is not null) { arrayList.Insert  (0, value); return ref value; } return ref Util.Reference<T>      .Null; }
    [GameMethod(AggressiveInlining)] public static ref readonly T       Prepend<T>(this System.Collections.Generic.LinkedList<T> list,      in T       value) { if (list      is not null) { list     .AddFirst(value);    return ref value; } return ref Util.Reference<T>      .Null; }
    [GameMethod(AggressiveInlining)] public static ref readonly T       Prepend<T>(this System.Collections.Generic.List      <T> list,      in T       value) { if (list      is not null) { list     .Insert  (0, value); return ref value; } return ref Util.Reference<T>      .Null; }

    public static void PreserveFromSceneLoad(this UnityEngine.Component  component) { if (null != component) component.gameObject.PreserveFromSceneLoad(); }
    public static void PreserveFromSceneLoad(this UnityEngine.GameObject gameObject) {
      #if !UNITY_EDITOR
        if (null != gameObject) // ->> `!UnityEditor.SceneVisibilityManager.instance.IsHidden(gameObject)`
        UnityEngine.Object.DontDestroyOnLoad(gameObject);
      #endif
    }

    [GameMethod(AggressiveInlining)] public static char           Random              (this    string                                                         value)            =>     (value is not null && !value.IsEmpty() ? value[(int) Util.RandomUInt((uint) value.Length)]                     :     Util.Reference<char>.Null);
    [GameMethod(AggressiveInlining)] public static ref T          Random<T>           (this    T[]                                                            array)            => ref (array is not null && !array.IsEmpty() ? ref Util.Reference<T>.At(array, Util.RandomUInt((uint) array.Length)) : ref Util.Reference<T>   .Null);
    [GameMethod(AggressiveInlining)] public static T              Random<T>           (in this UnityEngine.InputSystem.Utilities.ReadOnlyArray<T>             array)            =>     (array[(int) Util.RandomUInt((uint) array.Count)]);
    [GameMethod(AggressiveInlining)] public static T              Random<T>           (this    UnityEngine.InputSystem.Utilities.ReadOnlyArray<T>?            array)            =>     (array is not null && !array.IsEmpty() ? ((UnityEngine.InputSystem.Utilities.ReadOnlyArray<T>) array).Random() : Util.Reference<T>      .Null);
    [GameMethod(AggressiveInlining)] public static object?        Random              (this    System.Array                                                   array)            =>     (array is not null && !array.IsEmpty() ? array.GetValue((int) Util.RandomUInt((uint) array.Length))            : Util.Reference<object?>.Null);
    [GameMethod(AggressiveInlining)] public static T              Random<T>           (in this System.ArraySegment<T>                                         arraySegment)     =>     (arraySegment[(int) Util.RandomUInt((uint) arraySegment.Count)]);
    [GameMethod(AggressiveInlining)] public static T              Random<T>           (this    System.ArraySegment<T>?                                        arraySegment)     =>     (arraySegment     is not null && !arraySegment.IsEmpty() ? ((System.ArraySegment<T>) arraySegment).Random()                                                                                                                                                                              : Util.Reference<T>      .Null);
    [GameMethod(AggressiveInlining)] public static object?        Random              (this    System.Collections.ArrayList                                   arrayList)        =>     (arrayList        is not null && !arrayList   .IsEmpty() ? arrayList[(int) Util.RandomUInt((uint) arrayList.Count)]                                                                                                                                                                      : Util.Reference<object?>.Null);
    [GameMethod(AggressiveInlining)] public static bool           Random              (this    System.Collections.BitArray                                    bits)             =>     (bits             is not null && !bits        .IsEmpty() ? bits     [(int) Util.RandomUInt((uint) bits     .Count)]                                                                                                                                                                      : Util.Reference<bool>   .Null);
    [GameMethod(AggressiveInlining)] public static T              Random<T>           (this    System.Collections.Generic.IEnumerable<T>                      enumerable)       { if   (enumerable       is not null && !enumerable  .IsEmpty()) { using (System.Collections.Generic.IEnumerator<T> enumerator = enumerable.GetEnumerator()) while (true) { while (enumerator.MoveNext()) { if (Util.RandomBoolean()) return enumerator.Current; } enumerator.Reset(); } } return Util.Reference<T>      .Null; }
    [GameMethod(AggressiveInlining)] public static T              Random<T>           (this    System.Collections.Generic.List       <T>                      list)             =>     (list             is not null && !list        .IsEmpty() ? list             [(int) Util.RandomUInt((uint) list      .Count)]                                                                                                                                                             : Util.Reference<T>      .Null);
    [GameMethod(AggressiveInlining)] public static TValue         Random<TKey, TValue>(this    System.Collections.Generic.SortedList <TKey, TValue>           sortedList)       =>     (sortedList       is not null && !sortedList  .IsEmpty() ? sortedList.Values[(int) Util.RandomUInt((uint) sortedList.Count)]                                                                                                                                                             : Util.Reference<TValue> .Null); // ->> `sortedList.GetValueAtIndex(…)`
    [GameMethod(AggressiveInlining)] public static object?        Random              (this    System.Collections.IEnumerable                                 enumerable)       { if   (enumerable       is not null && !enumerable  .IsEmpty()) { for (System.Collections.IEnumerator enumerator = enumerable.GetEnumerator(); ; enumerator.Reset()) while (enumerator.MoveNext()) if (Util.RandomBoolean()) return enumerator.Current; } return                                 Util.Reference<object?>.Null; }
    [GameMethod(AggressiveInlining)] public static T              Random<T>           (this    System.Collections.ObjectModel.Collection                  <T> collection)       =>     (collection       is not null && !collection  .IsEmpty() ? collection[(int) Util.RandomUInt((uint) collection.Count)]                   : Util.Reference<T>      .Null);
    [GameMethod(AggressiveInlining)] public static T              Random<T>           (this    System.Collections.ObjectModel.ObservableCollection        <T> collection)       =>     (collection       is not null && !collection  .IsEmpty() ? ((System.Collections.ObjectModel.Collection<T>) collection).Random()         : Util.Reference<T>      .Null);
    [GameMethod(AggressiveInlining)] public static T              Random<T>           (this    System.Collections.ObjectModel.ReadOnlyCollection          <T> collection)       =>     (collection       is not null && !collection  .IsEmpty() ? collection[(int) Util.RandomUInt((uint) collection.Count)]                   : Util.Reference<T>      .Null);
    [GameMethod(AggressiveInlining)] public static T              Random<T>           (this    System.Collections.ObjectModel.ReadOnlyObservableCollection<T> collection)       =>     (collection       is not null && !collection  .IsEmpty() ? ((System.Collections.ObjectModel.ReadOnlyCollection<T>) collection).Random() : Util.Reference<T>      .Null);
    [GameMethod(AggressiveInlining)] public static object?        Random              (this    System.Collections.SortedList                                  sortedList)       =>     (sortedList       is not null && !sortedList  .IsEmpty() ? sortedList.GetByIndex((int) Util.RandomUInt((uint) sortedList.Count))        : Util.Reference<object?>.Null);
    [GameMethod(AggressiveInlining)] public static byte           Random              (this    System.IO.MemoryStream                                         stream)           =>     (stream           is not null && !stream      .IsEmpty() ? Util.Array.From(stream).Random()                                             : Util.Reference<byte>   .Null);
    [GameMethod(AggressiveInlining)] public static T              Random<T>           (in this System.Memory        <T>                                       memory)           =>     (memory.Span.Random());
    [GameMethod(AggressiveInlining)] public static T              Random<T>           (this    System.Memory        <T>?                                      memory)           =>     (memory is not null ? ((System.Memory<T>) memory).Random() : Util.Reference<T>.Null);
    [GameMethod(AggressiveInlining)] public static T              Random<T>           (in this System.ReadOnlyMemory<T>                                       memory)           =>     (memory.Span.Random());
    [GameMethod(AggressiveInlining)] public static T              Random<T>           (this    System.ReadOnlyMemory<T>?                                      memory)           =>     (memory is not null ? ((System.ReadOnlyMemory<T>) memory).Random() : Util.Reference<T>.Null);
    [GameMethod(AggressiveInlining)] public static ref readonly T Random<T>           (in this System.ReadOnlySpan  <T>                                       span)             => ref (Util.Reference<T>.At(in span, (int) Util.RandomUInt((uint) span.Length)));
    [GameMethod(AggressiveInlining)] public static ref          T Random<T>           (in this System.Span          <T>                                       span)             => ref (Util.Reference<T>.At(in span, (int) Util.RandomUInt((uint) span.Length)));

    [GameMethod(AggressiveInlining)] public static bool RemoveComponent   (this UnityEngine.Component  component)                                  { if (null != component) { UnityEngine.Object.DestroyImmediate(component, true); return true; } return false; }
    [GameMethod(AggressiveInlining)] public static bool RemoveComponent<T>(this UnityEngine.Component  component)  where T : UnityEngine.Component => component .RemoveComponent(typeof(T));
    [GameMethod(AggressiveInlining)] public static bool RemoveComponent<T>(this UnityEngine.GameObject gameObject) where T : UnityEngine.Component => gameObject.RemoveComponent(typeof(T));
    [GameMethod(AggressiveInlining)] public static bool RemoveComponent   (this UnityEngine.Component  component,  System.Type type)               => null != component  && component .GetComponent(type).RemoveComponent();
    [GameMethod(AggressiveInlining)] public static bool RemoveComponent   (this UnityEngine.GameObject gameObject, System.Type type)               => null != gameObject && gameObject.GetComponent(type).RemoveComponent();

    [GameMethod(AggressiveInlining)]
    public static void Reset(this UnityEngine.Transform transform) {
      if (null != transform) {
        transform.localRotation = UnityEngine.Quaternion.identity;
        transform.localScale    = UnityEngine.Vector3   .one;
        transform.position      = UnityEngine.Vector3   .zero;
      }
    }

    [GameMethod(AggressiveInlining)] public static void Reverse   (this System.Array array)                        { if (array is not null) System.Array.Reverse(array); }
    [GameMethod(AggressiveInlining)] public static void Reverse   (this System.Array array, int index, int length) { if (array is not null) System.Array.Reverse(array, index, length); }
    [GameMethod(AggressiveInlining)] public static void Reverse<T>(this T[]          array)                        { if (array is not null) ((System.Array) array).Reverse(0, array.Length); }
    [GameMethod(AggressiveInlining)] public static void Reverse<T>(this T[]          array, int index, int length) { if (array is not null) ((System.Array) array).Reverse(index, length); }

    [GameMethod(AggressiveInlining)] public static void SetAlpha(this UnityEngine.Component  component,  float alpha) { if (null != component)  component .GetComponent<UnityEngine.UI.Graphic>()?.SetAlpha(alpha); }
    [GameMethod(AggressiveInlining)] public static void SetAlpha(this UnityEngine.GameObject gameObject, float alpha) { if (null != gameObject) gameObject.GetComponent<UnityEngine.UI.Graphic>()?.SetAlpha(alpha); }
    [GameMethod(AggressiveInlining)] public static void SetAlpha(this UnityEngine.UI.Graphic graphic,    float alpha) { if (null != graphic)    graphic.color = new(graphic.color.r, graphic.color.g, graphic.color.b, alpha); }
    [GameMethod(AggressiveInlining)] public static void SetAlpha(this TMPro.TextMeshProUGUI  text,       float alpha) { if (null != text)       text   .alpha = alpha; }

    [GameMethod(AggressiveInlining)] public static void SetAnchoredPosition(this UnityEngine.Component     component,  in UnityEngine.Vector2 position, bool fallback = false) { if (null != component)  component .transform.SetAnchoredPosition(in position, fallback); }
    [GameMethod(AggressiveInlining)] public static void SetAnchoredPosition(this UnityEngine.GameObject    gameObject, in UnityEngine.Vector2 position, bool fallback = false) { if (null != gameObject) gameObject.transform.SetAnchoredPosition(in position, fallback); }
    [GameMethod(AggressiveInlining)] public static void SetAnchoredPosition(this UnityEngine.RectTransform transform,  in UnityEngine.Vector2 position, bool fallback = false) { if (null != transform)  transform.anchoredPosition = position; }
    [GameMethod(AggressiveInlining)] public static void SetAnchoredPosition(this UnityEngine.Transform     transform,  in UnityEngine.Vector2 position, bool fallback = false) { if (null != transform) { if (transform is UnityEngine.RectTransform rectTransform) rectTransform.SetAnchoredPosition(in position, fallback); else if (fallback) transform.localPosition = (UnityEngine.Vector3) position; } }

    [GameMethod(AggressiveInlining)] public static void SetColor(this UnityEngine.Component  component,  in UnityEngine.Color color) { if (null != component)  component .GetComponent<UnityEngine.UI.Graphic>()?.SetColor(in color); }
    [GameMethod(AggressiveInlining)] public static void SetColor(this UnityEngine.GameObject gameObject, in UnityEngine.Color color) { if (null != gameObject) gameObject.GetComponent<UnityEngine.UI.Graphic>()?.SetColor(in color); }
    [GameMethod(AggressiveInlining)] public static void SetColor(this UnityEngine.UI.Graphic graphic,    in UnityEngine.Color color) { if (null != graphic)    graphic.color = color; }

    [GameMethod(AggressiveInlining)] public static void SetMaterialColor(this UnityEngine.Component  component,  in UnityEngine.Color color) { if (null != component)  component .GetComponent<UnityEngine.Renderer>()?.SetMaterialColor(in color); }
    [GameMethod(AggressiveInlining)] public static void SetMaterialColor(this UnityEngine.GameObject gameObject, in UnityEngine.Color color) { if (null != gameObject) gameObject.GetComponent<UnityEngine.Renderer>()?.SetMaterialColor(in color); }
    [GameMethod(AggressiveInlining)] public static void SetMaterialColor(this UnityEngine.Renderer   renderer,   in UnityEngine.Color color) { if (null != renderer)   renderer.material.color = color; }

    [GameMethod(AggressiveInlining)] public static void SetRectHeight(this UnityEngine.Component     component,  float                  height) { if (null != component) component.transform.SetRectHeight(height); }
    [GameMethod(AggressiveInlining)] public static void SetRectHeight(this UnityEngine.GameObject    gameObject, float                  height) { if (null != gameObject) gameObject.transform.SetRectHeight(height); }
    [GameMethod(AggressiveInlining)] public static void SetRectHeight(this UnityEngine.RectTransform transform,  float                  height) { if (null != transform) { UnityEngine.RectTransform? parentTransform = transform.parent?.transform as UnityEngine.RectTransform; transform.sizeDelta = new(transform.sizeDelta.x, height - (parentTransform is not null ? parentTransform.rect.height * (transform.anchorMax.y - transform.anchorMin.y) : 0.0f)); } }
    [GameMethod(AggressiveInlining)] public static void SetRectHeight(this UnityEngine.Transform     transform,  float                  height) { if (null != transform) (transform as UnityEngine.RectTransform)?.SetRectHeight(height); }
    [GameMethod(AggressiveInlining)] public static void SetRectSize  (this UnityEngine.Component     component,  in UnityEngine.Vector2 size)   { if (null != component) component.transform.SetRectSize(size); }
    [GameMethod(AggressiveInlining)] public static void SetRectSize  (this UnityEngine.GameObject    gameObject, in UnityEngine.Vector2 size)   { if (null != gameObject) gameObject.transform.SetRectSize(size); }
    [GameMethod(AggressiveInlining)] public static void SetRectSize  (this UnityEngine.RectTransform transform,  in UnityEngine.Vector2 size)   { if (null != transform) { UnityEngine.RectTransform? parentTransform = transform.parent?.transform as UnityEngine.RectTransform; transform.sizeDelta = size - (parentTransform is not null ? UnityEngine.Vector2.Scale(parentTransform.rect.size, transform.anchorMax - transform.anchorMin) : UnityEngine.Vector2.zero); } }
    [GameMethod(AggressiveInlining)] public static void SetRectSize  (this UnityEngine.Transform     transform,  in UnityEngine.Vector2 size)   { if (null != transform) (transform as UnityEngine.RectTransform)?.SetRectSize(size); }
    [GameMethod(AggressiveInlining)] public static void SetRectWidth (this UnityEngine.Component     component,  float                  width)  { if (null != component) component.transform.SetRectWidth(width); }
    [GameMethod(AggressiveInlining)] public static void SetRectWidth (this UnityEngine.GameObject    gameObject, float                  width)  { if (null != gameObject) gameObject.transform.SetRectWidth(width); }
    [GameMethod(AggressiveInlining)] public static void SetRectWidth (this UnityEngine.RectTransform transform,  float                  width)  { if (null != transform) { UnityEngine.RectTransform? parentTransform = transform.parent?.transform as UnityEngine.RectTransform; transform.sizeDelta = new(width - (parentTransform is not null ? parentTransform.rect.width * (transform.anchorMax.x - transform.anchorMin.x) : 0.0f), transform.sizeDelta.y); } }
    [GameMethod(AggressiveInlining)] public static void SetRectWidth (this UnityEngine.Transform     transform,  float                  width)  { if (null != transform) (transform as UnityEngine.RectTransform)?.SetRectWidth(width); }

    [GameMethod(AggressiveInlining)] public static void SetTexture(this UnityEngine.Component   component,  UnityEngine.Texture   texture) { if (null != component)  { component .GetComponent<UnityEngine.UI.RawImage>()?.SetTexture(texture); if (texture is UnityEngine.Texture2D texture2D) component .GetComponent<UnityEngine.UI.Image>()?.SetTexture(texture2D); } } // ->> Ignore `UnityEngine.Cubemap`, `UnityEngine.CubemapArray`, `UnityEngine.RenderTexture`, `UnityEngine.Texture2DArray`, and `UnityEngine.Texture3D` for now
    [GameMethod(AggressiveInlining)] public static void SetTexture(this UnityEngine.GameObject  gameObject, UnityEngine.Texture   texture) { if (null != gameObject) { gameObject.GetComponent<UnityEngine.UI.RawImage>()?.SetTexture(texture); if (texture is UnityEngine.Texture2D texture2D) gameObject.GetComponent<UnityEngine.UI.Image>()?.SetTexture(texture2D); } } //    ^^
    [GameMethod(AggressiveInlining)] public static void SetTexture(this UnityEngine.UI.Image    image,      UnityEngine.Texture2D texture) { if (null != image) { UnityEngine.Sprite sprite = image.sprite; if (sprite.texture != texture) { image.sprite  = UnityEngine.Sprite.Create(texture, new(0.0f, 0.0f, texture.width, texture.height), new(0.5f, 0.5f)); UnityEngine.Object.Destroy(sprite); } } }
    [GameMethod(AggressiveInlining)] public static void SetTexture(this UnityEngine.UI.RawImage image,      UnityEngine.Texture   texture) { if (null != image) {                                           if (image .texture != texture)   image.texture = texture; } }

    [GameMethod(AggressiveInlining)] public static void Sort   (this System.Array array)                                                                                                                { if (array is not null) System.Array.Sort   (array); }
    [GameMethod(AggressiveInlining)] public static void Sort   (this System.Array array, System.Collections.IComparer? comparer)                                                                        { if (array is not null) System.Array.Sort   (array, comparer); }
    [GameMethod(AggressiveInlining)] public static void Sort   (this System.Array array, int                           index, int length)                                                               { if (array is not null) System.Array.Sort   (array, index, length); }
    [GameMethod(AggressiveInlining)] public static void Sort   (this System.Array array, int                           index, int length, System.Collections.IComparer? comparer)                       { if (array is not null) System.Array.Sort   (array, index, length, comparer); }
    [GameMethod(AggressiveInlining)] public static void Sort<T>(this T[]          array)                                                                                                                { if (array is not null) System.Array.Sort<T>(array); }
    [GameMethod(AggressiveInlining)] public static void Sort<T>(this T[]          array, System.Comparison<T>                     comparison)                                                           { if (array is not null) System.Array.Sort<T>(array, comparison); }
    [GameMethod(AggressiveInlining)] public static void Sort<T>(this T[]          array, System.Collections.Generic.IComparer<T>? comparer)                                                             { if (array is not null) System.Array.Sort<T>(array, comparer); }
    [GameMethod(AggressiveInlining)] public static void Sort<T>(this T[]          array, int                                      index, int length)                                                    { if (array is not null) System.Array.Sort<T>(array, index, length); }
    [GameMethod(AggressiveInlining)] public static void Sort<T>(this T[]          array, int                                      index, int length, System.Collections.Generic.IComparer<T>? comparer) { if (array is not null) System.Array.Sort<T>(array, index, length, comparer); }

    [GameMethod(AggressiveInlining)] public static void TrimExcess<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> dictionary)               { if (dictionary is not null) dictionary.TrimExcess(dictionary.Count); }
    [GameMethod(AggressiveInlining)] public static void TrimExcess<T>           (this System.Collections.Generic.IList      <T>            list)                     { if (list       is not null) list      .TrimExcess(list      .Count); }
    [GameMethod(AggressiveInlining)] public static void TrimExcess<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> dictionary, int capacity) { if (dictionary is not null) switch (dictionary) { case Game.Collections.RefDictionary<TKey, TValue> subdictionary: subdictionary.TrimExcess((uint) capacity); break; case System.Collections.Generic.Dictionary<TKey, TValue> subdictionary: subdictionary.TrimExcess(capacity);        break; } }
    [GameMethod(AggressiveInlining)] public static void TrimExcess<T>           (this System.Collections.Generic.IList      <T>            list,       int capacity) { if (list       is not null) switch (list)       { case Game.Collections.RefList      <T>            sublist:       sublist      .TrimExcess((uint) capacity); break; case Game.Collections.SharedList  <T>            sublist:       sublist      .TrimExcess((uint) capacity); break; case System.Collections.Generic.List<T> sublist: sublist.Capacity = capacity; break; } }

    [GameMethod(AggressiveInlining)]
    public static bool TrueForAll<T>(this T[] array, System.Predicate<T> predicate) {
      return array is not null ? System.Array.TrueForAll<T>(array, predicate) : Util.Reference<bool>.Null;
    }

    [GameMethod(AggressiveInlining)] public static bool TryAdd   <T>(this System.Collections.Generic.IList<T> list, in T element) { if (list is not null) {                                    if (!list.Contains(element)) { list.Add(element); return true; }    return false; }       return Util.Reference<bool>.Null; }
    [GameMethod(AggressiveInlining)] public static T    TryAppend<T>(this System.Collections.Generic.IList<T> list, in T element) { if (list is not null) { int index = list.IndexOf(element); if (index == -1)             { list.Add(element); return element; } return list[index]; } return Util.Reference<T>   .Null; }

    [GameMethod(AggressiveInlining)] public static bool   TryAdd   <TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> dictionary, System.Collections.Generic.KeyValuePair<TKey, TValue> element)              => dictionary is not null ?  dictionary.TryAdd     (element.Key, element.Value)                                    : Util.Reference<bool>  .Null;
    [GameMethod(AggressiveInlining)] public static bool   TryAdd   <TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> dictionary, in TKey                                               key, in TValue value) => dictionary is not null ? !dictionary.ContainsKey(key) && ((dictionary[key] = value), _: true)._                 : Util.Reference<bool>  .Null;
    [GameMethod(AggressiveInlining)] public static TValue TryAppend<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> dictionary, System.Collections.Generic.KeyValuePair<TKey, TValue> element)              => dictionary is not null ?  dictionary.TryAppend  (element.Key, element.Value)                                    : Util.Reference<TValue>.Null;
    [GameMethod(AggressiveInlining)] public static TValue TryAppend<TKey, TValue>(this System.Collections.Generic.IDictionary<TKey, TValue> dictionary, in TKey                                               key, in TValue value) => dictionary is not null ? !dictionary.TryGetValue(key, out TValue prevalue) ? dictionary[key] = value : prevalue : Util.Reference<TValue>.Null;

    #if !(NETCOREAPP2_1 || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1 || NETSTANDARD2_1_OR_GREATER)
      [GameMethod(AggressiveInlining)] public static void TrimExcess<TKey, TValue>(this System.Collections.Generic.Dictionary<TKey, TValue> dictionary)               { /* ->> Do nothing… */ }
      [GameMethod(AggressiveInlining)] public static void TrimExcess<TKey, TValue>(this System.Collections.Generic.Dictionary<TKey, TValue> dictionary, int capacity) { /* ->> Do nothing… */ }
    #endif
  }

  public static class Traits /* ->> Metaprogramming generics */ {
    private static class TypeInfo<T> {
      public static readonly bool IsConstructibleType = Traits.IsConstructibleType(typeof(T));
      public static readonly bool IsPrimitiveType     = Traits.IsPrimitiveType    (typeof(T));
      public static readonly bool IsReferenceType     = Traits.IsReferenceType    (typeof(T));
      public static readonly bool IsUnmanagedType     = Traits.IsUnmanagedType    (typeof(T));
      public static readonly bool IsValueType         = Traits.IsValueType        (typeof(T));
    }

    internal abstract class ConstructibleConstraint       <T> where T : new()     {}
    internal abstract class NonNullableConstraint         <T> where T : notnull   {}
    internal abstract class NonNullableReferenceConstraint<T> where T : class     {}
    internal abstract class ReferenceConstraint           <T> where T : class?    {}
    internal abstract class UnmanagedConstraint           <T> where T : unmanaged {}
    internal abstract class ValueConstraint               <T> where T : struct    {}

    /* … */
    [GameMethod(AggressiveInlining), GameResolution(1)] public static bool IsConstructibleType<T>()                 => Traits.TypeInfo<T>.IsConstructibleType;
    [GameMethod(AggressiveInlining), GameResolution(1)] public static bool IsConstructibleType   (System.Type type) { try { typeof(Traits.ConstructibleConstraint<>).MakeGenericType(type); return true; } catch {} return false; }
    [GameMethod(AggressiveInlining), GameResolution(1)] public static bool IsPrimitiveType<T>    ()                 => Traits.TypeInfo<T>.IsPrimitiveType;
    [GameMethod(AggressiveInlining), GameResolution(1)] public static bool IsPrimitiveType       (System.Type type) => type.IsPrimitive; // ->> `type == typeof(bool) || type == typeof(byte) || type == typeof(char) || type == typeof(double) || type == typeof(float) || type == typeof(int) || type == typeof(long) || type == typeof(sbyte) || type == typeof(short) || type == typeof(uint) || type == typeof(ulong) || type == typeof(ushort) || type == typeof(System.IntPtr) || type == typeof(System.UIntPtr)`
    [GameMethod(AggressiveInlining), GameResolution(1)] public static bool IsReferenceType<T>    ()                 => Traits.TypeInfo<T>.IsReferenceType;
    [GameMethod(AggressiveInlining), GameResolution(1)] public static bool IsReferenceType       (System.Type type) { try { typeof(Traits.ReferenceConstraint<>).MakeGenericType(type); return true; } catch {} return false; }
    [GameMethod(AggressiveInlining), GameResolution(0)] public static bool IsUnmanagedType<T>    ()                 => Traits.TypeInfo<T>.IsUnmanagedType;
    [GameMethod(AggressiveInlining), GameResolution(0)] public static bool IsUnmanagedType       (System.Type type) { try { typeof(Traits.UnmanagedConstraint<>).MakeGenericType(type); return true; } catch {} return false; }
    [GameMethod(AggressiveInlining), GameResolution(1)] public static bool IsValueType<T>        ()                 => Traits.TypeInfo<T>.IsValueType;
    [GameMethod(AggressiveInlining), GameResolution(1)] public static bool IsValueType           (System.Type type) { if (type.IsByRef || type == typeof(void) || System.Nullable.GetUnderlyingType(type) is not null) return false; if (type.IsEnum || type.IsPointer || type.IsValueType || typeof(System.Enum).IsAssignableFrom(type) || typeof(System.ValueType).IsAssignableFrom(type)) return true; try { typeof(Traits.ValueConstraint<>).MakeGenericType(type); return true; } catch {} return false; }
  }

  public static partial class Util /* ->> Utilities */ {
    public static class Array /* ->> Based on `Util.Array<T>` for non-generics */ {
      public readonly struct Copyable : System.Collections.ICollection {
        public readonly System.Action<System.Array, int> CopyTo;
        public readonly uint                             Count;
        readonly int                                     System.Collections.ICollection.Count          => ((int) this.Count);
        readonly bool                                    System.Collections.ICollection.IsSynchronized => false;
        readonly object                                  System.Collections.ICollection.SyncRoot       => this;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        public Copyable(uint length, System.Action<System.Array, int> copier) {
          this.CopyTo = copier;
          this.Count  = length;
        }

        /* … */
        [GameMethod(AggressiveInlining)] public readonly bool                    IsEmpty                                     ()                              => 0u == this.Count;
        [GameMethod(AggressiveInlining)] readonly void                           System.Collections.ICollection.CopyTo       (System.Array array, int index) => this.CopyTo(array, index);
        [GameMethod(AggressiveInlining)] readonly System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()                              => null!;

        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Array                                       array)      => new((uint) array     .Length, array                                        .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.ArrayList                       arrayList)  => new((uint) arrayList .Count,  arrayList                                    .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.BitArray                        bits)       => new((uint) bits      .Count,  bits                                         .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.Queue                           queue)      => new((uint) queue     .Count,  queue                                        .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.SortedList                      sortedList) => new((uint) sortedList.Count,  sortedList.Values                            .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.Specialized.NameValueCollection collection) => new((uint) collection.Count,  collection                                   .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.Specialized.StringCollection    collection) => new((uint) collection.Count,  ((System.Collections.ICollection) collection).CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.Stack                           stack)      => new((uint) stack     .Count,  stack                                        .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.IO.MemoryStream                             stream)     => (Copyable) Array.From(stream);
      }

      public readonly struct Enumerable : System.Collections.IEnumerable {
        private readonly System.Collections.IEnumerable value;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)] public Enumerable(System.Collections.IEnumerable? enumerable) => this.value = enumerable ?? Array.From();
        [GameConstructor, GameMethod(AggressiveInlining)] public Enumerable(System.IO.MemoryStream?         stream)     => this.value = Array.From(stream);

        /* … */
        [GameMethod(AggressiveInlining)] public readonly System.Collections.IEnumerator GetEnumerator                               () => this.value.GetEnumerator();
        [GameMethod(AggressiveInlining)] readonly System.Collections.IEnumerator        System.Collections.IEnumerable.GetEnumerator() => this      .GetEnumerator();

        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Array?                                       array)      => new(array);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.ArrayList?                       arrayList)  => new(arrayList);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.BitArray?                        bits)       => new(bits);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.Queue?                           queue)      => new(queue);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.SortedList?                      sortedList) => new(sortedList);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.Specialized.NameValueCollection? collection) => new(collection);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.Specialized.StringCollection?    collection) => new(collection);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.Stack?                           stack)      => new(stack);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.IO.MemoryStream?                             stream)     => new(Array.From(stream).ConvertAll([GameMethod(AggressiveInlining)] static (element) => (object?) element));
      }

      /* … */
public static object foo<T>(T[] array) {
  uint          length = (uint) array.Length;
  uint          count  = (length - 1u) / 7u;
  System.Type[] types  = new System.Type[count + 1u];

  count *= 7u;
  for (uint index = count / 8u; ; --index) {
    uint          subcount = length - count;
    System.Type[] subtypes = new System.Type[subcount];

    System.Array.Fill(subtypes, typeof(T));
    // if (index != types.Length - 1u) subtypes[subcount - 1u] = types[index + 1u];
    // types[index] = System.Type.GetType("System.ValueTuple`" + subcount).MakeGenericType(subtypes);
    System.Console.WriteLine($"{count} {subcount}");

    if (0u == count)
    break;

    count   = count > 7u ? count - 7u : 0u;
    length -= subcount;
  }

  System.Console.WriteLine(types[0]);

  return null;
  // System.Type[] tupleGenericTypes = new System.Type[array.Length];
  // System.Array.Fill(tupleGenericTypes, typeof(T));
  // return System.Activator.CreateInstance(System.Type.GetType($"System.ValueTuple`{array.Length}").MakeGenericType(tupleGenericTypes), System.Array.ConvertAll(array, e => (object) e));
}

      public static void Copy(System.Array sourceArray, uint sourceIndex, System.Array destinationArray, uint destinationIndex, uint count) {
        (System.Type destinationType, System.Type sourceType) = (destinationArray.GetType().GetElementType(), sourceArray.GetType().GetElementType());

        // …
        if (Traits.IsPrimitiveType(destinationType) && Traits.IsPrimitiveType(sourceType)) {
          (int destinationElementSize, int sourceElementSize) = (System.Runtime.InteropServices.Marshal.SizeOf(destinationType), System.Runtime.InteropServices.Marshal.SizeOf(sourceType));

          if (destinationElementSize == sourceElementSize) {
            System.Buffer.BlockCopy(sourceArray, (int) sourceIndex * sourceElementSize, destinationArray, (int) destinationIndex * destinationElementSize, (int) count * sourceElementSize);
            return;
          }
        }

        System.Array.Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, count);
      }

      [GameMethod(AggressiveInlining)] public static System.Array From()                                                            => System.Array.Empty<object>();
      [GameMethod(AggressiveInlining)] public static System.Array From(System.Array?                                    array)      => array ?? Array.From();
      [GameMethod(AggressiveInlining)] public static object?[]    From(System.Collections.ArrayList?                    arrayList)  => arrayList is not null ? arrayList.ToArray() : System.Array.Empty<object?>();
      [GameMethod(AggressiveInlining)] public static bool   []    From(System.Collections.BitArray?                     bits)       { if (!(bits?.IsEmpty() ?? true)) { bool[] array = new bool[bits!.Length]; uint length = 0u; foreach (bool bit in bits) { array[length++] = bit; } return array; } return System.Array.Empty<bool>(); }
      [GameMethod(AggressiveInlining)] public static object?[]    From(System.Collections.IEnumerable?                  enumerable) { if (enumerable is not null) { System.Collections.Queue array = new(); for (System.Collections.IEnumerator enumerator = enumerable.GetEnumerator(); enumerator.MoveNext(); ) array.Enqueue(enumerator.Current); return Array.From(array); } return System.Array.Empty<object?>(); }
      [GameMethod(AggressiveInlining)] public static object?[]    From(System.Collections.Queue?                        queue)      => queue      is not null ? queue.ToArray()               : System.Array.Empty<object?>();
      [GameMethod(AggressiveInlining)] public static object?[]    From(System.Collections.SortedList?                   sortedList) => sortedList is not null ? Array.From(sortedList.Values) : System.Array.Empty<object?>();
      [GameMethod(AggressiveInlining)] public static string?[]    From(System.Collections.Specialized.StringCollection? collection) { if (!(collection?.IsEmpty() ?? true)) { string?[] array = new string?[collection!.Count]; uint length = 0u; foreach (string? element in collection) { array[length++] = element; } return array; } return System.Array.Empty<string?>(); }
      [GameMethod(AggressiveInlining)] public static object?[]    From(System.Collections.Stack?                        stack)      => stack  is not null ? stack .ToArray() : System.Array.Empty<object?>();
      [GameMethod(AggressiveInlining)] public static byte   []    From(System.IO.MemoryStream?                          stream)     => stream is not null ? stream.ToArray() : System.Array.Empty<byte>   ();
      public static object?[] From(params Array.Enumerable[] enumerables) { System.Collections.Queue array = new(enumerables.Length); foreach (Array.Enumerable enumerable in enumerables) { foreach (object? element in enumerable) array.Enqueue(element); } return Array.From(array); }
    }

    public static class Array<T> /* ->> Based on `Util.Reference<T>` for `𝑓 Util.Array<T>.Copy(…)` */ {
      public readonly struct Copyable : System.Collections.Generic.ICollection<T> {
        public readonly System.Action<T[], int> CopyTo;
        public readonly uint                    Count;
        readonly int                            System.Collections.Generic.ICollection<T>.Count      => ((int) this.Count);
        readonly bool                           System.Collections.Generic.ICollection<T>.IsReadOnly => true;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)]
        public Copyable(uint length, System.Action<T[], int> copier) {
          this.CopyTo = copier;
          this.Count  = length;
        }

        /* … */
        [GameMethod(AggressiveInlining)] public readonly bool                               IsEmpty                                                ()                     => 0u == this.Count;
        [GameMethod(NoInlining)]         readonly void                                      System.Collections.Generic.ICollection<T>.Add          (T element)            => throw new System.NotSupportedException("Copyable is read-only");
        [GameMethod(NoInlining)]         readonly void                                      System.Collections.Generic.ICollection<T>.Clear        ()                     => throw new System.NotSupportedException("Copyable is read-only");
        [GameMethod(NoInlining)]         readonly bool                                      System.Collections.Generic.ICollection<T>.Contains     (T   element)          => throw new System.NotSupportedException("Copyable is opaque");
        [GameMethod(AggressiveInlining)] readonly void                                      System.Collections.Generic.ICollection<T>.CopyTo       (T[] array, int index) => this.CopyTo(array, index);
        [GameMethod(NoInlining)]         readonly bool                                      System.Collections.Generic.ICollection<T>.Remove       (T   element)          => throw new System.NotSupportedException("Copyable is read-only");
        [GameMethod(AggressiveInlining)] readonly System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()                     => null!;
        [GameMethod(AggressiveInlining)] readonly System.Collections.IEnumerator            System.Collections.IEnumerable.GetEnumerator           ()                     => null!;

        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(T[]                                                            array)        => new((uint) array       .Length, ((System.Collections.Generic.ICollection<T>) array).CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(Game.Collections.RefReadOnlyList<T>                    list)         => new((uint) list        .Count,  list                                               .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(Game.Collections.SharedList     <T>                    list)         => new((uint) list        .Count,  list                                               .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Array                                                   array)        => new((uint) array       .Length, [GameMethod(AggressiveInlining)] (destinationArray, index) => array.CopyTo(destinationArray, index));
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(in System.ArraySegment<T>                                      arraySegment) => new((uint) arraySegment.Count,  arraySegment.CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.ArrayList                                   arrayList)    => new((uint) arrayList   .Count,  [GameMethod(AggressiveInlining)] (destinationArray, index) => arrayList.CopyTo(destinationArray, index));
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.BitArray                                    bits)         => new((uint) bits        .Count,  [GameMethod(AggressiveInlining)] (destinationArray, index) => bits     .CopyTo(destinationArray, index));
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.Generic.List                            <T> list)         => new((uint) list        .Count,  list                                                                .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.Generic.HashSet                         <T> hashset)      => new((uint) hashset     .Count,  hashset                                                             .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.Generic.LinkedList                      <T> list)         => new((uint) list        .Count,  list                                                                .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.Generic.Queue                           <T> queue)        => new((uint) queue       .Count,  queue                                                               .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.Generic.SortedSet                       <T> sortedSet)    => new((uint) sortedSet   .Count,  sortedSet                                                           .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.Generic.Stack                           <T> stack)        => new((uint) stack       .Count,  stack                                                               .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.ObjectModel.Collection                  <T> collection)   => new((uint) collection  .Count,  collection                                                          .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.ObjectModel.ObservableCollection        <T> collection)   => new((uint) collection  .Count,  (collection as System.Collections.ObjectModel.Collection<T>)        .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.ObjectModel.ReadOnlyCollection          <T> collection)   => new((uint) collection  .Count,  collection                                                          .CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.ObjectModel.ReadOnlyObservableCollection<T> collection)   => new((uint) collection  .Count,  (collection as System.Collections.ObjectModel.ReadOnlyCollection<T>).CopyTo);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.Queue                                       queue)        => new((uint) queue       .Count,  [GameMethod(AggressiveInlining)] (destinationArray, index) => queue                                        .CopyTo(destinationArray, index));
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.SortedList                                  sortedList)   => new((uint) sortedList  .Count,  [GameMethod(AggressiveInlining)] (destinationArray, index) => sortedList.Values                            .CopyTo(destinationArray, index));
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.Specialized.NameValueCollection             collection)   => new((uint) collection  .Count,  [GameMethod(AggressiveInlining)] (destinationArray, index) => collection                                   .CopyTo(destinationArray, index));
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.Specialized.StringCollection                collection)   => new((uint) collection  .Count,  [GameMethod(AggressiveInlining)] (destinationArray, index) => ((System.Collections.ICollection) collection).CopyTo(destinationArray, index));
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.Collections.Stack                                       stack)        => new((uint) stack       .Count,  [GameMethod(AggressiveInlining)] (destinationArray, index) => stack                                        .CopyTo(destinationArray, index));
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(System.IO.MemoryStream                                         stream)       => typeof(T) == typeof(byte) && stream.Length <= int.MaxValue ? new Copyable((uint) stream.Length, [GameMethod(AggressiveInlining)] (destinationArray, index) => stream.Read(destinationArray as byte[], 0, (int) stream.Length)) : (Copyable) Util.Array.From(stream);
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(in System.Memory        <T>                                    memory)       => (Copyable) memory.Span;
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(in System.ReadOnlyMemory<T>                                    memory)       => (Copyable) memory.Span;
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(in System.ReadOnlySpan  <T>                                    span)         => new((uint) span.Length, ((System.Collections.Generic.ICollection<T>) Array<T>.From(in span)).CopyTo); // ->> Could alternatively use function pointer if `static`
        [GameMethod(AggressiveInlining)] public static implicit operator Copyable(in System.Span          <T>                                    span)         => (Copyable) (System.ReadOnlySpan<T>) span;
      }

      public readonly struct Enumerable : System.Collections.Generic.IEnumerable<T> /* ->> Solely for `Util.Array<T>.From(…)` */ {
        public readonly struct Enumerator : System.Collections.Generic.IEnumerator<T> {
          public  readonly T                              Current => (T) this.enumerator.Current!;
          private readonly System.Collections.IEnumerator enumerator;
          readonly T                                      System.Collections.Generic.IEnumerator<T>.Current => this.Current;
          readonly object                                 System.Collections.IEnumerator.Current            => this.Current!;

          /* … */
          [GameConstructor, GameMethod(AggressiveInlining)]
          public Enumerator(System.Collections.IEnumerator enumerator) => this.enumerator = enumerator;

          /* … */
          public readonly void Dispose                                () { /* Do nothing… */ }
          public readonly bool MoveNext                               () => this.enumerator.MoveNext();
          public readonly void Reset                                  () => this.enumerator.Reset   ();
          readonly bool        System.Collections.IEnumerator.MoveNext() => this           .MoveNext();
          readonly void        System.Collections.IEnumerator.Reset   () => this           .Reset   ();
          readonly void        System.IDisposable.Dispose             () => this           .Dispose ();
        }

        /* … */
        private readonly System.Collections.IEnumerable value;

        /* … */
        [GameConstructor, GameMethod(AggressiveInlining)] public Enumerable(System.Collections.IEnumerable? enumerable)                              => this.value = enumerable ?? Array<T>.From();
        [GameConstructor, GameMethod(AggressiveInlining)] public Enumerable(System.IO.MemoryStream?         stream)                                  => this.value = Util.Array.From(stream);
        [GameConstructor, GameMethod(AggressiveInlining)] public Enumerable(in System.Memory        <T>     memory) : this(Array<T>.From(in memory)) {}
        [GameConstructor, GameMethod(AggressiveInlining)] public Enumerable(in System.ReadOnlyMemory<T>     memory) : this(Array<T>.From(in memory)) {}
        [GameConstructor, GameMethod(AggressiveInlining)] public Enumerable(in System.ReadOnlySpan  <T>     span)   : this(Array<T>.From(in span))   {}
        [GameConstructor, GameMethod(AggressiveInlining)] public Enumerable(in System.Span          <T>     span)   : this(Array<T>.From(in span))   {}

        /* … */
        [GameMethod(AggressiveInlining)] public readonly Enumerable.Enumerator              GetEnumerator                                          () => new(this.value.GetEnumerator());
        [GameMethod(AggressiveInlining)] readonly System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator() => this.GetEnumerator();
        [GameMethod(AggressiveInlining)] readonly System.Collections.IEnumerator            System.Collections.IEnumerable.GetEnumerator           () => this.GetEnumerator();

        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(T[]?                                                            array)        => new(array);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(Game.Collections.RefReadOnlyList<T>?                    list)         => new(list);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(Game.Collections.SharedList     <T>?                    list)         => new(list);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Array?                                                   array)        => new(array);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(in System.ArraySegment<T>                                       arraySegment) => new(arraySegment);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.ArraySegment<T>?                                         arraySegment) => new(arraySegment);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.ArrayList?                                   arrayList)    => new(arrayList);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.BitArray?                                    bits)         => new(bits);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.Generic.List                            <T>? list)         => new(list);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.Generic.HashSet                         <T>? hashset)      => new(hashset);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.Generic.LinkedList                      <T>? list)         => new(list);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.Generic.Queue                           <T>? queue)        => new(queue);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.Generic.SortedSet                       <T>? sortedSet)    => new(sortedSet);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.Generic.Stack                           <T>? stack)        => new(stack);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.ObjectModel.Collection                  <T>? collection)   => new(collection);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.ObjectModel.ObservableCollection        <T>? collection)   => new(collection as System.Collections.ObjectModel.Collection<T>);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.ObjectModel.ReadOnlyCollection          <T>? collection)   => new(collection);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.ObjectModel.ReadOnlyObservableCollection<T>? collection)   => new(collection as System.Collections.ObjectModel.ReadOnlyCollection<T>);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.Queue?                                       queue)        => new(queue);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.SortedList?                                  sortedList)   => new(sortedList?.Values);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.Specialized.NameValueCollection?             collection)   => new(collection);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.Specialized.StringCollection?                collection)   => new(collection);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.Collections.Stack?                                       stack)        => new(stack);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(System.IO.MemoryStream?                                         stream)       => new(Util.Array.From(stream));
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(in System.Memory        <T>                                     memory)       => new(memory);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(in System.ReadOnlyMemory<T>                                     memory)       => new(memory);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(in System.ReadOnlySpan  <T>                                     span)         => new(span);
        [GameMethod(AggressiveInlining)] public static implicit operator Enumerable(in System.Span          <T>                                     span)         => new(span);
        #if NET9_0 || NET9_0_OR_GREATER
          [GameMethod(AggressiveInlining)]
          public static implicit operator Enumerable(this System.Collections.ObjectModel.ReadOnlySet<T> set) => new(set);
        #endif
      }

      private readonly struct Sentinel {}

      /* … */
      public static readonly Game.ArrayCopier<T> Copy = (Game.ArrayCopier<T>) (Traits.IsPrimitiveType<T>() ? ((Game.ArrayCopier<Array<T>.Sentinel>) Array<Array<T>.Sentinel>.UnmanagedCopy).Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.ArrayCopier<T>)) : (Game.ArrayCopier<T>) Array<T>.ManagedCopy<T>);

      /* … */
      [GameMethod(AggressiveInlining)] // ->> Faster with `System.GC.AllocateUninitializedArray<T>(…, false)`
      public static T[] Create(uint length) => 0u != length ? new T[length] : System.Array.Empty<T>();

      [GameMethod(AggressiveInlining)] public static T[] From       ()                                                                                     => System.Array.Empty<T>();
      [GameMethod(AggressiveInlining)] public static T[] From       (T[]?                                                    array)                        => array ?? Array<T>.From();
      [GameMethod(AggressiveInlining)] public static T[] From       (Game.Collections.RefReadOnlyList    <T>?        list)                         { if (!(list            ?.IsEmpty() ?? true)) { T[] array = new T[list            !.Count]; list            .CopyTo(array); return array; } return System.Array.Empty<T>(); }
      [GameMethod(AggressiveInlining)] public static T[] From<TSort>(Game.Collections.RefSortedCollection<TSort, T>? sortedCollection)             { if (!(sortedCollection?.IsEmpty() ?? true)) { T[] array = new T[sortedCollection!.Count]; sortedCollection.CopyTo(array); return array; } return System.Array.Empty<T>(); }
      [GameMethod(AggressiveInlining)] public static T[] From       (Game.Collections.SharedList         <T>?        list)                         { if (!(list            ?.IsEmpty() ?? true)) { T[] array = new T[list            !.Count]; list            .CopyTo(array); return array; } return System.Array.Empty<T>(); }
      [GameMethod(AggressiveInlining)] public static T[] From       (System.Array?                                           array)                        => (T[]) (array ?? Array<T>.From());
      [GameMethod(AggressiveInlining)] public static T[] From       (in System.ArraySegment<T>                               arraySegment)                 =>        arraySegment .ToArray();
      [GameMethod(AggressiveInlining)] public static T[] From       (System.ArraySegment   <T>?                              arraySegment)                 =>        arraySegment?.ToArray()          ?? Array<T>.From();
      [GameMethod(AggressiveInlining)] public static T[] From       (System.Collections.ArrayList?                           arrayList)                    => (T[]) (arrayList   ?.ToArray(typeof(T)) ?? Array<T>.From());
      [GameMethod(AggressiveInlining)] public static T[] From       (System.Collections.BitArray?                            bits)                         => Util.Array.From(bits)      .ConvertAll([GameMethod(AggressiveInlining)] static (element) => Util.GetConverter<bool,    T>()(in element));
      [GameMethod(AggressiveInlining)] public static T[] From       (System.Collections.IEnumerable?                         enumerable)                   => Util.Array.From(enumerable).ConvertAll([GameMethod(AggressiveInlining)] static (element) => Util.GetConverter<object?, T>()(in element));
      [GameMethod(AggressiveInlining)] public static T[] From       (System.Collections.Generic.IEnumerable<T>?              enumerable)                   { if (enumerable is not null) { System.Collections.Generic.Queue<T> array = new(); using (System.Collections.Generic.IEnumerator<T> enumerator = enumerable.GetEnumerator()) { while (enumerator.MoveNext()) array.Enqueue(enumerator.Current); } return Util.Array<T>.From(array); } return Util.Array<T>.From(); }
      [GameMethod(AggressiveInlining)] public static T[] From       (System.Collections.Generic.List       <T>?              list)                         => list ?.ToArray() ?? Array<T>.From();
      [GameMethod(AggressiveInlining)] public static T[] From       (System.Collections.Generic.Queue      <T>?              queue)                        => queue?.ToArray() ?? Array<T>.From();
      [GameMethod(AggressiveInlining)] public static T[] From       (System.Collections.Generic.Stack      <T>?              stack)                        => stack?.ToArray() ?? Array<T>.From();
      [GameMethod(AggressiveInlining)] public static T[] From       (System.Collections.Queue?                               queue)                        => Util.Array.From(queue)     .ConvertAll([GameMethod(AggressiveInlining)] static (element) => Util.GetConverter<object?, T>()(in element));
      [GameMethod(AggressiveInlining)] public static T[] From       (System.Collections.Specialized.StringCollection?        collection)                   => Util.Array.From(collection).ConvertAll([GameMethod(AggressiveInlining)] static (element) => Util.GetConverter<string?, T>()(in element));
      [GameMethod(AggressiveInlining)] public static T[] From       (System.Collections.Stack?                               stack)                        => Util.Array.From(stack)     .ConvertAll([GameMethod(AggressiveInlining)] static (element) => Util.GetConverter<object?, T>()(in element));
      [GameMethod(AggressiveInlining)] public static T[] From<TKey> (System.Collections.Generic.SortedList<TKey, T>          sortedList)                   => !(sortedList?.IsEmpty() ?? true) ? Array<T>.From(sortedList!.Values) : Array<T>.From();
      [GameMethod(AggressiveInlining)] public static T[] From       (System.Collections.SortedList                           sortedList)                   => Util.Array.From(sortedList).ConvertAll([GameMethod(AggressiveInlining)] static (element) => Util.GetConverter<object?, T>()(in element));
      [GameMethod(AggressiveInlining)] public static T[] From       (System.IO.MemoryStream?                                 stream)                       => Util.Array.From(stream)    .ConvertAll([GameMethod(AggressiveInlining)] static (element) => Util.GetConverter<byte,    T>()(in element));
      [GameMethod(AggressiveInlining)] public static T[] From       (in System.Memory                <T>                     memory)                       =>                                   memory                                             .ToArray       ();
      [GameMethod(AggressiveInlining)] public static T[] From       (System.Memory                   <T>?                    memory)                       =>                                   memory                                            ?.ToArray       () ?? Array<T>.From();
      [GameMethod(AggressiveInlining)] public static T[] From       (in System.ReadOnlyMemory        <T>                     memory)                       =>                                   memory                                             .ToArray       ();
      [GameMethod(AggressiveInlining)] public static T[] From       (System.ReadOnlyMemory           <T>?                    memory)                       =>                                   memory                                            ?.ToArray       () ?? Array<T>.From();
      [GameMethod(AggressiveInlining)] public static T[] From       (in System.Span                  <T>                     span)                         =>                                   span                                               .ToArray       ();
      [GameMethod(AggressiveInlining)] public static T[] From       (in System.ReadOnlySpan          <T>                     span)                         =>                                   span                                               .ToArray       ();
      [GameMethod(AggressiveInlining)] public static U[] From<U>    (in Unity.Collections.NativeArray<U>                     array) where U : unmanaged, T =>                                   array                                              .ToArray       ();
      [GameMethod(AggressiveInlining)] public static U[] From<U>    (Unity.Collections.NativeArray   <U>?                    array) where U : unmanaged, T =>                                   array                                             ?.ToArray       () ?? Array<U>.From();
      [GameMethod(AggressiveInlining)] public static U[] From<U>    (in Unity.Collections.NativeArray<U>.ReadOnly            array) where U : unmanaged, T =>                     Array<U>.From(array                                              .AsReadOnlySpan());
      [GameMethod(AggressiveInlining)] public static U[] From<U>    (Unity.Collections.NativeArray   <U>.ReadOnly?           array) where U : unmanaged, T => array is not null ? Array<U>.From(((Unity.Collections.NativeArray<U>.ReadOnly) array).AsReadOnlySpan()) : Array<U>.From();

      public static T[] From(params Array<T>.Enumerable[] enumerables) {
        System.Collections.Generic.Queue<T> array = new(enumerables.Length);

        // …
        foreach (Array<T>.Enumerable enumerable in enumerables) {
          foreach (T element in enumerable)
          array.Enqueue(element);
        }

        return Array<T>.From(array);
      }

      [GameMethod(AggressiveInlining)] private        static void ManagedCopy  <U>(U[] sourceArray, uint sourceIndex, U[] destinationArray, uint destinationIndex, uint count)                     => System.Array.Copy      (sourceArray, sourceIndex,                   destinationArray, destinationIndex,                   count);
      [GameMethod(AggressiveInlining)] private unsafe static void UnmanagedCopy<U>(U[] sourceArray, uint sourceIndex, U[] destinationArray, uint destinationIndex, uint count) where U : unmanaged => System.Buffer.BlockCopy(sourceArray, (int) sourceIndex * sizeof(U), destinationArray, (int) destinationIndex * sizeof(U), (int) count * sizeof(U));
    }

    public static class Enumerable {
      [GameMethod(AggressiveInlining)]
      public static uint Count(System.Collections.IEnumerable enumerable) {
        uint count = 0u;

        // …
        for (System.Collections.IEnumerator enumerator = enumerable.GetEnumerator(); enumerator.MoveNext(); )
        ++count;

        return count;
      }

      [GameMethod(AggressiveInlining)]
      public static uint Count<T>(System.Collections.Generic.IEnumerable<T> enumerable) {
        uint count = 0u;

        // …
        using (System.Collections.Generic.IEnumerator<T> enumerator = enumerable.GetEnumerator()) {
          while (enumerator.MoveNext())
          ++count;
        }

        return count;
      }

      [GameMethod(AggressiveInlining)]
      public static bool IsEmpty(System.Collections.IEnumerable enumerable) => !enumerable.GetEnumerator().MoveNext();

      [GameMethod(AggressiveInlining)]
      public static bool IsEmpty<T>(System.Collections.Generic.IEnumerable<T> enumerable) {
        using (System.Collections.Generic.IEnumerator<T> enumerator = enumerable.GetEnumerator())
        return !enumerator.MoveNext();
      }
    }

    public static class Enumerator {
      [GameMethod(AggressiveInlining)]
      public static uint Count(System.Collections.IEnumerator enumerator, bool preserve = true) {
        uint count = 0u;
        uint index = 0u;

        // …
        if  (preserve) { while (enumerator.MoveNext()) ++index; }
        for (enumerator.Reset(); enumerator.MoveNext(); ) ++count;
        if  (preserve) { for (enumerator.Reset(); count != index; ++index) enumerator.MoveNext(); } // ->> Reset `enumerator` to initially passed state

        return count;
      }

      [GameMethod(AggressiveInlining)]
      public static uint Count<T>(System.Collections.Generic.IEnumerator<T> enumerator, bool preserve = true) {
        uint count = Enumerator.Count((System.Collections.IEnumerator) enumerator, preserve);

        // …
        if (!preserve)
        enumerator.Dispose();

        return count;
      }

      [GameMethod(AggressiveInlining)]
      public static TEnumerable? MoveNext<TEnumerable>(in TEnumerable enumerator, uint length = 1u, bool preserve = true) where TEnumerable : System.Collections.IEnumerator {
        uint count = 0u;
        uint index = 0u;

        // …
        if (preserve) {
          while (enumerator.MoveNext())                       ++index;
          for   (enumerator.Reset(); enumerator.MoveNext(); ) ++count;

          enumerator.Reset();
          for (uint subindex = index; count != subindex; ++subindex) enumerator.MoveNext();
        }

        while (0u != length--)
        if (!enumerator.MoveNext()) {
          if (preserve) {
            for (enumerator.Reset(); count != index; ++index)
            enumerator.MoveNext(); // ->> Reset `enumerator` to initially passed state
          }

          return default;
        }

        return enumerator;
      }

      [GameMethod(AggressiveInlining)]
      public static TEnumerable? MoveTo<TEnumerable>(in TEnumerable enumerator, uint position, bool preserve = true) where TEnumerable : System.Collections.IEnumerator {
        uint count = 0u;
        uint index = 0u;

        // …
        if (preserve) {
          while (enumerator.MoveNext())
          ++index;
        }

        for (enumerator.Reset(); 0u != position--; ++count)
        if (!enumerator.MoveNext()) {
          if (preserve) {
            for (enumerator.Reset(); count != index; ++index)
            enumerator.MoveNext(); // ->> Reset `enumerator` to initially passed state
          }

          return default;
        }

        return enumerator;
      }
    }

    public static class Game {
      public   static       bool                    IsAnimationSequenceAutomatic { get; internal set; } = false;
      public   static       bool                    IsQuitting                   { get; internal set; } = false;
      internal static       UnityEngine.GameObject? Object                                              = null;
      public   static event System.Action<double>   OnEnd                                               = [GameMethod(AggressiveInlining)] static (timestamp) => {};
      public   static event System.Action<double>   OnLateUpdate                                        = [GameMethod(AggressiveInlining)] static (timestamp) => {};
      public   static event System.Action<double>   OnStart                                             = [GameMethod(AggressiveInlining)] static (timestamp) => {};
      public   static event System.Action<double>   OnUpdate                                            = [GameMethod(AggressiveInlining)] static (timestamp) => {};

      /* … */
      [GameMethod(AggressiveInlining)] public static bool AskToSave() => Game.AskToSave(UnityEngine.SceneManagement.SceneManager.GetActiveScene());
      [GameMethod(AggressiveInlining)] public static bool AskToSave(in UnityEngine.SceneManagement.Scene scene) {
        // … ->> Undo’s not bothered with for the time begin
        #if UNITY_EDITOR
          if (!UnityEditor.EditorApplication.isPlaying)
          return UnityEditor.SceneManagement.EditorSceneManager.MarkSceneDirty(scene);
        #endif

        return false;
      }

      [GameMethod(AggressiveInlining)] internal static void End       (double timestamp) => Game.OnEnd       (timestamp);
      [GameMethod(AggressiveInlining)] internal static void LateUpdate(double timestamp) => Game.OnLateUpdate(timestamp);

      [GameMethod(AggressiveInlining)]
      public static void Quit(int code = 0x0 /* ->> `EXIT_SUCCESS` */) {
        if (Game.Util.Game.IsQuitting)
        return;

        Game.Util.Game.IsQuitting = true;
        UnityEngine.Application.Quit(code);
        #if UNITY_EDITOR
          UnityEditor.EditorApplication.ExitPlaymode();
          UnityEditor.EditorApplication.isPlaying = false;
        #endif
      }

      [UnityEngine.RuntimeInitializeOnLoadMethod(UnityEngine.RuntimeInitializeLoadType.AfterSceneLoad)]
      private static void Main() => new UnityEngine.GameObject("…", typeof(GameBehaviour)); // ->> `Game.Object` is set by itself

      [GameMethod(AggressiveInlining)] internal static void Start (double timestamp) => Game.OnStart (timestamp);
      [GameMethod(AggressiveInlining)] internal static void Update(double timestamp) => Game.OnUpdate(timestamp);
    }

    public static class Keys {
      public delegate void Keyer   (in Game.Collections.KeyInfo key);
      public delegate void Prompter();

      /* … */
      public static class Functions {
        public static Game.Collections.DeviceState F1  { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F2  { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F3  { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F4  { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F5  { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F6  { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F7  { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F8  { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F9  { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F10 { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F11 { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F12 { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F13 { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F14 { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F15 { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F16 { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F17 { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F18 { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F19 { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F20 { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F21 { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F22 { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F23 { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState F24 { get; internal set; } = Game.Collections.DeviceState.INVALID;
      }

      public static class Modifiers {
        public static Game.Collections.DeviceState Alt              { get => Game.Collections.DeviceState.GetDeviceState(System.Math.Min((uint) Keys.Modifiers.LeftAlt,     (uint) Keys.Modifiers.RightAlt));     internal set => Keys.Modifiers.LeftAlt     = Keys.Modifiers.RightAlt     = value; }
        public static Game.Collections.DeviceState Control          { get => Game.Collections.DeviceState.GetDeviceState(System.Math.Min((uint) Keys.Modifiers.LeftControl, (uint) Keys.Modifiers.RightControl)); internal set => Keys.Modifiers.LeftControl = Keys.Modifiers.RightControl = value; }
        public static Game.Collections.DeviceState Ctrl             { get => Keys.Modifiers.Control; internal set => Keys.Modifiers.Control = value; }
        public static Game.Collections.DeviceState LeftAlt          { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState LeftControl      { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState LeftCtrl         { get => Keys.Modifiers.LeftControl; internal set => Keys.Modifiers.LeftControl = value; }
        public static Game.Collections.DeviceState LeftMeta         { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState LeftMetaCommand  { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState LeftMetaApple    { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState LeftMetaWindows  { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState LeftShift        { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState Meta             { get => Game.Collections.DeviceState.GetDeviceState(System.Math.Min((uint) Keys.Modifiers.LeftMeta,        (uint) Keys.Modifiers.RightMeta));        internal set => Keys.Modifiers.LeftMeta        = Keys.Modifiers.RightMeta        = value; }
        public static Game.Collections.DeviceState MetaApple        { get => Game.Collections.DeviceState.GetDeviceState(System.Math.Min((uint) Keys.Modifiers.LeftMetaApple,   (uint) Keys.Modifiers.RightMetaApple));   internal set => Keys.Modifiers.LeftMetaApple   = Keys.Modifiers.RightMetaApple   = value; }
        public static Game.Collections.DeviceState MetaCommand      { get => Game.Collections.DeviceState.GetDeviceState(System.Math.Min((uint) Keys.Modifiers.LeftMetaCommand, (uint) Keys.Modifiers.RightMetaCommand)); internal set => Keys.Modifiers.LeftMetaCommand = Keys.Modifiers.RightMetaCommand = value; }
        public static Game.Collections.DeviceState MetaWindows      { get => Game.Collections.DeviceState.GetDeviceState(System.Math.Min((uint) Keys.Modifiers.LeftMetaWindows, (uint) Keys.Modifiers.RightMetaWindows)); internal set => Keys.Modifiers.LeftMetaWindows = Keys.Modifiers.RightMetaWindows = value; }
        public static Game.Collections.DeviceState RightAlt         { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState RightControl     { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState RightCtrl        { get => Keys.Modifiers.RightControl; internal set => Keys.Modifiers.RightControl = value; }
        public static Game.Collections.DeviceState RightMeta        { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState RightMetaApple   { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState RightMetaCommand { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState RightMetaWindows { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState RightShift       { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState Shift            { get => Game.Collections.DeviceState.GetDeviceState(System.Math.Min((uint) Keys.Modifiers.LeftShift,   (uint) Keys.Modifiers.RightShift));   internal set => Keys.Modifiers.LeftShift   = Keys.Modifiers.RightShift   = value; }
      }

      public static class Specials {
        public static Game.Collections.DeviceState A          { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState D          { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState DownArrow  { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState Escape     { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState LeftArrow  { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState RightArrow { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState S          { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState Space      { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState Tab        { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState UpArrow    { get; internal set; } = Game.Collections.DeviceState.INVALID;
        public static Game.Collections.DeviceState W          { get; internal set; } = Game.Collections.DeviceState.INVALID;
      }

      /* … */
      internal static readonly Game.Collections.RefList        <Game.Collections.KeyInfo>                                                             BeginState                        =  new(16u);
      public   static readonly Game.Collections.RefReadOnlyList<Game.Collections.KeyInfo>                                                             Begin                             =  (Game.Collections.RefReadOnlyList<Game.Collections.KeyInfo>) Keys.BeginState;
      public   static          uint                                                                                                                                   Count                             => System.Math.Max(Keys.CurrentState.Count, System.Math.Max(Keys.BeginState.Count, Keys.EndState.Count));
      internal static readonly Game.Collections.RefList                     <Game.Collections.KeyInfo>                                                CurrentState                      =  new(16u);
      public   static readonly Game.Collections.RefReadOnlyList             <Game.Collections.KeyInfo>                                                Current                           =  (Game.Collections.RefReadOnlyList<Game.Collections.KeyInfo>) Keys.CurrentState;
      internal static readonly Game.Collections.RefList                     <Game.Collections.KeyInfo>                                                EndState                          =  new(16u);
      public   static readonly Game.Collections.RefReadOnlyList             <Game.Collections.KeyInfo>                                                End                               =  (Game.Collections.RefReadOnlyList<Game.Collections.KeyInfo>) Keys.EndState;
      public   static          ref readonly Game.Collections.RefReadOnlyList<Game.Collections.KeyInfo>                                                Held                              => ref Keys.Current;
      public   static          bool                                                                                                                                   IsActive                          => UnityEngine.Input.anyKey || UnityEngine.Input.anyKeyDown || !Keys.BeginState.IsEmpty() && !Keys.CurrentState.IsEmpty() && !Keys.EndState.IsEmpty();
      public   static          bool                                                                                                                                   IsAdding   { get; internal set; } =  false;
      public   static          bool                                                                                                                                   IsChanging { get; internal set; } =  false;
      public   static          bool                                                                                                                                   IsHeld                            => UnityEngine.Input.anyKey     || !Keys.CurrentState.IsEmpty();
      public   static          bool                                                                                                                                   IsPressed                         => UnityEngine.Input.anyKeyDown || !Keys.BeginState  .IsEmpty();
      public   static          bool                                                                                                                                   IsPrompted { get; internal set; } =  false;
      public   static          bool                                                                                                                                   IsReleased                        => !Keys.EndState.IsEmpty(); // ->> What‥ no `UnityEngine.Input.anyKeyUp`, Unity?
      public   static          bool                                                                                                                                   IsRemoving { get; internal set; } =  false;
      public   static event    Keys.Keyer                                                                                                                             OnKeyAdded                        =  [GameMethod(AggressiveInlining)] static (in Game.Collections.KeyInfo key) => {};
      public   static event    Keys.Keyer                                                                                                                             OnKeyRemoved                      =  [GameMethod(AggressiveInlining)] static (in Game.Collections.KeyInfo key) => {};
      public   static event    Keys.Keyer                                                                                                                             OnKeyUpdated                      =  [GameMethod(AggressiveInlining)] static (in Game.Collections.KeyInfo key) => {};
      public   static event    Keys.Prompter                                                                                                                          OnPrompt                          =  [GameMethod(AggressiveInlining)] static ()                                        => {};
      public   static          ref readonly Game.Collections.RefReadOnlyList<Game.Collections.KeyInfo>                                                Pressed                           => ref Keys.Begin;
      public   static          ref readonly Game.Collections.RefReadOnlyList<Game.Collections.KeyInfo>                                                Released                          => ref Keys.End;
      public   static          double                                                                                                                                 RepeatDelay                       =  1.0; // ->> in Seconds; UI keyboard repeat delay
      public   static readonly System.Collections.ObjectModel.ReadOnlyCollection<Game.Collections.RefList<Game.Collections.KeyInfo>>                  States                            =  new[] {Keys.BeginState, Keys.CurrentState, Keys.EndState}.AsReadOnly();
      public   static readonly Game.Collections.InputStateCollection    <Game.Collections.KeyInfo>                                                    Any                               =  new(Keys.States);
      internal static readonly (Game.Collections.RefReadOnlyList<UnityEngine.KeyCode>, Game.Collections.RefReadOnlyList<UnityEngine.InputSystem.Key>) All                               =  (new(stackalloc[] {UnityEngine.KeyCode.A, UnityEngine.KeyCode.Alpha0, UnityEngine.KeyCode.Alpha1, UnityEngine.KeyCode.Alpha2, UnityEngine.KeyCode.Alpha3, UnityEngine.KeyCode.Alpha4, UnityEngine.KeyCode.Alpha5, UnityEngine.KeyCode.Alpha6, UnityEngine.KeyCode.Alpha7, UnityEngine.KeyCode.Alpha8, UnityEngine.KeyCode.Alpha9, UnityEngine.KeyCode.AltGr, UnityEngine.KeyCode.Ampersand, UnityEngine.KeyCode.Asterisk, UnityEngine.KeyCode.At, UnityEngine.KeyCode.B, UnityEngine.KeyCode.BackQuote, UnityEngine.KeyCode.Backslash, UnityEngine.KeyCode.Backspace, UnityEngine.KeyCode.Break, UnityEngine.KeyCode.C, UnityEngine.KeyCode.CapsLock, UnityEngine.KeyCode.Caret, UnityEngine.KeyCode.Clear, UnityEngine.KeyCode.Colon, UnityEngine.KeyCode.Comma, UnityEngine.KeyCode.D, UnityEngine.KeyCode.Delete, UnityEngine.KeyCode.Dollar, UnityEngine.KeyCode.DoubleQuote, UnityEngine.KeyCode.DownArrow, UnityEngine.KeyCode.E, UnityEngine.KeyCode.End, UnityEngine.KeyCode.Equals, UnityEngine.KeyCode.Escape, UnityEngine.KeyCode.Exclaim, UnityEngine.KeyCode.F, UnityEngine.KeyCode.F1, UnityEngine.KeyCode.F10, UnityEngine.KeyCode.F11, UnityEngine.KeyCode.F12, UnityEngine.KeyCode.F13, UnityEngine.KeyCode.F14, UnityEngine.KeyCode.F15, UnityEngine.KeyCode.F2, UnityEngine.KeyCode.F3, UnityEngine.KeyCode.F4, UnityEngine.KeyCode.F5, UnityEngine.KeyCode.F6, UnityEngine.KeyCode.F7, UnityEngine.KeyCode.F8, UnityEngine.KeyCode.F9, UnityEngine.KeyCode.G, UnityEngine.KeyCode.Greater, UnityEngine.KeyCode.H, UnityEngine.KeyCode.Hash, UnityEngine.KeyCode.Help, UnityEngine.KeyCode.Home, UnityEngine.KeyCode.I, UnityEngine.KeyCode.Insert, UnityEngine.KeyCode.J, UnityEngine.KeyCode.K, UnityEngine.KeyCode.Keypad0, UnityEngine.KeyCode.Keypad1, UnityEngine.KeyCode.Keypad2, UnityEngine.KeyCode.Keypad3, UnityEngine.KeyCode.Keypad4, UnityEngine.KeyCode.Keypad5, UnityEngine.KeyCode.Keypad6, UnityEngine.KeyCode.Keypad7, UnityEngine.KeyCode.Keypad8, UnityEngine.KeyCode.Keypad9, UnityEngine.KeyCode.KeypadDivide, UnityEngine.KeyCode.KeypadEnter, UnityEngine.KeyCode.KeypadEquals, UnityEngine.KeyCode.KeypadMinus, UnityEngine.KeyCode.KeypadMultiply, UnityEngine.KeyCode.KeypadPeriod, UnityEngine.KeyCode.KeypadPlus, UnityEngine.KeyCode.L, UnityEngine.KeyCode.LeftAlt, UnityEngine.KeyCode.LeftApple, UnityEngine.KeyCode.LeftArrow, UnityEngine.KeyCode.LeftBracket, UnityEngine.KeyCode.LeftCommand, UnityEngine.KeyCode.LeftControl, UnityEngine.KeyCode.LeftCurlyBracket, UnityEngine.KeyCode.LeftMeta, UnityEngine.KeyCode.LeftParen, UnityEngine.KeyCode.LeftShift, UnityEngine.KeyCode.LeftWindows, UnityEngine.KeyCode.Less, UnityEngine.KeyCode.M, UnityEngine.KeyCode.Menu, UnityEngine.KeyCode.Minus, UnityEngine.KeyCode.N, UnityEngine.KeyCode.Numlock, UnityEngine.KeyCode.O, UnityEngine.KeyCode.P, UnityEngine.KeyCode.PageDown, UnityEngine.KeyCode.PageUp, UnityEngine.KeyCode.Pause, UnityEngine.KeyCode.Percent, UnityEngine.KeyCode.Period, UnityEngine.KeyCode.Pipe, UnityEngine.KeyCode.Plus, UnityEngine.KeyCode.Print, UnityEngine.KeyCode.Q, UnityEngine.KeyCode.Question, UnityEngine.KeyCode.Quote, UnityEngine.KeyCode.R, UnityEngine.KeyCode.Return, UnityEngine.KeyCode.RightAlt, UnityEngine.KeyCode.RightApple, UnityEngine.KeyCode.RightArrow, UnityEngine.KeyCode.RightBracket, UnityEngine.KeyCode.RightCommand, UnityEngine.KeyCode.RightControl, UnityEngine.KeyCode.RightCurlyBracket, UnityEngine.KeyCode.RightMeta, UnityEngine.KeyCode.RightParen, UnityEngine.KeyCode.RightShift, UnityEngine.KeyCode.RightWindows, UnityEngine.KeyCode.S, UnityEngine.KeyCode.ScrollLock, UnityEngine.KeyCode.Semicolon, UnityEngine.KeyCode.Slash, UnityEngine.KeyCode.Space, UnityEngine.KeyCode.SysReq, UnityEngine.KeyCode.T, UnityEngine.KeyCode.Tab, UnityEngine.KeyCode.Tilde, UnityEngine.KeyCode.U, UnityEngine.KeyCode.Underscore, UnityEngine.KeyCode.UpArrow, UnityEngine.KeyCode.V, UnityEngine.KeyCode.W, UnityEngine.KeyCode.X, UnityEngine.KeyCode.Y, UnityEngine.KeyCode.Z}), new(stackalloc[] {UnityEngine.InputSystem.Key.A, UnityEngine.InputSystem.Key.AltGr, UnityEngine.InputSystem.Key.B, UnityEngine.InputSystem.Key.Backquote, UnityEngine.InputSystem.Key.Backslash, UnityEngine.InputSystem.Key.Backspace, UnityEngine.InputSystem.Key.C, UnityEngine.InputSystem.Key.CapsLock, UnityEngine.InputSystem.Key.Comma, UnityEngine.InputSystem.Key.ContextMenu, UnityEngine.InputSystem.Key.D, UnityEngine.InputSystem.Key.Delete, UnityEngine.InputSystem.Key.Digit0, UnityEngine.InputSystem.Key.Digit1, UnityEngine.InputSystem.Key.Digit2, UnityEngine.InputSystem.Key.Digit3, UnityEngine.InputSystem.Key.Digit4, UnityEngine.InputSystem.Key.Digit5, UnityEngine.InputSystem.Key.Digit6, UnityEngine.InputSystem.Key.Digit7, UnityEngine.InputSystem.Key.Digit8, UnityEngine.InputSystem.Key.Digit9, UnityEngine.InputSystem.Key.DownArrow, UnityEngine.InputSystem.Key.E, UnityEngine.InputSystem.Key.End, UnityEngine.InputSystem.Key.Enter, UnityEngine.InputSystem.Key.Equals, UnityEngine.InputSystem.Key.Escape, UnityEngine.InputSystem.Key.F, UnityEngine.InputSystem.Key.F1, UnityEngine.InputSystem.Key.F10, UnityEngine.InputSystem.Key.F11, UnityEngine.InputSystem.Key.F12, UnityEngine.InputSystem.Key.F2, UnityEngine.InputSystem.Key.F3, UnityEngine.InputSystem.Key.F4, UnityEngine.InputSystem.Key.F5, UnityEngine.InputSystem.Key.F6, UnityEngine.InputSystem.Key.F7, UnityEngine.InputSystem.Key.F8, UnityEngine.InputSystem.Key.F9, UnityEngine.InputSystem.Key.G, UnityEngine.InputSystem.Key.H, UnityEngine.InputSystem.Key.Home, UnityEngine.InputSystem.Key.I, UnityEngine.InputSystem.Key.Insert, UnityEngine.InputSystem.Key.J, UnityEngine.InputSystem.Key.K, UnityEngine.InputSystem.Key.L, UnityEngine.InputSystem.Key.LeftAlt, UnityEngine.InputSystem.Key.LeftApple, UnityEngine.InputSystem.Key.LeftArrow, UnityEngine.InputSystem.Key.LeftBracket, UnityEngine.InputSystem.Key.LeftCommand, UnityEngine.InputSystem.Key.LeftCtrl, UnityEngine.InputSystem.Key.LeftMeta, UnityEngine.InputSystem.Key.LeftShift, UnityEngine.InputSystem.Key.LeftWindows, UnityEngine.InputSystem.Key.M, UnityEngine.InputSystem.Key.Minus, UnityEngine.InputSystem.Key.N, UnityEngine.InputSystem.Key.NumLock, UnityEngine.InputSystem.Key.Numpad0, UnityEngine.InputSystem.Key.Numpad1, UnityEngine.InputSystem.Key.Numpad2, UnityEngine.InputSystem.Key.Numpad3, UnityEngine.InputSystem.Key.Numpad4, UnityEngine.InputSystem.Key.Numpad5, UnityEngine.InputSystem.Key.Numpad6, UnityEngine.InputSystem.Key.Numpad7, UnityEngine.InputSystem.Key.Numpad8, UnityEngine.InputSystem.Key.Numpad9, UnityEngine.InputSystem.Key.NumpadDivide, UnityEngine.InputSystem.Key.NumpadEnter, UnityEngine.InputSystem.Key.NumpadEquals, UnityEngine.InputSystem.Key.NumpadMinus, UnityEngine.InputSystem.Key.NumpadMultiply, UnityEngine.InputSystem.Key.NumpadPeriod, UnityEngine.InputSystem.Key.NumpadPlus, UnityEngine.InputSystem.Key.O, UnityEngine.InputSystem.Key.OEM1, UnityEngine.InputSystem.Key.OEM2, UnityEngine.InputSystem.Key.OEM3, UnityEngine.InputSystem.Key.OEM4, UnityEngine.InputSystem.Key.OEM5, UnityEngine.InputSystem.Key.P, UnityEngine.InputSystem.Key.PageDown, UnityEngine.InputSystem.Key.PageUp, UnityEngine.InputSystem.Key.Pause, UnityEngine.InputSystem.Key.Period, UnityEngine.InputSystem.Key.PrintScreen, UnityEngine.InputSystem.Key.Q, UnityEngine.InputSystem.Key.Quote, UnityEngine.InputSystem.Key.R, UnityEngine.InputSystem.Key.RightAlt, UnityEngine.InputSystem.Key.RightApple, UnityEngine.InputSystem.Key.RightArrow, UnityEngine.InputSystem.Key.RightBracket, UnityEngine.InputSystem.Key.RightCommand, UnityEngine.InputSystem.Key.RightCtrl, UnityEngine.InputSystem.Key.RightMeta, UnityEngine.InputSystem.Key.RightShift, UnityEngine.InputSystem.Key.RightWindows, UnityEngine.InputSystem.Key.S, UnityEngine.InputSystem.Key.ScrollLock, UnityEngine.InputSystem.Key.Semicolon, UnityEngine.InputSystem.Key.Slash, UnityEngine.InputSystem.Key.Space, UnityEngine.InputSystem.Key.T, UnityEngine.InputSystem.Key.Tab, UnityEngine.InputSystem.Key.U, UnityEngine.InputSystem.Key.UpArrow, UnityEngine.InputSystem.Key.V, UnityEngine.InputSystem.Key.W, UnityEngine.InputSystem.Key.X, UnityEngine.InputSystem.Key.Y, UnityEngine.InputSystem.Key.Z})); // ->> `new(System.Enum.GetValues<…>())`

      /* … */
      [GameMethod(AggressiveInlining)]
      internal static void Add(in Game.Collections.KeyInfo key) => Keys.OnKeyAdded(in key);

      [GameMethod(AggressiveInlining)] public        static bool HasActive(in System.ReadOnlySpan<UnityEngine.KeyCode>         keys)                                                            => Keys.HasHeld(keys)                                                       || Keys.HasPressed(keys)                                                       || Keys.HasReleased(keys);
      [GameMethod(AggressiveInlining)] public        static bool HasActive(in System.ReadOnlySpan<UnityEngine.InputSystem.Key> keys)                                                            => Keys.HasHeld(keys)                                                       || Keys.HasPressed(keys)                                                       || Keys.HasReleased(keys);
      [GameMethod(AggressiveInlining)] public        static bool HasActive(params UnityEngine.KeyCode[]                        keys)                                                            => Keys.HasHeld(new System.ReadOnlySpan<UnityEngine.KeyCode>        (keys)) || Keys.HasPressed(new System.ReadOnlySpan<UnityEngine.KeyCode>        (keys)) || Keys.HasReleased(new System.ReadOnlySpan<UnityEngine.KeyCode>        (keys));
      [GameMethod(AggressiveInlining)] public        static bool HasActive(params UnityEngine.InputSystem.Key[]                keys)                                                            => Keys.HasHeld(new System.ReadOnlySpan<UnityEngine.InputSystem.Key>(keys)) || Keys.HasPressed(new System.ReadOnlySpan<UnityEngine.InputSystem.Key>(keys)) || Keys.HasReleased(new System.ReadOnlySpan<UnityEngine.InputSystem.Key>(keys));
      [GameMethod(AggressiveInlining)] public unsafe static bool HasActive(in Game.Collections.DeviceState             state, in System.ReadOnlySpan<UnityEngine.KeyCode>         keys) { static UnityEngine.KeyCode         Decode(in Game.Collections.KeyInfo key) => key.codes.Item1; return Keys.HasActive(in state, in keys, &Decode); }
      [GameMethod(AggressiveInlining)] public unsafe static bool HasActive(in Game.Collections.DeviceState             state, in System.ReadOnlySpan<UnityEngine.InputSystem.Key> keys) { static UnityEngine.InputSystem.Key Decode(in Game.Collections.KeyInfo key) => key.codes.Item2; return Keys.HasActive(in state, in keys, &Decode); }
      [GameMethod(AggressiveInlining)] public        static bool HasActive(in Game.Collections.DeviceState             state, params UnityEngine.KeyCode[]                        keys) => Keys.HasActive(in state, new System.ReadOnlySpan<UnityEngine.KeyCode>        (keys));
      [GameMethod(AggressiveInlining)] public        static bool HasActive(in Game.Collections.DeviceState             state, params UnityEngine.InputSystem.Key[]                keys) => Keys.HasActive(in state, new System.ReadOnlySpan<UnityEngine.InputSystem.Key>(keys));

      [GameMethod(AggressiveInlining)]
      private unsafe static bool HasActive<T>(in Game.Collections.DeviceState state, in System.ReadOnlySpan<T> keys, in delegate*<in Game.Collections.KeyInfo, T> decoder) where T : unmanaged, System.Enum {
        if (Game.Collections.DeviceState.BEGIN   == state) return Keys.HasActive(Keys.BeginState,   in keys, in decoder);
        if (Game.Collections.DeviceState.CURRENT == state) return Keys.HasActive(Keys.CurrentState, in keys, in decoder);
        if (Game.Collections.DeviceState.END     == state) return Keys.HasActive(Keys.EndState,     in keys, in decoder);

        return false;
      }

      private unsafe static bool HasActive<T>(Game.Collections.RefList<Game.Collections.KeyInfo> state, in System.ReadOnlySpan<T> keys, in delegate*<in Game.Collections.KeyInfo, T> decoder) where T : unmanaged, System.Enum {
        fixed (T* address = keys)
        for (uint index = state.Count; 0u != index; ) {
          T code = decoder(in state[--index]);

          for (T* iterator = address + keys.Length; address != iterator; ) {
            if (Game.Collections.RefReadOnlyEqualityComparer<T>.Default.Equals(in code, in *--iterator))
            return true;
          }
        }

        return false;
      }

      [GameMethod(AggressiveInlining)] public static bool HasHeld    (in System.ReadOnlySpan<UnityEngine.KeyCode>         keys) => Keys.HasActive(in Game.Collections.DeviceState.CURRENT, keys);
      [GameMethod(AggressiveInlining)] public static bool HasHeld    (in System.ReadOnlySpan<UnityEngine.InputSystem.Key> keys) => Keys.HasActive(in Game.Collections.DeviceState.CURRENT, keys);
      [GameMethod(AggressiveInlining)] public static bool HasHeld    (params UnityEngine.KeyCode[]                        keys) => Keys.HasActive(in Game.Collections.DeviceState.CURRENT, new System.ReadOnlySpan<UnityEngine.KeyCode>        (keys));
      [GameMethod(AggressiveInlining)] public static bool HasHeld    (params UnityEngine.InputSystem.Key[]                keys) => Keys.HasActive(in Game.Collections.DeviceState.CURRENT, new System.ReadOnlySpan<UnityEngine.InputSystem.Key>(keys));
      [GameMethod(AggressiveInlining)] public static bool HasPressed (in System.ReadOnlySpan<UnityEngine.KeyCode>         keys) => Keys.HasActive(in Game.Collections.DeviceState.BEGIN,   keys);
      [GameMethod(AggressiveInlining)] public static bool HasPressed (in System.ReadOnlySpan<UnityEngine.InputSystem.Key> keys) => Keys.HasActive(in Game.Collections.DeviceState.BEGIN,   keys);
      [GameMethod(AggressiveInlining)] public static bool HasPressed (params UnityEngine.KeyCode[]                        keys) => Keys.HasActive(in Game.Collections.DeviceState.BEGIN,   new System.ReadOnlySpan<UnityEngine.KeyCode>        (keys));
      [GameMethod(AggressiveInlining)] public static bool HasPressed (params UnityEngine.InputSystem.Key[]                keys) => Keys.HasActive(in Game.Collections.DeviceState.BEGIN,   new System.ReadOnlySpan<UnityEngine.InputSystem.Key>(keys));
      [GameMethod(AggressiveInlining)] public static bool HasReleased(in System.ReadOnlySpan<UnityEngine.KeyCode>         keys) => Keys.HasActive(in Game.Collections.DeviceState.END,     keys);
      [GameMethod(AggressiveInlining)] public static bool HasReleased(in System.ReadOnlySpan<UnityEngine.InputSystem.Key> keys) => Keys.HasActive(in Game.Collections.DeviceState.END,     keys);
      [GameMethod(AggressiveInlining)] public static bool HasReleased(params UnityEngine.KeyCode[]                        keys) => Keys.HasActive(in Game.Collections.DeviceState.END,     new System.ReadOnlySpan<UnityEngine.KeyCode>        (keys));
      [GameMethod(AggressiveInlining)] public static bool HasReleased(params UnityEngine.InputSystem.Key[]                keys) => Keys.HasActive(in Game.Collections.DeviceState.END,     new System.ReadOnlySpan<UnityEngine.InputSystem.Key>(keys));

      [GameMethod(AggressiveInlining)] internal static void Prompt()                                        => Keys.OnPrompt    ();
      [GameMethod(AggressiveInlining)] internal static void Remove(in Game.Collections.KeyInfo key) => Keys.OnKeyRemoved(in key);
      [GameMethod(AggressiveInlining)] internal static void Update(in Game.Collections.KeyInfo key) => Keys.OnKeyUpdated(in key);
    }

    public static class Load {
      internal abstract class CachedIndex {}
      internal abstract class FailedIndex {}

      /* … */
      public   const           double                                                                                               Asynchronously    = 0.0;
      internal static          Unity.Collections.NativeArray<float>                                                                 AudioClipData     = new(0, Unity.Collections.Allocator.Persistent, Unity.Collections.NativeArrayOptions.UninitializedMemory);
      public   const           uint                                                                                                 Once              = 0u;
      internal static readonly Game.Collections.RefDictionary<(System.Type, System.Uri), Game.Collections.LoadInfo> Pending           = new(16u);
      public   const           uint                                                                                                 Persistently      = uint.MaxValue;
      public   const           double                                                                                               Synchronously     = double.PositiveInfinity;
      public   const           byte                                                                                                 WithCache         = (byte) 1u; // ->> `true`
      public   const           byte                                                                                                 WithoutCache      = (byte) 0u; // ->> `false`
      public   const           byte                                                                                                 WithReadOnlyCache = (byte) 2u; // ->> `true`

      /* … */
      [GameMethod(NoInlining)]
      private static void Idle(object? target, in Game.Events.LoadEvent data) {}

      private static T? Uri<T>(System.Uri path, Game.Handler<Game.Events.LoadEvent> callback, object? metadata, double timeout, bool cached, uint retries, System.Func<System.Uri, UnityEngine.Networking.UnityWebRequest> requester, System.Func<UnityEngine.Networking.UnityWebRequest, T?> loader, System.Func<T, T> recacher, Game.Handler<Game.Events.LoadEvent> fallback, bool restarted) where T : class? {
        ref Game.Collections.LoadInfo                load             = ref Load.Pending.TryAppend((typeof(T), path), new());
        uint                                                 attempts         = restarted ? load.events[0].metadata.data.attempts : 1u;
        uint                                                 attemptsAllowed  = System.Math.Min(retries, uint.MaxValue - 1u)      + 1u;
        Game.Collections.Mono<T>                     cachedPayload    = default;
        bool                                                 failed           = false; // ->> `UnityEngine.Networking.UnityWebRequest.Result.*Error`, `timeout`, …, e.t.c.
        uint                                                 loadHandlerIndex = restarted ? 0u : default;
        UnityEngine.Networking.UnityWebRequestAsyncOperation operation        = null!; // ->> Able to access the `UnityEngine.Application.streamingAssetsPath` directory
        bool                                                 requested        = restarted;
        System.Diagnostics.Stopwatch                         stopwatch        = new(); // ->> Track `timeout`

        /* … */
        [GameMethod(AggressiveInlining)]
        static ref readonly T GetCache(ref Game.Collections.LoadInfo load, ref Game.Collections.Mono<T> payload, System.Func<T, T> recacher) {
          payload = !payload ? recacher((T) load.cached!) : payload;
          return ref payload.Value;
        }

        [GameMethod(AggressiveInlining)]
        static void LoadCached(ref Game.Collections.LoadInfo load, ref Game.Collections.Mono<T> payload, System.Func<T, T> recacher) {
          Game.Collections.SharedList<Game.Collections.IndexFor<Load.CachedIndex>> resolved = new();

          // …
          for (uint index = resolved.IsEmpty() ? load.events.CountInvocationList() : resolved[resolved.Count - 1u].value; 0u != index--; ) {
            ref Game.Collections.HandlerInfo<Game.Events.LoadEvent> loadHandler = ref load.events[index];
            ref Game.Events.LoadEvent                                       loadEvent   = ref loadHandler.metadata;

            // …
            if (loadEvent.data.cached) {
              loadEvent.callback      = loadHandler.value;
              loadEvent.data.duration = UnityEngine.Time.realtimeSinceStartupAsDouble - loadEvent.data.duration;
              loadEvent.data.payload  = GetCache(ref load, ref payload, recacher);

              resolved.Add(index);
              loadHandler.Invoke();
            }
          }

          foreach (uint index in resolved)
            load.events.RemoveAt(index);

          resolved.Clear();
        }

        [GameMethod(AggressiveInlining)]
        static void LoadFailed(ref Game.Collections.LoadInfo load) {
          Game.Collections.SharedList<Game.Collections.IndexFor<Load.FailedIndex>> resolved = new();

          // …
          load.payload = null;

          for (uint index = resolved.IsEmpty() ? load.events.CountInvocationList() : resolved[resolved.Count - 1u].value; 0u != index--; ) {
            ref Game.Collections.HandlerInfo<Game.Events.LoadEvent> loadHandler = ref load.events[index];
            ref Game.Events.LoadEvent                                       loadEvent   = ref loadHandler.metadata;
            Game.Handler<Game.Events.LoadEvent>                     fallback    = loadEvent.callback;

            // …
            if (loadEvent.data.attempts == loadEvent.data.attemptsAllowed) {
              loadEvent.callback      = loadHandler.value;
              loadEvent.data.duration = UnityEngine.Time.realtimeSinceStartupAsDouble - loadEvent.data.duration;
              load.events[index]      = new(fallback, loadHandler.target, loadHandler.metadata);

              resolved.Add(index);
              loadHandler.Invoke();
            } else ++loadEvent.data.attempts;
          }

          foreach (uint index in resolved)
            load.events.RemoveAt(index);

          resolved.Clear();
        }

        [GameMethod(AggressiveInlining)]
        /*static*/ T? LoadSucceeded(ref Game.Collections.LoadInfo load, UnityEngine.Networking.UnityWebRequest handler, System.Func<UnityEngine.Networking.UnityWebRequest, T?> loader) {
          T? payload = loader(handler);

          // …
          load.payload = payload;

          if (payload is not null) {
            if (load.cached is not null && typeof(T) == typeof(UnityEngine.Networking.DownloadHandler))
              ((UnityEngine.Networking.DownloadHandler) load.cached).Dispose();

            load.cached = payload;
          }

          foreach (ref Game.Collections.HandlerInfo<Game.Events.LoadEvent> loadHandler in load.events) {
            ref Game.Events.LoadEvent loadEvent = ref loadHandler.metadata;

            // …
            loadEvent.callback      = loadHandler.value;
            loadEvent.data.duration = UnityEngine.Time.realtimeSinceStartupAsDouble - loadEvent.data.duration;
            loadEvent.data.payload  = payload;

            loadHandler.Invoke();
          }

          load.events.Clear();

          return payload;
        }

        [GameMethod(Synchronized)]
        /* static */ void LoadUri(UnityEngine.AsyncOperation _) /* ->> Captures `loader` and `path` */ {
          UnityEngine.Networking.UnityWebRequestAsyncOperation operation        = (UnityEngine.Networking.UnityWebRequestAsyncOperation) _;
          ref Game.Collections.LoadInfo                load             = ref Load.Pending[(typeof(T), path)];
          int                                                  loadHandlerIndex = load.events.FindIndex([GameMethod(AggressiveInlining)] (loadHandler) => loadHandler.target == operation);

          // …
          using (UnityEngine.Networking.UnityWebRequest request = operation.webRequest) // ->> `request.uri` could be modified through redirection unless `::redirectLimit = 0`
          if (loadHandlerIndex != -1) {
            ref Game.Collections.HandlerInfo<Game.Events.LoadEvent> loadHandler = ref load.events[(uint) loadHandlerIndex];

            if (UnityEngine.Networking.UnityWebRequest.Result.Success != request.result) {
              request.disposeDownloadHandlerOnDispose = true;

              if (loadHandler.metadata.data.attempts != loadHandler.metadata.data.attemptsAllowed) {
                operation                                            = requester(path).SendWebRequest();
                operation.completed                                 += LoadUri;
                operation.webRequest.disposeDownloadHandlerOnDispose = typeof(T) != typeof(UnityEngine.Networking.DownloadHandler);
                loadHandler.metadata.data.attempts                  += 1u;
                load.events[(uint) loadHandlerIndex]                 = new(loadHandler.value, operation, loadHandler.metadata);
              }

              else {
                LoadFailed(ref load);

                if (!load.events.IsEmpty())
                ReloadUri(ref load, requester, loader, recacher);
              }
            } else LoadSucceeded(ref load, request, loader);
          }
        }

        [GameMethod(AggressiveInlining)]
        static void ReloadUri(ref Game.Collections.LoadInfo load, System.Func<System.Uri, UnityEngine.Networking.UnityWebRequest> requester, System.Func<UnityEngine.Networking.UnityWebRequest, T?> loader, System.Func<T, T> recacher) /* ->> Use pending asynchronous handler to get payload (ideally does not raise a `System.StackOverflowException`) */ {
          ref Game.Collections.HandlerInfo<Game.Events.LoadEvent> loadHandler = ref load.events[0];
          Load.Uri<T>(loadHandler.metadata.data.path, loadHandler.value, null, Load.Asynchronously, loadHandler.metadata.data.cached, loadHandler.metadata.data.attemptsAllowed - 1u, requester, loader, recacher, loadHandler.metadata.callback, true);
        }

        // … ->> Get cache
        if (load.cached is not null) {
          LoadCached(ref load, ref cachedPayload, recacher);

          if (cached) {
            if      (!restarted)             callback(null, new() {callback = callback, data = (attempts, attemptsAllowed, true, 0.0, path, GetCache(ref load, ref cachedPayload, recacher))}); // ->> Otherwise already cleared and invoked via `LoadCached(…)`
            else if (!load.events.IsEmpty()) ReloadUri(ref load, requester, loader, recacher);                                                                                                    // ->> Avoid dead-locking the load queue

            return GetCache(ref load, ref cachedPayload, recacher);
          }
        }

        // … ->> Get payload
        do {
          stopwatch.Restart();

          // … ->> Wait in load queue until prior handler is complete
          if (!requested && !load.events.IsEmpty()) {
            // … ->> `Load.Asynchronously` — Handler awaits completion of predecessor
            if (double.IsNaN(timeout) || 0.0 >= timeout) {
              stopwatch.Stop();
              load.events += new Game.Collections.HandlerInfo<Game.Events.LoadEvent>(callback, null, new() {callback = fallback, data = (attempts - 1u, attemptsAllowed, cached, UnityEngine.Time.realtimeSinceStartupAsDouble, path, null), metadata = metadata});

              return null;
            }

            // … ->> `Load.Synchronously` — Handler blocks until completion of predecessor
            else {
              while (!load.events.IsEmpty() && stopwatch.Elapsed.TotalSeconds < timeout)                                 continue; // ->> `while …`
              if    (attempts != attemptsAllowed && (load.payload is null || stopwatch.Elapsed.TotalSeconds >= timeout)) continue; // ->> `do … while`

              stopwatch.Stop();
              (load.payload is not null ? callback : fallback)(null, new() {callback = callback, data = (attempts, attemptsAllowed, cached, stopwatch.Elapsed.TotalSeconds, path, load.payload)});

              return load.payload as T;
            }
          }

          // … ->> Future handlers will wait on this handler to complete
          failed                                               = false;
          operation                                            = requester(path).SendWebRequest(); // ->> Was unaware of `int UnityEngine.Networking.UnityWebRequest::timeout` beforehand
          operation.webRequest.disposeDownloadHandlerOnDispose = typeof(T) != typeof(UnityEngine.Networking.DownloadHandler);

          if (!requested) {
            loadHandlerIndex = load.events.CountInvocationList();
            load.events     += new Game.Collections.HandlerInfo<Game.Events.LoadEvent>(callback, operation, new() {callback = fallback, data = (attempts - 1u, attemptsAllowed, cached, UnityEngine.Time.realtimeSinceStartupAsDouble, path, null), metadata = metadata});
          }

          load.events[loadHandlerIndex] = new(load.events[loadHandlerIndex].value, operation, load.events[loadHandlerIndex].metadata);
          requested                     = true;

          for (UnityEngine.Networking.UnityWebRequest request = operation.webRequest; !failed && UnityEngine.Networking.UnityWebRequest.Result.Success != request.result; failed = failed || UnityEngine.Networking.UnityWebRequest.Result.ConnectionError == request.result || UnityEngine.Networking.UnityWebRequest.Result.DataProcessingError == request.result || UnityEngine.Networking.UnityWebRequest.Result.ProtocolError == request.result)
          if (UnityEngine.Networking.UnityWebRequest.Result.InProgress == request.result) {
            // … ->> `Load.Asynchronously`
            if (double.IsNaN(timeout) || 0.0 >= timeout) {
              operation.completed += LoadUri;
              return null;
            }

            // … ->> `Load.Synchronously`
            failed = stopwatch.Elapsed.TotalSeconds >= timeout;
          }

          using (UnityEngine.Networking.UnityWebRequest request = operation.webRequest) {
            ++load.events[loadHandlerIndex].metadata.data.attempts;

            if (failed) {
              request.disposeDownloadHandlerOnDispose = true;
              continue;
            }

            stopwatch.Stop();
            return LoadSucceeded(ref load, request, loader);
          }
        } while (attempts++ != attemptsAllowed);

        // … ->> Allow pending handlers to get payload (or available cache)
        if (failed) {
          LoadFailed(ref load);
          if (!load.events.IsEmpty()) ReloadUri(ref load, requester, loader, recacher);
        }

        return null;
      }

      [GameMethod(AggressiveInlining)] public static Unity.Collections.NativeArray<byte>.ReadOnly? Uri(System.Uri path, System.Action       <object?>?                       callback = null,                          double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.Uri(path, Game.Events.ToMetadataHandler<Game.Events.LoadEvent>(callback!), null,     timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static Unity.Collections.NativeArray<byte>.ReadOnly? Uri(System.Uri path, System.Action       <object?>?                       callback = null, object? metadata = null, double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.Uri(path, Game.Events.ToMetadataHandler<Game.Events.LoadEvent>(callback!), metadata, timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static Unity.Collections.NativeArray<byte>.ReadOnly? Uri(System.Uri path, Game.Handler<Game.Events.LoadEvent>? callback = null,                          double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.Uri(path, callback,                                                                        null,     timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)]
      public static Unity.Collections.NativeArray<byte>.ReadOnly? Uri(System.Uri path, Game.Handler<Game.Events.LoadEvent>? callback = null, object? metadata = null, double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.Uri<UnityEngine.Networking.DownloadHandler>(
        path,
        callback is null ? Load.Idle : [GameMethod(AggressiveInlining)] (object? target, in Game.Events.LoadEvent data) => callback(target, new() {callback = callback, data = (data.data.attempts, data.data.attemptsAllowed, data.data.cached, data.data.duration, data.data.path, ((UnityEngine.Networking.DownloadHandler) data.data.payload!).nativeData), epoch = data.epoch, metadata = data.metadata}),
        metadata, timeout, Load.WithoutCache < cached, retries,
        [GameMethod(AggressiveInlining)] static (path)    => UnityEngine.Networking.UnityWebRequest.Get(path),
        [GameMethod(AggressiveInlining)] static (request) => request.downloadHandler,
        [GameMethod(AggressiveInlining)] static (cached)  => cached,
        fallback ?? Load.Idle,
        false
      )?.nativeData;

      [GameMethod(AggressiveInlining)] public static UnityEngine.AudioClip? UriAsAudioClip(System.Uri path,                                 System.Action       <object?>?                       callback = null,                          double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsAudioClip(path, UnityEngine.AudioType.MPEG, Game.Events.ToMetadataHandler<Game.Events.LoadEvent>(callback!), null,     timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static UnityEngine.AudioClip? UriAsAudioClip(System.Uri path,                                 System.Action       <object?>?                       callback = null, object? metadata = null, double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsAudioClip(path, UnityEngine.AudioType.MPEG, Game.Events.ToMetadataHandler<Game.Events.LoadEvent>(callback!), metadata, timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static UnityEngine.AudioClip? UriAsAudioClip(System.Uri path, UnityEngine.AudioType encoding, System.Action       <object?>?                       callback = null,                          double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsAudioClip(path, encoding,                   Game.Events.ToMetadataHandler<Game.Events.LoadEvent>(callback!), null,     timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static UnityEngine.AudioClip? UriAsAudioClip(System.Uri path, UnityEngine.AudioType encoding, System.Action       <object?>?                       callback = null, object? metadata = null, double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsAudioClip(path, encoding,                   Game.Events.ToMetadataHandler<Game.Events.LoadEvent>(callback!), metadata, timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static UnityEngine.AudioClip? UriAsAudioClip(System.Uri path,                                 Game.Handler<Game.Events.LoadEvent>? callback = null,                          double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsAudioClip(path, UnityEngine.AudioType.MPEG, callback,                                                                        null,     timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static UnityEngine.AudioClip? UriAsAudioClip(System.Uri path,                                 Game.Handler<Game.Events.LoadEvent>? callback = null, object? metadata = null, double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsAudioClip(path, UnityEngine.AudioType.MPEG, callback,                                                                        metadata, timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static UnityEngine.AudioClip? UriAsAudioClip(System.Uri path, UnityEngine.AudioType encoding, Game.Handler<Game.Events.LoadEvent>? callback = null,                          double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsAudioClip(path, encoding,                   callback,                                                                        null,     timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)]
      public static UnityEngine.AudioClip? UriAsAudioClip(System.Uri path, UnityEngine.AudioType encoding, Game.Handler<Game.Events.LoadEvent>? callback = null, object? metadata = null, double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.Uri<UnityEngine.AudioClip>(
        path, callback ?? Load.Idle, metadata, timeout, Load.WithoutCache < cached, retries,
        [GameMethod(AggressiveInlining)]        (path)    => UnityEngine.Networking.UnityWebRequestMultimedia.GetAudioClip(path, encoding),
        [GameMethod(AggressiveInlining)] static (request) => {
          UnityEngine.AudioClip? audioClip = UnityEngine.Networking.DownloadHandlerAudioClip.GetContent(request); // ->> `((UnityEngine.Networking.DownloadHandlerAudioClip) request.downloadHandler).audioClip`

          // …
          if (null != audioClip)
          audioClip.name = $"🎵 {System.IO.Path.GetFileName(request.url)}";

          return audioClip;
        },
        Load.WithReadOnlyCache == cached ? ([GameMethod(AggressiveInlining)] static (cached) => cached) : ([GameMethod(AggressiveInlining)] static (cached) => {
          UnityEngine.AudioClip cachedAudioClip         = (UnityEngine.AudioClip) cached;
          int                   cachedAudioClipDataSize = cachedAudioClip.channels * cachedAudioClip.samples;
          UnityEngine.AudioClip audioClip               = cachedAudioClip;

          // …
          if (int.MaxValue / cachedAudioClip.channels >= cachedAudioClip.samples) do {
            if (cachedAudioClipDataSize > Load.AudioClipData.Length) {
              Load.AudioClipData.Dispose();
              Load.AudioClipData = new(cachedAudioClipDataSize, Unity.Collections.Allocator.Persistent, Unity.Collections.NativeArrayOptions.UninitializedMemory);
            }

            if (!cachedAudioClip.GetData(Load.AudioClipData, 0)) break;
            audioClip = UnityEngine.AudioClip.Create(cachedAudioClip.name, cachedAudioClip.samples, cachedAudioClip.channels, cachedAudioClip.frequency, false);

            if (!audioClip.SetData(Load.AudioClipData, 0))
            return cachedAudioClip;
          } while (false);

          return audioClip;
        }),
        fallback ?? Load.Idle,
        false
      );

      [GameMethod(AggressiveInlining)] public static string? UriAsText(System.Uri path,                                System.Action       <object?>?                       callback = null,                          double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsText(path, System.Text.Encoding.UTF8, Game.Events.ToMetadataHandler<Game.Events.LoadEvent>(callback!), null,     timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static string? UriAsText(System.Uri path,                                System.Action       <object?>?                       callback = null, object? metadata = null, double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsText(path, System.Text.Encoding.UTF8, Game.Events.ToMetadataHandler<Game.Events.LoadEvent>(callback!), metadata, timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static string? UriAsText(System.Uri path, System.Text.Encoding encoding, System.Action       <object?>?                       callback = null,                          double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsText(path, encoding,                  Game.Events.ToMetadataHandler<Game.Events.LoadEvent>(callback!), null,     timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static string? UriAsText(System.Uri path, System.Text.Encoding encoding, System.Action       <object?>?                       callback = null, object? metadata = null, double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsText(path, encoding,                  Game.Events.ToMetadataHandler<Game.Events.LoadEvent>(callback!), metadata, timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static string? UriAsText(System.Uri path,                                Game.Handler<Game.Events.LoadEvent>? callback = null,                          double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsText(path, System.Text.Encoding.UTF8, callback,                                                                        null,     timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static string? UriAsText(System.Uri path,                                Game.Handler<Game.Events.LoadEvent>? callback = null, object? metadata = null, double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsText(path, System.Text.Encoding.UTF8, callback,                                                                        metadata, timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static string? UriAsText(System.Uri path, System.Text.Encoding encoding, Game.Handler<Game.Events.LoadEvent>? callback = null,                          double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsText(path, encoding,                  callback,                                                                        null,     timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)]
      public static string? UriAsText(System.Uri path, System.Text.Encoding encoding, Game.Handler<Game.Events.LoadEvent>? callback = null, object? metadata = null, double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.Uri<string>(
        path, callback ?? Load.Idle, metadata, timeout, Load.WithoutCache < cached, retries,
        [GameMethod(AggressiveInlining)] static (path) => UnityEngine.Networking.UnityWebRequest.Get(path),
        encoding is System.Text.UTF8Encoding ? ([GameMethod(AggressiveInlining)] static (request) => request.downloadHandler.text) : ([GameMethod(AggressiveInlining)] (request) => {
          try { return encoding.GetString(request.downloadHandler.nativeData.AsReadOnlySpan()); }
          catch (System.Exception exception) when (exception is System.ArgumentException || exception is System.ArgumentNullException || exception is System.Text.DecoderFallbackException) {}

          return null;
        }),
        [GameMethod(AggressiveInlining)] static (cached) => cached,
        fallback ?? Load.Idle,
        false
      );

      [GameMethod(AggressiveInlining)] public static UnityEngine.Texture2D? UriAsTexture2D(System.Uri path, System.Action       <object?>?                       callback = null,                          double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsTexture2D(path, Game.Events.ToMetadataHandler<Game.Events.LoadEvent>(callback!), null,     timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Texture2D? UriAsTexture2D(System.Uri path, System.Action       <object?>?                       callback = null, object? metadata = null, double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsTexture2D(path, Game.Events.ToMetadataHandler<Game.Events.LoadEvent>(callback!), metadata, timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Texture2D? UriAsTexture2D(System.Uri path, Game.Handler<Game.Events.LoadEvent>? callback = null,                          double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.UriAsTexture2D(path, callback,                                                                        null,     timeout, cached, retries, fallback);
      [GameMethod(AggressiveInlining)]
      public static UnityEngine.Texture2D? UriAsTexture2D(System.Uri path, Game.Handler<Game.Events.LoadEvent>? callback = null, object? metadata = null, double timeout = Load.Asynchronously, byte cached = Load.WithCache, uint retries = Load.Persistently, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Load.Uri<UnityEngine.Texture2D>(
        path, callback ?? Load.Idle, metadata, timeout, Load.WithoutCache < cached, retries,
        [GameMethod(AggressiveInlining)] static (path)    => UnityEngine.Networking.UnityWebRequest.Get(path),
        [GameMethod(AggressiveInlining)] static (request) => {
          UnityEngine.Texture2D texture = new(2, 2, UnityEngine.TextureFormat.RGBA32, -1, false);

          texture.name = $"🖼️ {System.IO.Path.GetFileName(request.url)}";
          return UnityEngine.ImageConversion.LoadImage(texture, request.downloadHandler.data, true) ? texture : null;
        },
        Load.WithReadOnlyCache == cached ? ([GameMethod(AggressiveInlining)] static (cached) => cached) : ([GameMethod(AggressiveInlining)] static (cached) => {
          UnityEngine.Texture2D cachedTexture = (UnityEngine.Texture2D) cached;
          UnityEngine.Texture2D texture       = cachedTexture;

          // …
          texture      = new(cachedTexture.width, cachedTexture.height, cachedTexture.format, cachedTexture.mipmapCount, false);
          texture.name = cachedTexture.name;
          UnityEngine.Graphics.CopyTexture(cachedTexture, texture);

          return texture;
        }),
        fallback ?? Load.Idle,
        false
      );
    }

    public static class Log {
      public  static          UnityEngine.Color                       BooleanColor                     = UnityEngine.Color.dodgerBlue;
      public  static          UnityEngine.Color                       BytesColor                       = UnityEngine.Color.greenYellow;
      public  static          UnityEngine.Color                       DateTimeColor                    = UnityEngine.Color.blueViolet;
      public  static          UnityEngine.Color                       DecimalColor                     = UnityEngine.Color.darkSeaGreen;
      public  static          UnityEngine.Color                       DoubleColor                      = UnityEngine.Color.seaGreen;
      public  static          UnityEngine.Color                       EnumerableColor                  = UnityEngine.Color.mediumTurquoise;
      public  static          uint                                    EnumerablesMaximumEntries        = 10u;
      public  static          bool                                    EnumerablesStringsDelimited      = true;
      public  static          UnityEngine.Color                       EnumerationColor                 = UnityEngine.Color.turquoise;
      public  static          UnityEngine.Color                       ErrorColor                       = UnityEngine.Color.red;
      public  static          UnityEngine.Color                       ExceptionColor                   = UnityEngine.Color.maroon;
      public  static          bool                                    Formatted                        = true;
      public  static          UnityEngine.Color                       FloatColor                       = UnityEngine.Color.lightSeaGreen;
      public  static          UnityEngine.Color                       InformationColor                 = UnityEngine.Color.deepSkyBlue;
      public  static          UnityEngine.Color                       IntegerColor                     = UnityEngine.Color.mediumSeaGreen;
      public  static          UnityEngine.Color                       PointerColor                     = UnityEngine.Color.mediumSeaGreen;
      private static readonly System.Collections.Generic.List<object> Recursives                       = new(1);
      private static readonly string                                  RecursiveEntry                   = "{…}";
      public  static          UnityEngine.Color                       RecursiveEntryColor              = UnityEngine.Color.firebrick;
      public  static          UnityEngine.Color                       StringColor                      = UnityEngine.Color.orange;
      public  static          bool                                    StringsDelimited                 = true;
      public  static          bool                                    StringsDelimitedAlways           = false;
      public  static          UnityEngine.Color                       TypeColor                        = UnityEngine.Color.purple;
      public  static          UnityEngine.Color                       UnityColor                       = UnityEngine.Color.olive;
      private static          System.Reflection.Assembly?             UnityEditorLogAssembly           = null;
      private static          System.Reflection.MethodInfo?           UnityEditorLogEntriesClearMethod = null;
      private static          System.Type?                            UnityEditorLogEntriesType        = null;
      public  static          UnityEngine.Color                       UriColor                         = UnityEngine.Color.cyan;
      public  static          UnityEngine.Color                       WarningColor                     = UnityEngine.Color.yellow;

      /* … */
      [GameMethod(AggressiveInlining)]
      public static void Clear() {
        Log.UnityEditorLogEntriesType ??= System.Type.GetType("UnityEditor.LogEntries");
        Log.UnityEditorLogEntriesType ??= System.Type.GetType("UnityEditorInternal.LogEntries");

        #if UNITY_EDITOR
          if (Log.UnityEditorLogEntriesType is null) {
            Log.UnityEditorLogAssembly ??= System.Reflection.Assembly.GetAssembly(typeof(UnityEditor.ActiveEditorTracker));
            Log.UnityEditorLogAssembly ??= System.Reflection.Assembly.GetAssembly(typeof(UnityEditor.Editor));
            Log.UnityEditorLogAssembly ??= System.Reflection.Assembly.GetAssembly(typeof(UnityEditor.SceneView));

            if (Log.UnityEditorLogAssembly is not null) {
              Log.UnityEditorLogEntriesType ??= Log.UnityEditorLogAssembly.GetType("UnityEditor.LogEntries");
              Log.UnityEditorLogEntriesType ??= Log.UnityEditorLogAssembly.GetType("UnityEditorInternal.LogEntries");
            }
          }
        #endif

        Log.UnityEditorLogEntriesClearMethod ??= Log.UnityEditorLogEntriesType?.GetMethod("Clear"); // ->> `System.Reflection.BindingFlags.Public`

        // …
        UnityEngine.Debug.ClearDeveloperConsole(); // ->> `UnityEngine.Debug.developerConsoleVisible`
        Log.UnityEditorLogEntriesClearMethod?.Invoke(new object(), null);
      }

      [GameMethod(AggressiveInlining)]
      public static void Print(object? value) {
        bool stringsDelimitedAlways = Log.StringsDelimitedAlways;

        // … ->> Ignore null values
        Log.StringsDelimitedAlways = Log.StringsDelimited;

        if (value is not null) {
          System.Console.WriteLine(Log.ToString(value));
          #if UNITY_EDITOR
            UnityEngine.Debug.Log(Log.ToString(value, Log.Formatted));
          #endif
        }

        Log.StringsDelimitedAlways = stringsDelimitedAlways;
      }

      public static void Print(params object?[] values) /* ->> Modifies possible pre-existing `values` array */ {
        uint length = (uint) values.Length;

        // …
        for (uint index = length; 0u != index--; ) {
          // ->> Ignore null values
          if (Util.Reference<object?>.At(values, index) is null)
          Util.Array<object?>.Copy(values, index + 1u, values, index, --length - index);
        }

        // …
        if (length == 1u)
          Log.Print(Util.Reference<object?>.Only(values));

        else if (0u != length) {
          System.Array.Resize(ref values, (int) length);
          System.Console.WriteLine(string.Join(' ', values.ConvertAll(Log.ToString<object?>)));
          #if UNITY_EDITOR
            UnityEngine.Debug.Log(string.Join(' ', values.ConvertAll(static _ => Log.ToString<object?>(_, Log.Formatted))));
          #endif
        }
      }

      [GameMethod(AggressiveInlining)] private static string ToString<T>(T value)                 => Log.ToString(value, false,     false);
      [GameMethod(AggressiveInlining)] private static string ToString<T>(T value, bool formatted) => Log.ToString(value, formatted, false);
      [GameMethod(AggressiveInlining)]
      private unsafe static string ToString<T>(in T value, bool formatted, bool recursive) {
        #pragma warning disable CS0219 // ->> “ThE VaRiAbLe '…' iS AsSiGnEd bUt iTs vAlUe iS NeVeR UsEd.”
          char                                                              containerBegin = '[', containerEnd = ']';
          bool                                                              embolden, italicize, underline;
          delegate*<string, in UnityEngine.Color, bool, bool, bool, string> format            = formatted ? &ToFormattedString : &ToUnformattedString;
          UnityEngine.Color32?                                              valueAsColor32    = null;
          object[]?                                                         valueAsEnumerable = null;
        #pragma warning restore CS0219

        // …
        [GameMethod(AggressiveInlining)] static string ColorToFormattedString  (in UnityEngine.Color color)                                                                            => UnityEngine.ColorUtility.ToHtmlStringRGB(color);
        [GameMethod(AggressiveInlining)] static string DecimalToFormattedString(decimal              value)                                                                            => value.ToString("0.000###") + 'm';
        [GameMethod(AggressiveInlining)] static string DoubleToFormattedString (double               value)                                                                            => !double.IsInfinity(value) && !double.IsNaN(value) ? value.ToString("0.00####") : value.ToString();
        [GameMethod(AggressiveInlining)] static string Escape                  (string               value)                                                                            => value.Replace("<", "＜", System.StringComparison.OrdinalIgnoreCase).Replace("＞", "&gt;", System.StringComparison.OrdinalIgnoreCase); // ->> Replace rich text tag tokens with their full-width counterparts
        [GameMethod(AggressiveInlining)] static string FloatToFormattedString  (float                value)                                                                            => !float.IsInfinity(value) && !float.IsNaN(value) ? value.ToString("0.0#####") + 'f' : value.ToString();
        [GameMethod(AggressiveInlining)] static bool   Recur                   (object               value, bool recursive)                                                            { if (!recursive) Log.Recursives.Clear(); if (Log.Recursives.Contains(value)) return true; Log.Recursives.Add(value); return false; }
        [GameMethod(AggressiveInlining)] static string ToFormattedString       (string               value, in UnityEngine.Color color, bool embolden, bool italicize, bool underline) => $"<color=#{ColorToFormattedString(color)}>{(underline ? "<u>" : string.Empty)}{(embolden ? "<b>" : string.Empty)}{(italicize ? "<i>" : string.Empty)}{value}{(italicize ? "</i>" : string.Empty)}{(embolden ? "</b>" : string.Empty)}{(underline ? "</u>" : string.Empty)}</color>";
        [GameMethod(AggressiveInlining)] static string ToUnformattedString     (string               value, in UnityEngine.Color color, bool embolden, bool italicize, bool underline) => value;

        // … ->> Basic types
        if (value is null)                            return string.Empty;
        if (value is bool    boolean)                 return format(boolean.ToString(),                                                                      Log.BooleanColor,     embolden = false, italicize = false, underline = false);
        if (value is byte    bits && recursive)       return format($"0x{bits.ToString("X2")}",                                                              Log.BytesColor,       embolden = false, italicize = true,  underline = false);
        if (value is decimal numberA)                 return format(DecimalToFormattedString(numberA),                                                       Log.DecimalColor,     embolden = false, italicize = false, underline = false);
        if (value is double  numberB)                 return format(DoubleToFormattedString (numberB),                                                       Log.DoubleColor,      embolden = false, italicize = false, underline = false);
        if (value is float   numberC)                 return format(FloatToFormattedString  (numberC),                                                       Log.FloatColor,       embolden = false, italicize = false, underline = false);
        if (value is int  or nint or sbyte or short)  return format(value.ToString(),                                                                        Log.IntegerColor,     embolden = false, italicize = false, underline = false);
        if (value is long)                            return format($"{value.ToString()}L",                                                                  Log.IntegerColor,     embolden = false, italicize = false, underline = false);
        if (value is nuint or uint or ushort or byte) return format($"{value.ToString()}u",                                                                  Log.IntegerColor,     embolden = false, italicize = false, underline = false);
        if (value is ulong)                           return format($"{value.ToString()}uL",                                                                 Log.IntegerColor,     embolden = false, italicize = false, underline = false);
        if (value is UnityEngine.LayerMask layerMask) return format($"{typeof(UnityEngine.LayerMask)}.{UnityEngine.LayerMask.LayerToName(layerMask.value)}", Log.EnumerationColor, embolden = false, italicize = false, underline = false);
        if (value is System.DateTime)                 return format(value.ToString(),                                                                        Log.DateTimeColor,    embolden = false, italicize = true,  underline = false);
        if (value is System.Enum)                     return format(value.ToString(),                                                                        Log.EnumerationColor, embolden = true,  italicize = false, underline = false);
        if (value is System.Exception)                return format(value.ToString(),                                                                        Log.ExceptionColor,   embolden = false, italicize = false, underline = false);
        if (value is System.Index   subindex)         return format(subindex.ToString(),                                                                     Log.IntegerColor,     embolden = false, italicize = false, underline = false);
        if (value is System.IntPtr  pointerA)         return format($"@{pointerA.ToInt64().ToString("x16")}",                                                Log.PointerColor,     embolden = false, italicize = false, underline = false);
        if (value is System.Range   range)            return format(range.ToString(),                                                                        Log.IntegerColor,     embolden = false, italicize = false, underline = false);
        if (value is System.Type    type)             return format($"typeof({type})",                                                                       Log.TypeColor,        embolden = false, italicize = false, underline = false);
        if (value is System.UIntPtr pointerB)         return format($"@{pointerB.ToUInt64().ToString("x16")}u",                                              Log.PointerColor,     embolden = false, italicize = false, underline = false);
        if (value is System.Uri     uri)              return format(uri.ToString(),                                                                          Log.StringColor,      embolden = false, italicize = false, underline = true);

        if (value is string text) {
          bool   textIsUri = System.Uri.TryCreate(text, System.UriKind.Absolute, out System.Uri _);
          string textUri   = formatted && textIsUri ? System.Uri.EscapeDataString(text).Replace("<", "%3C", System.StringComparison.OrdinalIgnoreCase).Replace(">", "%3E", System.StringComparison.OrdinalIgnoreCase) : string.Empty;

          // …
          text = Escape(text);
          text = formatted && textIsUri ? $"<u><link=\"{textUri}\"><color=#{ColorToFormattedString(Log.UriColor)}>{text}</color></link></u>" : text;

          return format(!Log.StringsDelimitedAlways && (recursive ? !Log.EnumerablesStringsDelimited : true) ? text : 0 == text.Length || text.Length != 1 ? $"“{text.Replace("“", "\\“", System.StringComparison.OrdinalIgnoreCase).Replace("”", "\\”", System.StringComparison.OrdinalIgnoreCase)}”" : $"‘{text.Replace("‘", "\\‘", System.StringComparison.OrdinalIgnoreCase).Replace("’", "\\’", System.StringComparison.OrdinalIgnoreCase)}’", Log.StringColor, embolden = false, italicize = false, underline = false);
        }

        // … ->> Foundational types (RIP `UnityEngine.Animation…Info`, `UnityEngine.ContactPoint…`, `UnityEngine.DrivenRectTransformTracker`, `UnityEngine.HumanBone`, `UnityEngine.JointAngleLimits2D`, `UnityEngine.Matrix4x4`, `UnityEngine.RaycastHit…`, `UnityEngine.RenderTextureDescriptor`, `UnityEngine.SkeletonBone`, `UnityEngine.WaitFor…` …)
        if (value is Game.Collections.DeviceState state)                    return formatted ? $"<color=#{ColorToFormattedString(Log.EnumerationColor)}>{state}</color>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        : state.ToString()!;
        if (value is Game.Collections.Vector2Bool vectorA)                  return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b><color=#{ColorToFormattedString(Log.BooleanColor)}>{vectorA.x}</color>, <color=#{ColorToFormattedString(Log.BooleanColor)}>{vectorA.y}</color><b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        : $"{containerBegin}{vectorA.x}, {vectorA.y}{containerEnd}";
        if (value is Game.Collections.Vector3Bool vectorB)                  return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b><color=#{ColorToFormattedString(Log.BooleanColor)}>{vectorB.x}</color>, <color=#{ColorToFormattedString(Log.BooleanColor)}>{vectorB.y}</color>, <color=#{ColorToFormattedString(Log.BooleanColor)}>{vectorB.z}</color><b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                : $"{containerBegin}{vectorB.x}, {vectorB.y}, {vectorB.z}{containerEnd}";
        if (value is Game.Collections.Vector4Bool vectorC)                  return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b><color=#{ColorToFormattedString(Log.BooleanColor)}>{vectorC.x}</color>, <color=#{ColorToFormattedString(Log.BooleanColor)}>{vectorC.y}</color>, <color=#{ColorToFormattedString(Log.BooleanColor)}>{vectorC.z}</color>, <color=#{ColorToFormattedString(Log.BooleanColor)}>{vectorC.w}</color><b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                        : $"{containerBegin}{vectorC.x}, {vectorC.y}, {vectorC.z}, {vectorC.w}{containerEnd}";
        if (value is UnityEngine.Bounds                   bounds)                   return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>center: {Log.ToString(bounds.center, true, true)}, size: {Log.ToString(bounds.size, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      : $"{containerBegin}center: {Log.ToString(bounds.center, false, true)}, size: {Log.ToString(bounds.size, false, true)}{containerEnd}";
        if (value is UnityEngine.BoundsInt                boundsInt)                return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>center: {Log.ToString(Util.Vector.ToInt(boundsInt.center), true, true)}, size: {Log.ToString(Util.Vector.ToInt(boundsInt.size), true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          : $"{containerBegin}center: {Log.ToString(Util.Vector.ToInt(boundsInt.center), false, true)}, size: {Log.ToString(Util.Vector.ToInt(boundsInt.size), false, true)}{containerEnd}";
        if (value is UnityEngine.GameObject               gameObject)               return formatted ? $"{Log.ToString(gameObject.name, true, true)} <color=#{ColorToFormattedString(Log.UnityColor)}>(</color><color=#{ColorToFormattedString(Log.IntegerColor)}>{gameObject.GetComponents(typeof(UnityEngine.Component)).Length - 0}</color><color=#{ColorToFormattedString(Log.UnityColor)}>)</color> <color=#{ColorToFormattedString(Log.UnityColor)}>(</color><color=#{ColorToFormattedString(Log.TypeColor)}>{gameObject.GetType().Name}</color><color=#{ColorToFormattedString(Log.UnityColor)}>)</color>"                                                                                                                                                                                                                                                                                                                                                       : gameObject.ToString();
        if (value is UnityEngine.Component                component)                return formatted ? $"{Log.ToString(component .name, true, true)} <color=#{ColorToFormattedString(Log.UnityColor)}>(</color><color=#{ColorToFormattedString(Log.IntegerColor)}>{component .GetComponents(typeof(UnityEngine.Component)).Length - 1}</color><color=#{ColorToFormattedString(Log.UnityColor)}>)</color> <color=#{ColorToFormattedString(Log.UnityColor)}>(</color><color=#{ColorToFormattedString(Log.TypeColor)}>{component .GetType().Name}</color><color=#{ColorToFormattedString(Log.UnityColor)}>)</color>"                                                                                                                                                                                                                                                                                                                                                       : component .ToString();
        if (value is UnityEngine.GradientAlphaKey         gradientAlphaKey)         return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>alpha: {Log.ToString(gradientAlphaKey.alpha, true, true)}, time: {Log.ToString(gradientAlphaKey.time, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    : $"{containerBegin}alpha: {Log.ToString(gradientAlphaKey.alpha, false, true)}, time: {Log.ToString(gradientAlphaKey.time, false, true)}{containerEnd}";
        if (value is UnityEngine.GradientColorKey         gradientColorKey)         return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>color: {Log.ToString(gradientColorKey.color, true, true)}, time: {Log.ToString(gradientColorKey.time, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    : $"{containerBegin}color: {Log.ToString(gradientColorKey.color, false, true)}, time: {Log.ToString(gradientColorKey.time, false, true)}{containerEnd}";
        if (value is UnityEngine.JointMotor2D             jointMotor2D)             return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>maxTorque: {Log.ToString(jointMotor2D.maxMotorTorque, true, true)}, speed: {Log.ToString(jointMotor2D.motorSpeed, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        : $"{containerBegin}maxTorque: {Log.ToString(jointMotor2D.maxMotorTorque, false, true)}, speed: {Log.ToString(jointMotor2D.motorSpeed, false, true)}{containerEnd}";
        if (value is UnityEngine.JointSuspension2D        jointSuspension2D)        return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>angle: {Log.ToString(jointSuspension2D.angle, true, true)}, dampingRatio: {Log.ToString(jointSuspension2D.dampingRatio, true, true)}, frequency: {Log.ToString(jointSuspension2D.frequency, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                              : $"{containerBegin}angle: {Log.ToString(jointSuspension2D.angle, false, true)}, dampingRatio: {Log.ToString(jointSuspension2D.dampingRatio, false, true)}, frequency: {Log.ToString(jointSuspension2D.frequency, false, true)}{containerEnd}";
        if (value is UnityEngine.JointTranslationLimits2D jointTranslationLimits2D) return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>{Log.ToString(jointTranslationLimits2D.min, true, true)} → {Log.ToString(jointTranslationLimits2D.max, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   : $"{containerBegin}{Log.ToString(jointTranslationLimits2D.min, false, true)} → {Log.ToString(jointTranslationLimits2D.max, false, true)}{containerEnd}";
        if (value is UnityEngine.LOD                      levelOfDetail)            return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>fadeTransitionWidth: {Log.ToString(levelOfDetail.fadeTransitionWidth, true, true)}, renderers: {Log.ToString(levelOfDetail.renderers.Length, true, true)}, screenRelativeTransitionHeight: {Log.ToString(levelOfDetail.screenRelativeTransitionHeight, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                   : $"{containerBegin}fadeTransitionWidth: {Log.ToString(levelOfDetail.fadeTransitionWidth, false, true)}, renderers: {Log.ToString(levelOfDetail.renderers.Length, false, true)}, screenRelativeTransitionHeight: {Log.ToString(levelOfDetail.screenRelativeTransitionHeight, false, true)}{containerEnd}";
        if (value is UnityEngine.MatchTargetWeightMask    matchTargetWeightMask)    return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>positionXYZWeight: {Log.ToString(matchTargetWeightMask.positionXYZWeight, true, true)}, rotationWeight: {Log.ToString(matchTargetWeightMask.rotationWeight, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              : $"{containerBegin}positionXYZWeight: {Log.ToString(matchTargetWeightMask.positionXYZWeight, false, true)}, rotationWeight: {Log.ToString(matchTargetWeightMask.rotationWeight, false, true)}{containerEnd}";
        if (value is UnityEngine.Object)                                            return formatted ? $"<color=#{ColorToFormattedString(Log.UnityColor)}>{value}</color>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              : value.ToString();
        if (value is UnityEngine.Plane                plane)                        return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>distance: {Log.ToString(plane.distance, true, true)}, normal: {Log.ToString(plane.normal, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                : $"{containerBegin}distance: {Log.ToString(plane.distance, false, true)}, normal: {Log.ToString(plane.normal, false, true)}{containerEnd}";
        if (value is UnityEngine.Pose                 pose)                         return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>position: {Log.ToString(pose.position, true, true)}, rotation: {Log.ToString(pose.rotation, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              : $"{containerBegin}position: {Log.ToString(pose.position, false, true)}, rotation: {Log.ToString(pose.rotation, false, true)}{containerEnd}";
        if (value is UnityEngine.Quaternion           quaternion)                   return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b><color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(quaternion.x)}</color>, <color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(quaternion.y)}</color>, <color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(quaternion.z)}</color>, <color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(quaternion.w)}</color><b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                    : $"{containerBegin}{FloatToFormattedString(quaternion.x)}, {FloatToFormattedString(quaternion.y)}, {FloatToFormattedString(quaternion.z)}, {FloatToFormattedString(quaternion.w)}{containerEnd}";
        if (value is UnityEngine.Ray                  ray)                          return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>direction: {Log.ToString(ray  .direction, true, true)}, origin: {Log.ToString(ray  .origin, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              : $"{containerBegin}direction: {Log.ToString(ray  .direction, false, true)}, origin: {Log.ToString(ray  .origin, false, true)}{containerEnd}";
        if (value is UnityEngine.Ray2D                ray2D)                        return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>direction: {Log.ToString(ray2D.direction, true, true)}, origin: {Log.ToString(ray2D.origin, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              : $"{containerBegin}direction: {Log.ToString(ray2D.direction, false, true)}, origin: {Log.ToString(ray2D.origin, false, true)}{containerEnd}";
        if (value is UnityEngine.Touch                touch)                        return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color><color=#{ColorToFormattedString(Log.EnumerableColor)}>{touch.fingerId}</color><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b> <b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>count: {Log.ToString(touch.tapCount, true, true)}, phase: {Log.ToString(touch.phase, true, true)}, position: <b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>{Log.ToString(touch.rawPosition, true, true)} → {Log.ToString(touch.position, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>, pressure: {Log.ToString(touch.pressure, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>" : $"{containerBegin}{touch.fingerId}{containerEnd} {containerBegin}count: {Log.ToString(touch.tapCount, false, true)}, phase: {Log.ToString(touch.phase, false, true)}, position: {containerBegin}{Log.ToString(touch.rawPosition, false, true)} → {Log.ToString(touch.position, false, true)}{containerEnd}, pressure: {Log.ToString(touch.pressure, false, true)}{containerEnd}";
        if (value is UnityEngine.Rect                 rectangle)                    return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>x: <color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(rectangle.x)}</color>, y: <color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(rectangle.y)}</color>, width: <color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(rectangle.width)}</color>, height: <color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(rectangle.height)}</color><b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                          : $"{containerBegin}x: {FloatToFormattedString(rectangle.x)}, y: {FloatToFormattedString(rectangle.y)}, width: {FloatToFormattedString(rectangle.width)}, height: {FloatToFormattedString(rectangle.height)}{containerEnd}";
        if (value is UnityEngine.RectInt              rectangleInt)                 return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>x: <color=#{ColorToFormattedString(Log.IntegerColor)}>{rectangleInt.x}</color>, y: <color=#{ColorToFormattedString(Log.IntegerColor)}>{rectangleInt.y}</color>, width: <color=#{ColorToFormattedString(Log.IntegerColor)}>{rectangleInt.width}</color>, height: <color=#{ColorToFormattedString(Log.IntegerColor)}>{rectangleInt.height}</color><b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                      : $"{containerBegin}x: {rectangleInt.x}, y: {rectangleInt.y}, width: {rectangleInt.width}, height: {rectangleInt.height}{containerEnd}";
        if (value is UnityEngine.Resolution           resolution)                   return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>height: {Log.ToString(resolution.height, true, true)}, width: {Log.ToString(resolution.width, true, true)}, refreshRateRatio: {Log.ToString(resolution.refreshRateRatio, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 : $"{containerBegin}height: {Log.ToString(resolution.height, false, true)}, width: {Log.ToString(resolution.width, false, true)}, refreshRateRatio: {Log.ToString(resolution.refreshRateRatio, false, true)}{containerEnd}";
        if (value is UnityEngine.SoftJointLimit       softJointLimit)               return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>bounciness: {Log.ToString(softJointLimit.bounciness, true, true)}, contactDistance: {Log.ToString(softJointLimit.contactDistance, true, true)}, limit: {Log.ToString(softJointLimit.limit, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                               : $"{containerBegin}bounciness: {Log.ToString(softJointLimit.bounciness, false, true)}, contactDistance: {Log.ToString(softJointLimit.contactDistance, false, true)}, limit: {Log.ToString(softJointLimit.limit, false, true)}{containerEnd}";
        if (value is UnityEngine.SoftJointLimitSpring softJointLimitSpring)         return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>damper: {Log.ToString(softJointLimitSpring.damper, true, true)}, spring: {Log.ToString(softJointLimitSpring.spring, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      : $"{containerBegin}damper: {Log.ToString(softJointLimitSpring.damper, false, true)}, spring: {Log.ToString(softJointLimitSpring.spring, false, true)}{containerEnd}";
        if (value is UnityEngine.SpringJoint2D        springJoint2D)                return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>auto.: {Log.ToString(springJoint2D.autoConfigureDistance, true, true)}, dampingRatio: {Log.ToString(springJoint2D.dampingRatio, true, true)}, distance: {Log.ToString(springJoint2D.distance, true, true)}, frequency: {Log.ToString(springJoint2D.frequency, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                            : $"{containerBegin}auto.: {Log.ToString(springJoint2D.autoConfigureDistance, false, true)}, dampingRatio: {Log.ToString(springJoint2D.dampingRatio, false, true)}, distance: {Log.ToString(springJoint2D.distance, false, true)}, frequency: {Log.ToString(springJoint2D.frequency, false, true)}{containerEnd}";
        if (value is UnityEngine.Vector2              vectorD)                      return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b><color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(vectorD.x)}</color>, <color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(vectorD.y)}</color><b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            : $"{containerBegin}{FloatToFormattedString(vectorD.x)}, {FloatToFormattedString(vectorD.y)}{containerEnd}";
        if (value is UnityEngine.Vector2Int           vectorE)                      return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b><color=#{ColorToFormattedString(Log.IntegerColor)}>{vectorE.x}</color>, <color=#{ColorToFormattedString(Log.IntegerColor)}>{vectorE.y}</color><b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        : $"{containerBegin}{vectorE.x}, {vectorE.y}{containerEnd}";
        if (value is UnityEngine.Vector3              vectorF)                      return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b><color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(vectorF.x)}</color>, <color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(vectorF.y)}</color>, <color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(vectorF.z)}</color><b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                              : $"{containerBegin}{FloatToFormattedString(vectorF.x)}, {FloatToFormattedString(vectorF.y)}, {FloatToFormattedString(vectorF.z)}{containerEnd}";
        if (value is UnityEngine.Vector3Int           vectorG)                      return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b><color=#{ColorToFormattedString(Log.IntegerColor)}>{vectorG.x}</color>, <color=#{ColorToFormattedString(Log.IntegerColor)}>{vectorG.y}</color>, <color=#{ColorToFormattedString(Log.IntegerColor)}>{vectorG.z}</color><b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                                                                                : $"{containerBegin}{vectorG.x}, {vectorG.y}, {vectorG.z}{containerEnd}";
        if (value is UnityEngine.Vector4              vectorH)                      return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b><color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(vectorH.x)}</color>, <color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(vectorH.y)}</color>, <color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(vectorH.z)}</color>, <color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(vectorH.w)}</color><b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                : $"{containerBegin}{FloatToFormattedString(vectorH.x)}, {FloatToFormattedString(vectorH.y)}, {FloatToFormattedString(vectorH.z)}, {FloatToFormattedString(vectorH.w)}{containerEnd}";
        if (value is UnityEngine.WheelFrictionCurve   wheelFrictionCurve)           return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>asymptoteSlip: {Log.ToString(wheelFrictionCurve.asymptoteSlip, true, true)}, asymptoteValue: {Log.ToString(wheelFrictionCurve.asymptoteValue, true, true)}, extremumSlip: {Log.ToString(wheelFrictionCurve.extremumSlip, true, true)}, extremumValue: {Log.ToString(wheelFrictionCurve.extremumValue, true, true)}, stiffness: {Log.ToString(wheelFrictionCurve.stiffness, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"                                                                                                                                                                                                                                                                                                                                                                                                             : $"{containerBegin}asymptoteSlip: {Log.ToString(wheelFrictionCurve.asymptoteSlip, false, true)}, asymptoteValue: {Log.ToString(wheelFrictionCurve.asymptoteValue, false, true)}, extremumSlip: {Log.ToString(wheelFrictionCurve.extremumSlip, false, true)}, extremumValue: {Log.ToString(wheelFrictionCurve.extremumValue, false, true)}, stiffness: {Log.ToString(wheelFrictionCurve.stiffness, false, true)}{containerEnd}";

        if (value is Game.Collections.Keyframe keyframe) {
          uint     index    = 0u;
          string[] subvalue = new string[keyframe.properties.Count];

          // …
          [GameMethod(AggressiveInlining)]
          static string ValueToFormattedString(object? value, bool formatted, bool recursive) => value is not null ? formatted ? Log.ToString(value, true, recursive) : value.ToString() : string.Empty;

          // …
          if (Recur(keyframe, recursive))
          return formatted ? $"<color=#{ColorToFormattedString(Log.RecursiveEntryColor)}>{Log.RecursiveEntry}</color>" : Log.RecursiveEntry;

          for (System.Collections.IDictionaryEnumerator enumerator = keyframe.properties.GetEnumerator(); enumerator.MoveNext(); )
          subvalue[index++] = (formatted ? $"<color=#{ColorToFormattedString(Log.StringColor)}>{enumerator.Key}</color>" : enumerator.Key.ToString()) + ": " + (keyframe.begin is null ? ValueToFormattedString(enumerator.Value, formatted, recursive) : $"{ValueToFormattedString(keyframe.begin![enumerator.Key], formatted, recursive)} → {ValueToFormattedString(keyframe.end![enumerator.Key], formatted, recursive)}");

          return (string.IsNullOrEmpty(keyframe.name) ? string.Empty : $"{Log.ToString(keyframe.name, formatted, true)} ") + (keyframe is Game.Collections.Timeframe sequence ? $"{(formatted ? $"<color=#{ColorToFormattedString(Log.DoubleColor)}>" : string.Empty)}{(sequence.progress * 100.0).ToString("F2")}%{(formatted ? $"</color>" : string.Empty)} " : string.Empty) + $"[{string.Join(", ", subvalue)}]";
        }

        if (value is UnityEngine.Color32 color32)
        valueAsColor32 = color32;

        if (value is UnityEngine.Color color || (valueAsColor32 is not null ? (color = (UnityEngine.Color32) valueAsColor32, _: true)._ : false)) {
          fixed (UnityEngine.Color* address = Util.Colors.values.Items)
          for (UnityEngine.Color* iterator = address + Util.Colors.Count; address != iterator; ) {
            if (color == *--iterator)
            return formatted ? $"<color=#{ColorToFormattedString(Log.EnumerationColor)}>#{ColorToFormattedString(color)}</color> <color=#{ColorToFormattedString(Log.EnumerationColor)}>UnityEngine.Color{(valueAsColor32 is not null ? "32" : string.Empty)}.{Util.Colors.keys[(uint) (iterator - address)]}</color>" : $"#{ColorToFormattedString(color)} {Util.Colors.keys[(uint) (iterator - address)]}";
          }

          return formatted ? $"<color=#{ColorToFormattedString(Log.EnumerationColor)}>#{ColorToFormattedString(color)}</color> <b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b><color=#{ColorToFormattedString(Log.IntegerColor)}>{(byte) (color.r * 255u)}</color>, <color=#{ColorToFormattedString(Log.IntegerColor)}>{(byte) (color.g * 255u)}</color>, <color=#{ColorToFormattedString(Log.IntegerColor)}>{(byte) (color.b * 255u)}</color>, <color=#{ColorToFormattedString(Log.FloatColor)}>{FloatToFormattedString(color.a * 100.0f)}%</color><b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>"  : $"#{ColorToFormattedString(color)} {containerBegin}{(byte) (color.r * 255u)}, {(byte) (color.g * 255u)}, {(byte) (color.b * 255u)}, {FloatToFormattedString(color.a * 100.0f)}%{containerEnd}";
        }

        // … ->> Interfaces
        if (value is Game.Collections.IEventHandler events) goto fallback;
        if (value is Game.Collections.IMono         mono)    { if (Recur(mono,    recursive)) { return formatted ? $"<color=#{ColorToFormattedString(Log.RecursiveEntryColor)}>{Log.RecursiveEntry}</color>" : Log.RecursiveEntry; } return Log.ToString(mono.Value, formatted, true); }
        if (value is Game.Collections.IHandlerInfo  handler) { if (Recur(handler, recursive)) { return formatted ? $"<color=#{ColorToFormattedString(Log.RecursiveEntryColor)}>{Log.RecursiveEntry}</color>" : Log.RecursiveEntry; } return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b><b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerBegin}</color></b>{Log.ToString(handler.target, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b> {Log.ToString(handler.metadata, true, true)}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>" : $"[[{Log.ToString(handler.target, false, true)}] {Log.ToString(handler.metadata, false, true)}]"; }
        if (value is Game.Collections.IKeyValuePair pair)    valueAsEnumerable = new object[] {pair.Key, pair.Value!};
        if (value is Game.Collections.IShared       shared)  { if (Recur(shared, recursive)) { return formatted ? $"<color=#{ColorToFormattedString(Log.RecursiveEntryColor)}>{Log.RecursiveEntry}</color>" : Log.RecursiveEntry; } return Log.ToString(shared.Value, formatted, true); }

        if (value is System.Runtime.CompilerServices.ITuple tuple) {
          containerBegin    = '('; containerEnd = ')';
          valueAsEnumerable = new object[tuple.Length];

          for (int index = tuple.Length; 0 != index--; )
          valueAsEnumerable[index] = tuple[index]!;
        }

        if ((valueAsEnumerable is null ? value as System.Collections.IEnumerable : (System.Collections.IEnumerable) valueAsEnumerable) is System.Collections.IEnumerable enumerable) {
          System.Text.StringBuilder builder   = new();
          uint                      count     = 0u;
          char*                     separator = stackalloc[] {',', ' ', '…'};

          // …
          if (Recur(enumerable, recursive))
          return formatted ? $"<color=#{ColorToFormattedString(Log.RecursiveEntryColor)}>{Log.RecursiveEntry}</color>" : Log.RecursiveEntry;

          for (System.Collections.IEnumerator enumerator = enumerable.GetEnumerator(); ; ++count) {
            if (Log.EnumerablesMaximumEntries == count) { builder.Append(separator, 3); while (enumerator.MoveNext()) ++count; break; }
            if (enumerator.MoveNext()) { if (0u != count) builder.Append(separator, 2); } else break;

            builder.Append(Log.ToString(enumerator.Current, formatted, true)); // ->> Acknowledge null values
          }

          return formatted ? $"<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{(valueAsEnumerable is null ? "(" + count + ") " : string.Empty)}{containerBegin}</color></b>{builder.ToString()}<b><color=#{ColorToFormattedString(Log.EnumerableColor)}>{containerEnd}</color></b>" : $"[{builder.ToString()}]";
        }

        // …
        fallback:
        return Escape(value.ToString()); // ->> `Game.Collections.InputInfo`, `UnityEngine.GameObject`, …
      }
    }

    public static class Path {
      public static string Assets => Path.Normalize(UnityEngine.Application.streamingAssetsPath);
      public static string Data   => Path.Normalize(UnityEngine.Application.persistentDataPath);

      [GameMethod(AggressiveInlining)]
      private static string Normalize(string path) {
        path = path.TrimEnd().Replace(System.IO.Path.AltDirectorySeparatorChar, System.IO.Path.DirectorySeparatorChar);

        while (!path.IsEmpty() && (path.EndsWith(System.IO.Path.DirectorySeparatorChar) || string.IsNullOrWhiteSpace(path.Substring(path.Length - 1))))
        path = path.TrimEnd(System.IO.Path.DirectorySeparatorChar).TrimEnd();

        return path;
      }
    }

    public static class Pointed {
      public static readonly Game.Collections.RefList<Game.Collections.PointedInfo> Any              =  new();
      public static          uint                                                                   Count            => Pointed.Any.Count;
      public static          UnityEngine.EventSystems.EventSystem?                                  EventSystem      =  null;
      public static          UnityEngine.UI.GraphicRaycaster?                                       GraphicRaycaster =  null;

      /* … */
      [GameMethod(AggressiveInlining)] public static bool IsPointed(UnityEngine.Component  component)                                                    => Pointed.IsPointed(component,            out Game.Collections.PointedInfo pointed);
      [GameMethod(AggressiveInlining)] public static bool IsPointed(UnityEngine.GameObject gameObject)                                                   => Pointed.IsPointed(gameObject,           out Game.Collections.PointedInfo pointed);
      [GameMethod(AggressiveInlining)] public static bool IsPointed(UnityEngine.Component  component,  out Game.Collections.PointedInfo pointed) => Pointed.IsPointed(component.gameObject, out pointed);
      [GameMethod(AggressiveInlining)] public static bool IsPointed(UnityEngine.GameObject gameObject, out Game.Collections.PointedInfo pointed) { for (uint index = Pointed.Any.Count; 0u != index--; ) if (gameObject == Pointed.Any[index].graphic.gameObject) { pointed = Pointed.Any[index]; pointed.pointersList = pointed.pointersList.AsCopy(); return true; } pointed = new(); return false; }
    }

    public static class Pointers {
      public delegate void Pointerer(in Game.Collections.PointerInfo pointer);
      public delegate void Scroller (in UnityEngine.Vector2                  scroll, in UnityEngine.Vector2 scrollDelta);

      /* … */
      internal static readonly Game.Collections.RefList        <Game.Collections.PointerInfo>                                                                                                                                                        BeginState                                     =  new(24u);
      public   static readonly Game.Collections.RefReadOnlyList<Game.Collections.PointerInfo>                                                                                                                                                        Begin                                          =  (Game.Collections.RefReadOnlyList<Game.Collections.PointerInfo>) Pointers.BeginState;
      public   static          uint                                                                                                                                                                                                                                  Count                                          => System.Math.Max(Pointers.CurrentState.Count, System.Math.Max(Pointers.BeginState.Count, Pointers.EndState.Count));
      internal static readonly Game.Collections.RefList                     <Game.Collections.PointerInfo>                                                                                                                                           CurrentState                                   =  new(24u);
      public   static readonly Game.Collections.RefReadOnlyList             <Game.Collections.PointerInfo>                                                                                                                                           Current                                        =  (Game.Collections.RefReadOnlyList<Game.Collections.PointerInfo>) Pointers.CurrentState;
      internal static readonly Game.Collections.RefList                     <Game.Collections.PointerInfo>                                                                                                                                           EndState                                       =  new(24u);
      public   static readonly Game.Collections.RefReadOnlyList             <Game.Collections.PointerInfo>                                                                                                                                           End                                            =  (Game.Collections.RefReadOnlyList<Game.Collections.PointerInfo>) Pointers.EndState;
      public   static          ref readonly Game.Collections.RefReadOnlyList<Game.Collections.PointerInfo>                                                                                                                                           Held                                           => ref Pointers.Current;
      public   static          bool                                                                                                                                                                                                                                  IsActive                                       => !Pointers.BeginState.IsEmpty() && !Pointers.CurrentState.IsEmpty() && !Pointers.EndState.IsEmpty();
      public   static          bool                                                                                                                                                                                                                                  IsAdding   { get; internal set; }              =  false;
      public   static          bool                                                                                                                                                                                                                                  IsChanging { get; internal set; }              =  false;
      public   static          bool                                                                                                                                                                                                                                  IsClicking { get; internal set; }              =  false;
      public   static          bool                                                                                                                                                                                                                                  IsHeld                                         => Pointers.CurrentState.Count == 1u ? Pointers.IsId(Pointers.CurrentState[0].id) : !Pointers.CurrentState.IsEmpty();
      public   static          bool                                                                                                                                                                                                                                  IsMoving   { get; internal set; }              =  false;
      public   static          bool                                                                                                                                                                                                                                  IsPointing { get; internal set; }              =  false;
      public   static          bool                                                                                                                                                                                                                                  IsPressed                                      => Pointers.BeginState.Count == 1u ? Pointers.IsId(Pointers.BeginState[0].id) : !Pointers.BeginState.IsEmpty();
      public   static          bool                                                                                                                                                                                                                                  IsReleased                                     => Pointers.EndState  .Count == 1u ? Pointers.IsId(Pointers.EndState  [0].id) : !Pointers.EndState  .IsEmpty();
      public   static          bool                                                                                                                                                                                                                                  IsRemoving { get; internal set; }              =  false;
      public   const           sbyte                                                                                                                                                                                                                                 MouseButtonBack                                =  0x4;
      public   static          Game.Collections.DeviceState                                                                                                                                                                                                  MouseButtonBackState { get; internal set; }    =  Game.Collections.DeviceState.UNKNOWN;
      public   const           sbyte                                                                                                                                                                                                                                 MouseButtonForward                             =  0x3;
      public   static          Game.Collections.DeviceState                                                                                                                                                                                                  MouseButtonForwardState { get; internal set; } =  Game.Collections.DeviceState.UNKNOWN;
      public   const           sbyte                                                                                                                                                                                                                                 MouseButtonLeft                                =  0x0;
      public   static          Game.Collections.DeviceState                                                                                                                                                                                                  MouseButtonLeftState { get; internal set; }    =  Game.Collections.DeviceState.UNKNOWN;
      public   const           sbyte                                                                                                                                                                                                                                 MouseButtonMiddle                              =  0x2;
      public   static          Game.Collections.DeviceState                                                                                                                                                                                                  MouseButtonMiddleState { get; internal set; }  =  Game.Collections.DeviceState.UNKNOWN;
      public   const           sbyte                                                                                                                                                                                                                                 MouseButtonRight                               =  0x1;
      public   static          Game.Collections.DeviceState                                                                                                                                                                                                  MouseButtonRightState { get; internal set; }   =  Game.Collections.DeviceState.UNKNOWN;
      public   static event    Pointers.Pointerer                                                                                                                                                                                                                    OnClick                                        =  [GameMethod(AggressiveInlining)] static (in Game.Collections.PointerInfo pointer)                                    => {};
      public   static event    Pointers.Pointerer                                                                                                                                                                                                                    OnPoint                                        =  [GameMethod(AggressiveInlining)] static (in Game.Collections.PointerInfo pointer)                                    => {};
      public   static event    Pointers.Pointerer                                                                                                                                                                                                                    OnPointerAdded                                 =  [GameMethod(AggressiveInlining)] static (in Game.Collections.PointerInfo pointer)                                    => {};
      public   static event    Pointers.Pointerer                                                                                                                                                                                                                    OnPointerRemoved                               =  [GameMethod(AggressiveInlining)] static (in Game.Collections.PointerInfo pointer)                                    => {};
      public   static event    Pointers.Pointerer                                                                                                                                                                                                                    OnPointerUpdated                               =  [GameMethod(AggressiveInlining)] static (in Game.Collections.PointerInfo pointer)                                    => {};
      public   static event    Pointers.Scroller                                                                                                                                                                                                                     OnScroll                                       =  [GameMethod(AggressiveInlining)] static (in UnityEngine.Vector2                  scroll, in UnityEngine.Vector2 scrollDelta) => {};
      public   const           sbyte                                                                                                                                                                                                                                 PenButtonBarrel                                =  0x2;
      public   static          Game.Collections.DeviceState                                                                                                                                                                                                  PenButtonBarrelState { get; internal set; }    =  Game.Collections.DeviceState.UNKNOWN;
      public   const           sbyte                                                                                                                                                                                                                                 PenButtonEraser                                =  0x1;
      public   static          Game.Collections.DeviceState                                                                                                                                                                                                  PenButtonEraserState { get; internal set; }    =  Game.Collections.DeviceState.UNKNOWN;
      public   const           sbyte                                                                                                                                                                                                                                 PenButtonTip                                   =  0x0;
      public   static          Game.Collections.DeviceState                                                                                                                                                                                                  PenButtonTipState { get; internal set; }       =  Game.Collections.DeviceState.UNKNOWN;
      public   static          Game.Collections.DeviceState                                                                                                                                                                                                  PointerState { get; internal set; }            =  Game.Collections.DeviceState.UNKNOWN;
      public   static          ref readonly Game.Collections.RefReadOnlyList<Game.Collections.PointerInfo>                                                                                                                                           Pressed                                        => ref Pointers.Begin;
      public   static          ref readonly Game.Collections.RefReadOnlyList<Game.Collections.PointerInfo>                                                                                                                                           Released                                       => ref Pointers.End;
      public   static          ref readonly UnityEngine.Vector2                                                                                                                                                                                                      Scroll                                         => ref Pointers.ScrollValue;
      public   static          UnityEngine.Vector2                                                                                                                                                                                                                   ScrollDelta                                    => Pointers.ScrollValue - Pointers.ScrollPreviousValue;
      internal static          UnityEngine.Vector2                                                                                                                                                                                                                   ScrollPreviousValue                            =  UnityEngine.Vector2.zero;
      internal static          UnityEngine.Vector2                                                                                                                                                                                                                   ScrollValue                                    =  UnityEngine.Vector2.zero;
      public   static readonly System.Collections.ObjectModel.ReadOnlyCollection<Game.Collections.RefList<Game.Collections.PointerInfo>>                                                                                                             States                                         =  new[] {Pointers.BeginState, Pointers.CurrentState, Pointers.EndState}.AsReadOnly();
      public   static          Game.Collections.DeviceState                                                                                                                                                                                                  TouchState { get; internal set; }              =  Game.Collections.DeviceState.UNKNOWN;
      public   static readonly Game.Collections.InputStateCollection    <Game.Collections.PointerInfo>                                                                                                                                               Any                                            =  new(Pointers.States);
      private  static readonly (Game.Collections.RefReadOnlyList<sbyte>, Game.Collections.RefReadOnlyList<sbyte> MouseButtons, Game.Collections.RefReadOnlyList<sbyte> PenButtons, Game.Collections.RefReadOnlyList<sbyte> TouchIds) All                                            =  ((System.Func<(Game.Collections.RefReadOnlyList<sbyte>, Game.Collections.RefReadOnlyList<sbyte>, Game.Collections.RefReadOnlyList<sbyte>, Game.Collections.RefReadOnlyList<sbyte>)>) ([GameMethod(AggressiveInlining)] static () => (
        Game.Collections.RefReadOnlyList<sbyte>.Empty,
        new Game.Collections.RefReadOnlyList<sbyte>(stackalloc[] {Pointers.MouseButtonLeft, Pointers.MouseButtonRight, Pointers.MouseButtonMiddle, Pointers.MouseButtonForward, Pointers.MouseButtonBack}),
        new Game.Collections.RefReadOnlyList<sbyte>(stackalloc[] {Pointers.PenButtonTip, Pointers.PenButtonEraser /* , Pointers.PenButtonBarrel… */}),
        Game.Collections.RefReadOnlyList<sbyte>.Empty
      )))();

      /* … */
      [GameMethod(AggressiveInlining)] internal static void Add  (in Game.Collections.PointerInfo pointer) => Pointers.OnPointerAdded(in pointer);
      [GameMethod(AggressiveInlining)] internal static void Click(in Game.Collections.PointerInfo pointer) => Pointers.OnClick       (in pointer);

      [GameMethod(AggressiveInlining)] public static bool IsEnhancedTouchId(long id) =>         uint.MaxValue <= id;
      [GameMethod(AggressiveInlining)] public static bool IsId             (long id) =>         uint.MaxValue == id;
      [GameMethod(AggressiveInlining)] public static bool IsMouseId        (long id) => -(long) uint.MaxValue <  id && id <  0L;
      [GameMethod(AggressiveInlining)] public static bool IsPenId          (long id) => -(long) uint.MaxValue >  id;
      [GameMethod(AggressiveInlining)] public static bool IsTouchId        (long id) =>         uint.MaxValue >  id && id >= 0L;
      [GameMethod(AggressiveInlining)] public static bool IsPointerId      (long id) =>         true;

      [GameMethod(AggressiveInlining)]
      public static bool IsScrolling() => Pointers.ScrollValue != Pointers.ScrollPreviousValue;

      [GameMethod(AggressiveInlining)] public static long MakeEnhancedTouchId(uint id) =>  (long) uint.MaxValue + (long) id;
      [GameMethod(AggressiveInlining)] public static long MakeId             ()        =>  (long) uint.MaxValue;
      [GameMethod(AggressiveInlining)] public static long MakeMouseId        (uint id) => -(long) id - 1L;
      [GameMethod(AggressiveInlining)] public static long MakePenId          (uint id) => -(long) uint.MaxValue - (long) id - 1L;
      [GameMethod(AggressiveInlining)] public static long MakePointerId      (uint id) =>  (long) id;
      [GameMethod(AggressiveInlining)] public static long MakeTouchId        (uint id) => +(long) id;

      [GameMethod(AggressiveInlining)]
      public static UnityEngine.EventSystems.PointerEventData MakePointerEventData(UnityEngine.EventSystems.EventSystem eventSystem, in Game.Collections.PointerInfo pointer, UnityEngine.GameObject? gameObject = null) {
        bool pointerIs         = Pointers.IsId(pointer.id);
        bool pointerIsDragging = pointer.IsDragging();
        bool pointerIsMouse    = Pointers.IsMouseId(pointer.id);
        bool pointerIsPen      = Pointers.IsPenId  (pointer.id);
        bool pointerIsTouch    = Pointers.IsTouchId(pointer.id);

        return new(eventSystem) {
          button = pointerIsMouse ? (int) Pointers.UnmakeMouseId(pointer.id) /* - UI.Mouse.Value.deviceId */ switch {
            Util.Pointers.MouseButtonLeft   => UnityEngine.EventSystems.PointerEventData.InputButton.Left,
            Util.Pointers.MouseButtonMiddle => UnityEngine.EventSystems.PointerEventData.InputButton.Middle,
            Util.Pointers.MouseButtonRight  => UnityEngine.EventSystems.PointerEventData.InputButton.Right,
            _                               => UnityEngine.EventSystems.PointerEventData.InputButton.Left
          } : UnityEngine.EventSystems.PointerEventData.InputButton.Left,
          clickCount = pointerIs ? 1    : (int) pointer.sequenced,
          clickTime  = pointerIs ? 0.0f : UnityEngine.Time.unscaledTime,
          delta      = pointer.delta,
          dragging   = pointer.IsDragging(),
          penStatus  = pointerIsPen ? (int) (Pointers.UnmakePenId(pointer.id) - Util.UI.Pen.Value.deviceId) switch {
            >= Util.Pointers.PenButtonBarrel => UnityEngine.PenStatus.Barrel,
            Util.Pointers.PenButtonEraser    => UnityEngine.PenStatus.Eraser,
            Util.Pointers.PenButtonTip       => UnityEngine.PenStatus.Contact,
            _                                => pointer.inverted ? UnityEngine.PenStatus.Inverted : UnityEngine.PenStatus.None
          } : UnityEngine.PenStatus.None,
          pointerClick = gameObject!,
          pointerDrag  = pointerIsDragging ? gameObject! : null!,
          pointerEnter = gameObject!,
          pointerId    = pointerIsMouse ? (int) Pointers.UnmakeMouseId(pointer.id) /* - UI.Mouse.Value.deviceId */ switch {
            Util.Pointers.MouseButtonLeft   => -1,
            Util.Pointers.MouseButtonMiddle => -3,
            Util.Pointers.MouseButtonRight  => -2,
            _                               => -1
          } : pointerIsTouch ? (int) Pointers.UnmakeTouchId(pointer.id) : -1, // ->> Assume left mouse button
          pointerPress       = gameObject!,
          position           = pointer.position,
          pressPosition      = gameObject is not null && pointerIs ? UnityEngine.Vector2.zero : pointer.position,
          pressure           = pointer.pressure,
          radius             = pointerIsTouch ? pointer.radius : UnityEngine.Vector2.zero,
          radiusVariance     = UnityEngine.Vector2.zero,
          rawPointerPress    = gameObject!,
          reentered          = false,
          scrollDelta        = pointerIsMouse ? Pointers.ScrollDelta : UnityEngine.Vector2.zero,
          tangentialPressure = System.Math.Clamp(pointer.pressure, 0.0f, 1.0f)
        };
      }

      [GameMethod(AggressiveInlining)]
      internal static void Point(in Game.Collections.PointerInfo pointer) => Pointers.OnPoint(in pointer);

      [GameMethod(AggressiveInlining)]
      public static System.Collections.Generic.List<UnityEngine.UI.Graphic> Raycast(UnityEngine.UI.GraphicRaycaster raycaster, UnityEngine.EventSystems.EventSystem eventSystem, in Game.Collections.PointerInfo pointer) {
        System.Collections.Generic.List<UnityEngine.EventSystems.RaycastResult> raycasts = new();

        // …
        raycaster.Raycast  (Pointers.MakePointerEventData(eventSystem, in pointer), raycasts);
        raycasts .RemoveAll([GameMethod(AggressiveInlining)] static (raycast) => !raycast.isValid);

        return raycasts.ConvertAll([GameMethod(AggressiveInlining)] static (raycast) => raycast.gameObject.GetComponent<UnityEngine.UI.Graphic>());
      }

      [GameMethod(AggressiveInlining)]
      internal static void Remove(in Game.Collections.PointerInfo pointer) => Pointers.OnPointerRemoved(in pointer);

      [GameMethod(AggressiveInlining)] public static uint UnmakeEnhancedTouchId(long id) => (uint) -((long) uint.MaxValue - (long) id);
      [GameMethod(AggressiveInlining)] public static uint UnmakeId             ()        => (uint)  uint.MaxValue;
      [GameMethod(AggressiveInlining)] public static uint UnmakeMouseId        (long id) => (uint) -id - 1u;
      [GameMethod(AggressiveInlining)] public static uint UnmakePenId          (long id) => (uint)  ((long) uint.MaxValue - (long) id + 1L);
      [GameMethod(AggressiveInlining)] public static uint UnmakePointerId      (long id) => (uint)  id;
      [GameMethod(AggressiveInlining)] public static uint UnmakeTouchId        (long id) => (uint) +id;

      [GameMethod(AggressiveInlining)] internal static void Update (in Game.Collections.PointerInfo pointer)                                    => Pointers.OnPointerUpdated(in pointer);
      [GameMethod(AggressiveInlining)] internal static void Scrolls(in UnityEngine.Vector2                  scroll, in UnityEngine.Vector2 scrollDelta) => Pointers.OnScroll        (in scroll, in scrollDelta);
    }

    public static class Preload {
      [GameMethod(AggressiveInlining)] public static Unity.Collections.NativeArray<byte>.ReadOnly? Uri           (System.Uri path,                                 Game.Handler<Game.Events.LoadEvent>? callback = null, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Util.Load.Uri           (path,                             callback, Util.Load.Asynchronously, Util.Load.WithCache, Util.Load.Once, fallback);
      [GameMethod(AggressiveInlining)] public static UnityEngine.AudioClip?                        UriAsAudioClip(System.Uri path,                                 Game.Handler<Game.Events.LoadEvent>? callback = null, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Util.Load.UriAsAudioClip(path, UnityEngine.AudioType.MPEG, callback, Util.Load.Asynchronously, Util.Load.WithCache, Util.Load.Once, fallback);
      [GameMethod(AggressiveInlining)] public static UnityEngine.AudioClip?                        UriAsAudioClip(System.Uri path, UnityEngine.AudioType encoding, Game.Handler<Game.Events.LoadEvent>? callback = null, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Util.Load.UriAsAudioClip(path, encoding,                   callback, Util.Load.Asynchronously, Util.Load.WithCache, Util.Load.Once, fallback);
      [GameMethod(AggressiveInlining)] public static string?                                       UriAsText     (System.Uri path,                                 Game.Handler<Game.Events.LoadEvent>? callback = null, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Util.Load.UriAsText     (path, System.Text.Encoding.UTF8,  callback, Util.Load.Asynchronously, Util.Load.WithCache, Util.Load.Once, fallback);
      [GameMethod(AggressiveInlining)] public static string?                                       UriAsText     (System.Uri path, System.Text.Encoding  encoding, Game.Handler<Game.Events.LoadEvent>? callback = null, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Util.Load.UriAsText     (path, encoding,                   callback, Util.Load.Asynchronously, Util.Load.WithCache, Util.Load.Once, fallback);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Texture2D?                        UriAsTexture2D(System.Uri path,                                 Game.Handler<Game.Events.LoadEvent>? callback = null, Game.Handler<Game.Events.LoadEvent>? fallback = null) => Util.Load.UriAsTexture2D(path,                             callback, Util.Load.Asynchronously, Util.Load.WithCache, Util.Load.Once, fallback);
    }

    public static class Reference<T> /* ->> Solely for `𝑓 Util.Reference<T>.*At(…)` */ {
      private readonly struct Sentinel {}

      /* … */
      private         static readonly Game.ArrayIndexer                 <T>                                                                   ArrayAtValue              =  (Game.ArrayIndexer                 <T>) (Traits.IsValueType<T>() ? ((Game.ArrayIndexer                 <Reference<T>.Sentinel>) Reference<Reference<T>.Sentinel>.UnmanagedArrayAt).Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.ArrayIndexer                 <T>)) : (Game.ArrayIndexer                 <T>) Reference<T>.ManagedArrayAt<T>); // ->> Damn it Unity, `ref System.Runtime.CompilerServices.Unsafe.Add(ref value, offset)` was perfectly fine
      public          static readonly Game.RefReadOnlyComparison        <T>                                                                   CompareValue              =  (Game.RefReadOnlyComparison        <T>) (Traits.IsValueType<T>() ? ((Game.RefReadOnlyComparison        <Reference<T>.Sentinel>) Reference<Reference<T>.Sentinel>.UnmanagedCompare).Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.RefReadOnlyComparison        <T>)) : (Game.RefReadOnlyComparison        <T>) Reference<T>.ManagedCompare);    //
      public          static readonly Game.RefReadOnlyEqualityComparison<T>                                                                   EqualsValue               =  (Game.RefReadOnlyEqualityComparison<T>) (Traits.IsValueType<T>() ? ((Game.RefReadOnlyEqualityComparison<Reference<T>.Sentinel>) Reference<Reference<T>.Sentinel>.UnmanagedEquals) .Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.RefReadOnlyEqualityComparison<T>)) : (Game.RefReadOnlyEqualityComparison<T>) Reference<T>.ManagedEquals<T>);  // ->> Damn it Unity, `ref System.Runtime.CompilerServices.Unsafe.AreSame(ref valueA, ref valueB)` was perfectly fine
      public          static          ref T                                                                                                           Invalid                   => throw new System.NullReferenceException("Object reference not set to an instance of an object");                                                                                                                                                                                                                                                                                                                             //
      private  unsafe static readonly Game.RefReadOnlyAddresser         <T>                                                                   LoadAddressValue          =  (Game.RefReadOnlyAddresser<T>) (Traits.IsValueType<T>() ? ((Game.RefReadOnlyAddresser<T>) Reference<T>.UnmanagedLoadAddress) : (Game.RefReadOnlyAddresser<T>) Reference<T>.ManagedLoadAddress);                                                                                                                                                                                                      // ->> Damn it Unity, pointers to managed types are fine given suitable expertise and care
      private         static readonly System.Collections.Generic.List           <(System.Reflection.FieldInfo, Game.RefReadOnlyAddresser<T>)> LoadFieldAddressValues    =  new(1);                                                                                                                                                                                                                                                                                                                                                                                                                      //
      internal        const           uint                                                                                                            ManagedByteSize           =  8u;                                                                                                                                                                                                                                                                                                                                                                                                                          // ->> Presumed byte size of managed/ reference types as structured within class types (i.e. `sizeof(void*)`) — relative liberal guess to avoid object splicing
      public          static          ref T                                                                                                           Null                      => ref System.Runtime.InteropServices.MemoryMarshal.GetReference(new System.ReadOnlySpan<T>(new T[] {default!}));                                                                                                                                                                                                                                                                                                               // ->> Do not get reference to `System.ReadOnlySpan<T>.Empty`
      private         static readonly Game.ReadOnlySpanIndexer <T>                                                                            ReadOnlySpanAtValue       =  (Game.ReadOnlySpanIndexer          <T>) (Traits.IsValueType<T>() ? ((Game.ReadOnlySpanIndexer<Reference<T>.Sentinel>) Reference<Reference<T>.Sentinel>.UnmanagedReadOnlySpanAt).Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.ReadOnlySpanIndexer<T>)) : (Game.ReadOnlySpanIndexer<T>) Reference<T>.ManagedReadOnlySpanAt<T>);                 //
      private         static readonly Game.SpanIndexer         <T>                                                                            SpanAtValue               =  (Game.SpanIndexer                  <T>) (Traits.IsValueType<T>() ? ((Game.SpanIndexer        <Reference<T>.Sentinel>) Reference<Reference<T>.Sentinel>.UnmanagedSpanAt)        .Method.GetGenericMethodDefinition().MakeGenericMethod(typeof(T)).CreateDelegate(typeof(Game.SpanIndexer        <T>)) : (Game.SpanIndexer        <T>) Reference<T>.ManagedSpanAt        <T>);                 //
      private         static readonly Game.RefReadOnlyAddresser<T>                                                                            UnmanagedLoadAddressValue =  ((System.Func<Game.RefReadOnlyAddresser<T>>) (static () => { unsafe {
        System.Reflection.Emit.DynamicMethod method            = new("LoadAddress", typeof(void*), new[] {typeof(T).MakeByRefType()}, typeof(Reference<T>).Module, true);
        System.Reflection.Emit.ILGenerator   generator         = method.GetILGenerator();
        System.Reflection.Emit.LocalBuilder  methodPinnedLocal = generator.DeclareLocal(typeof(void*), true);

        // … ->> Pray the Intermediate Language code is valid for C#’s .NET runtime and furthermore Unity’s Mono (or IL2CPP) implementation 🙏
        method.DefineParameter(1, System.Reflection.ParameterAttributes.In, "value"); // ->> Unnecessary formality

        generator.Emit(System.Reflection.Emit.OpCodes.Ldarg_0);                  //
        generator.Emit(System.Reflection.Emit.OpCodes.Stloc, methodPinnedLocal); // ->> Used only for pinning i.e. `fixed`
        generator.Emit(System.Reflection.Emit.OpCodes.Ldloc, methodPinnedLocal); //    ^^
        generator.Emit(System.Reflection.Emit.OpCodes.Conv_U);                   // ->> Is the `unsigned` conversion necessary?
        generator.Emit(System.Reflection.Emit.OpCodes.Ret);                      // ->> Also works for `T*` pointers, but Unity explicitly disallows

        // …
        return (Game.RefReadOnlyAddresser<T>) method.CreateDelegate(typeof(Game.RefReadOnlyAddresser<T>));
      } }))();

      /* … */
      [GameMethod(AggressiveInlining), GameResolution(0)] public unsafe static void*          AddressOf(in T                      value)                                      => Reference<T>.LoadAddressValue(in value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public unsafe static void*          AddressOf(in T                      value,  System.Reflection.FieldInfo field)  { if (field is not null) { Game.RefReadOnlyAddresser<T> LoadFieldAddresser = Reference<T>.GetUnmanagedLoadFieldAddresser(field); if (value is not null) return LoadFieldAddresser(in value); else { Game.Collections.SharedMono<T> subvalue = new(); return new System.IntPtr((byte*) LoadFieldAddresser(in subvalue.Value) - (byte*) Reference<T>.AddressOf(in subvalue.Value)).ToPointer(); } } return System.IntPtr.Zero.ToPointer(); }
      [GameMethod(AggressiveInlining), GameResolution(1)] public        static ref          T At       (T[]                       array,  uint                        index)  => ref Reference<T>.ArrayAtValue       (array,   index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public        static ref readonly T At       (in System.ReadOnlySpan<T> span,   int                         index)  => ref Reference<T>.ReadOnlySpanAtValue(in span, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public        static ref          T At       (in System.Span        <T> span,   int                         index)  => ref Reference<T>.SpanAtValue        (in span, index);
      [GameMethod(AggressiveInlining), GameResolution(0)] public        static int            Compare  (in T                      valueA, in T                        valueB) => Reference<T>.CompareValue(in valueA, in valueB);
      [GameMethod(AggressiveInlining), GameResolution(0)] public        static bool           Equals   (in T                      valueA, in T                        valueB) => Reference<T>.EqualsValue (in valueA, in valueB);
      [GameMethod(AggressiveInlining), GameResolution(1)] public        static ref          T First    (T[]                       array)                                      => ref Reference<T>.Only(array);
      [GameMethod(AggressiveInlining), GameResolution(0)] public        static ref readonly T First    (in System.ReadOnlySpan<T> span)                                       => ref Reference<T>.Only(in span);
      [GameMethod(AggressiveInlining), GameResolution(0)] public        static ref          T First    (in System.Span        <T> span)                                       => ref Reference<T>.Only(in span);

      [GameMethod(AggressiveInlining), GameResolution(0)]
      public unsafe static Game.RefReadOnlyAddresser<T> GetUnmanagedLoadFieldAddresser(System.Reflection.FieldInfo field) {
        Game.RefReadOnlyAddresser<T>? LoadFieldAddresser = null;

        // …
        foreach ((System.Reflection.FieldInfo subfield, Game.RefReadOnlyAddresser<T> LoadFieldAddress) in Reference<T>.LoadFieldAddressValues)
        if (field.Attributes == subfield.Attributes && field.DeclaringType == subfield.DeclaringType && field.FieldHandle == subfield.FieldHandle && field.FieldType == subfield.FieldType && field.IsAssembly == subfield.IsAssembly && field.IsFamily == subfield.IsFamily && field.IsFamilyAndAssembly == subfield.IsFamilyAndAssembly && field.IsFamilyOrAssembly == subfield.IsFamilyOrAssembly && field.IsInitOnly == subfield.IsInitOnly && field.IsLiteral == subfield.IsLiteral && field.IsPinvokeImpl == subfield.IsPinvokeImpl && field.IsPrivate == subfield.IsPrivate && field.IsPublic == subfield.IsPublic && field.IsSecurityCritical == subfield.IsSecurityCritical && field.IsSecuritySafeCritical == subfield.IsSecuritySafeCritical && field.IsSecurityTransparent == subfield.IsSecurityTransparent && field.IsSpecialName == subfield.IsSpecialName && field.IsStatic == subfield.IsStatic && field.MetadataToken == subfield.MetadataToken && field.Name == subfield.Name) {
          LoadFieldAddresser = LoadFieldAddress;
          break;
        }

        if (LoadFieldAddresser is null) {
          System.Reflection.Emit.DynamicMethod method    = new("LoadFieldAddress", typeof(void*), new[] {typeof(T).MakeByRefType()}, typeof(Reference<T>).Module, true);
          System.Reflection.Emit.ILGenerator   generator = method.GetILGenerator();

          // … ->> See `𝑓 Util.Reference<T>.UnmanagedLoadAddressValue(…)`
          method.DefineParameter(1, System.Reflection.ParameterAttributes.In, "value");

          generator.Emit(System.Reflection.Emit.OpCodes.Ldarg_0);
          generator.Emit(System.Reflection.Emit.OpCodes.Ldflda, field);
          generator.Emit(System.Reflection.Emit.OpCodes.Conv_U);
          generator.Emit(System.Reflection.Emit.OpCodes.Ret);

          LoadFieldAddresser = (Game.RefReadOnlyAddresser<T>) method.CreateDelegate(typeof(Game.RefReadOnlyAddresser<T>));
          Reference<T>.LoadFieldAddressValues.Add((field, LoadFieldAddresser));
        }

        return LoadFieldAddresser;
      }

      [GameMethod(AggressiveInlining), GameResolution(1)] public static ref          T Last(T[]                       array) => ref Reference<T>.At(array,   (uint) (!array.IsEmpty() ? array.Length - 1 : 0));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly T Last(in System.ReadOnlySpan<T> span)  => ref Reference<T>.At(in span, !span.IsEmpty            ? span .Length - 1 : 0);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          T Last(in System.Span        <T> span)  => ref Reference<T>.At(in span, !span.IsEmpty            ? span .Length - 1 : 0);

      [GameMethod(AggressiveInlining), GameResolution(0)] private        static ref U          ManagedArrayAt       <U>(U[]                       array,  uint index)  => ref array[index];
      [GameMethod(NoInlining),         GameResolution(0)] private unsafe static int            ManagedCompare          (in T                      valueA, in T valueB) { void** addresses = stackalloc[] {Reference<T>.ManagedLoadAddress(in valueA), Reference<T>.ManagedLoadAddress(in valueB)}; return addresses[0] < addresses[1] ? -1 : addresses[0] > addresses[1] ? +1 : 0; }
      [GameMethod(AggressiveInlining), GameResolution(0)] private        static bool           ManagedEquals        <U>(in U                      valueA, in U valueB) => object.ReferenceEquals(valueA, valueB);
      [GameMethod(AggressiveInlining), GameResolution(0)] private        static ref readonly U ManagedFrom          <U>(in U                      value)               => ref value;
      [GameMethod(NoInlining),         GameResolution(0)] private unsafe static void*          ManagedLoadAddress      (in T                      value)               { if (value is not null) { try { System.Runtime.InteropServices.GCHandle handle = System.Runtime.InteropServices.GCHandle.Alloc(value, System.Runtime.InteropServices.GCHandleType.Pinned); void* address = handle.AddrOfPinnedObject().ToPointer(); handle.Free(); return address; } catch (System.ArgumentException) /* ->> `value` contains non-primitive (non-blittable) field(s) */ {} return Reference<T>.UnmanagedLoadAddress(in value); } return System.IntPtr.Zero.ToPointer(); } // ->> Possibly stale (invalid) address evaluated by undocumented keyword: `try { System.TypedReference reference = __makeref(/* ref */ value); return (*(System.IntPtr**) &reference) -> ToPointer(); } catch (System.BadImageFormatException) {}`
      [GameMethod(AggressiveInlining), GameResolution(0)] private        static ref readonly U ManagedReadOnlySpanAt<U>(in System.ReadOnlySpan<U> span,   int  index)  => ref span[index];
      [GameMethod(AggressiveInlining), GameResolution(0)] private        static ref          U ManagedSpanAt        <U>(in System.Span        <U> span,   int  index)  => ref span[index];

      [GameMethod(AggressiveInlining), GameResolution(1)] public static ref          T Only(T[]                       array) => ref System.Runtime.InteropServices.MemoryMarshal.GetReference(new System.ReadOnlySpan<T>(array));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly T Only(in System.ReadOnlySpan<T> span)  => ref System.Runtime.InteropServices.MemoryMarshal.GetReference(span);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          T Only(in System.Span        <T> span)  => ref System.Runtime.InteropServices.MemoryMarshal.GetReference(span);

      [GameMethod(AggressiveInlining), GameResolution(0)] private unsafe static ref U          UnmanagedArrayAt       <U>(U[]                       array,  uint index)  where U : unmanaged { fixed (U*    address  = array)                                    return ref  address[index]; }
      [GameMethod(AggressiveInlining), GameResolution(0)] private unsafe static int            UnmanagedCompare       <U>(in U                      valueA, in U valueB) where U : unmanaged { fixed (void* addressA = &valueA) fixed (void* addressB = &valueB) return      addressA < addressB ? -1 : addressA > addressB ? +1 : 0; }
      [GameMethod(AggressiveInlining), GameResolution(0)] private unsafe static bool           UnmanagedEquals        <U>(in U                      valueA, in U valueB) where U : unmanaged { fixed (void* addressA = &valueA) fixed (void* addressB = &valueB) return      addressA == addressB; }
      [GameMethod(AggressiveInlining), GameResolution(0)] private unsafe static ref U          UnmanagedFrom          <U>(in U                      value)               where U : unmanaged { fixed (U*    address  = &value)                                   return ref *address; }
      [GameMethod(AggressiveInlining), GameResolution(0)] private unsafe static void*          UnmanagedLoadAddress      (in T                      value)                                   => value is not null ? Reference<T>.UnmanagedLoadAddressValue(in value) : System.IntPtr.Zero.ToPointer();
      [GameMethod(AggressiveInlining), GameResolution(0)] private unsafe static ref readonly U UnmanagedReadOnlySpanAt<U>(in System.ReadOnlySpan<U> span,   int  index)  where U : unmanaged { fixed (U* address = span) return ref *(address + index); }
      [GameMethod(AggressiveInlining), GameResolution(0)] private unsafe static ref          U UnmanagedSpanAt        <U>(in System.Span        <U> span,   int  index)  where U : unmanaged { fixed (U* address = span) return ref *(address + index); }
    }

    public static class UI {
      internal static          bool                                                                         Blurred                             =  false;
      internal static          Game.Collections.SharedLazyMono<UnityEngine.InputSystem.Keyboard>    Keyboard                            =  new(() => UnityEngine.InputSystem.Keyboard.current); // ->> `Game.Collections.DeviceState.END > Util.Keys.Modifiers.Control && Util.Keys.IsActive(Game.Collections.DeviceState.BEGIN, UnityEngine.KeyCode.C)`
      internal static          Game.Collections.SharedLazyMono<UnityEngine.InputSystem.Mouse>       Mouse                               =  new(() => UnityEngine.InputSystem.Mouse   .current);
      public   static event    System.Action<double>                                                        OnBlur                              =  [GameMethod(AggressiveInlining)] static (timestamp) => {};
      public   static event    System.Action<double>                                                        OnFocus                             =  [GameMethod(AggressiveInlining)] static (timestamp) => {};
      public   static event    System.Action<double>                                                        OnLateUpdate                        =  [GameMethod(AggressiveInlining)] static (timestamp) => {};
      public   static event    System.Action<double>                                                        OnUpdate                            =  [GameMethod(AggressiveInlining)] static (timestamp) => {};
      internal static          Game.Collections.SharedLazyMono<UnityEngine.InputSystem.Pen>         Pen                                 =  new(() => UnityEngine.InputSystem.Pen    .current);
      internal static          Game.Collections.SharedLazyMono<UnityEngine.InputSystem.Pointer>     Pointer                             =  new(() => UnityEngine.InputSystem.Pointer.current);
      private  static          byte                                                                         PointerAcknowledged                 =  (byte) 0u; // ->> Responsible for shifting the acknowledged cursor movement from `Game.Collections.DeviceState.BEGIN` to `Game.Collections.DeviceState.END`
      public   static          UnityEngine.GameObject?                                                      Tabbed                              => UI.TabIsActive ? UI.TabList[UI.TabIndex] : null;
      private  static          float                                                                        TabDelayElapsed                     =  0.0f;
      public   static          int                                                                          TabIndex                            =  -1;
      public   static          bool                                                                         TabIndexPreserved                   =  false;
      public   static          bool                                                                         TabIsActive                         => UI.TabIndex != -1;
      public   static          bool                                                                         TabIsChanging { get; private set; } =  false;
      public   static          bool                                                                         TabIsBlurred  { get; private set; } =  false;
      public   static readonly System.Collections.Generic.List<UnityEngine.GameObject>                      TabList                             =  new();
      public   static          int                                                                          TabPreviousIndex                    =  -1;
      internal static          Game.Collections.SharedLazyMono<UnityEngine.InputSystem.Touchscreen> Touchscreen                         =  new(() => UnityEngine.InputSystem.Touchscreen.current);

      /* … */
      [GameMethod(AggressiveInlining)]
      internal static void Blur() {
        UI.Blurred = true;
        UI.BlurKeys    ();
        UI.BlurPointers();
        UI.BlurTabs    ();
        UI.PointerAcknowledged = (byte) 0u;

        UI.OnBlur(UnityEngine.Time.realtimeSinceStartupAsDouble);
      }

      private static void Blur<T>(in Game.Collections.RefList<T> state, in Game.Collections.RefList<T> endState) where T : Game.Collections.InputInfo {
        // … ->> Progress all acknowledged inputs to their `.EndState` state
        for (uint index = state.Count; 0u != index--; ) {
          ref T input = ref state[index];

          // …
          input.state = Game.Collections.DeviceState.END;

          foreach (ref readonly T endInput in endState) {
            bool remove = false;

            // …
            if (endInput is Game.Collections.KeyInfo endKey && input is Game.Collections.KeyInfo key && endKey.codes == key.codes) {
              Util.Keys.IsRemoving = remove = true;
              Util.Keys.Remove(key);
            }

            else if (endInput is Game.Collections.PointerInfo endPointer && input is Game.Collections.PointerInfo pointer && endPointer.device == pointer.device && endPointer.id == pointer.id) {
              Util.Pointers.IsRemoving = remove = true;
              Util.Pointers.Remove(pointer);
            }

            // …
            if (remove) {
              state.RemoveAt(index);
              break;
            }
          }
        }

        endState.AddRange(state);
        state   .Clear   ();
      }

      public static void BlurKeys() {
        UI.Blur(in Game.Util.Keys.BeginState,   in Game.Util.Keys.EndState);
        UI.Blur(in Game.Util.Keys.CurrentState, in Game.Util.Keys.EndState);
      }

      public static void BlurPointed() {
        foreach (ref Game.Collections.PointedInfo pointed in Util.Pointed.Any) {
          pointed.epoch = Game.Collections.DeviceState.END != pointed.state ? UnityEngine.Time.realtimeSinceStartupAsDouble : pointed.epoch;
          pointed.state = Game.Collections.DeviceState.END;
        }
      }

      public static void BlurPointers() {
        UI.Blur(in Game.Util.Pointers.BeginState,   in Game.Util.Pointers.EndState);
        UI.Blur(in Game.Util.Pointers.CurrentState, in Game.Util.Pointers.EndState);
      }

      [GameMethod(AggressiveInlining)] public static void BlurTabs() => UI.BlurTabs(false);
      [GameMethod(AggressiveInlining)]
      public static void BlurTabs(bool ignore) {
        UI.TabDelayElapsed  = 0.0f;
        UI.TabIndex         = -1;
        UI.TabIsBlurred     = true;
        UI.TabPreviousIndex = ignore ? -1 : UI.TabPreviousIndex;
      }

      internal static void Focus() {
        UI.Blurred = false;
        UI.OnFocus(UnityEngine.Time.realtimeSinceStartupAsDouble);
      }

      [GameMethod(AggressiveInlining)]
      internal static void LateUpdate(double timestamp) {
        UI.LateUpdateKeys    (timestamp);
        UI.LateUpdatePointers(timestamp);

        UI.OnLateUpdate(timestamp);
      }

      [GameMethod(AggressiveInlining)]
      internal static void LateUpdateKeys(double timestamp) {
        Util.Keys.IsPrompted = Util.Keys.HasReleased(stackalloc[] {UnityEngine.KeyCode.KeypadEnter, UnityEngine.KeyCode.Return});
      }

      [GameMethod(AggressiveInlining)] internal static void LateUpdatePointers(double timestamp) {}
      [GameMethod(AggressiveInlining)] internal static void LateUpdateTabs    (double timestamp) {}

      [GameMethod(AggressiveInlining)]
      private static void Progress<T>(in Game.Collections.RefList<T> sourceState, Game.Collections.RefList<T>? destinationState) where T : Game.Collections.InputInfo {
        for (uint index = sourceState.Count; 0u != index--; ) {
          int   duplicateIndex = -1;
          ref T input          = ref sourceState[index];

          // …
          if (!input.polled) {
            input.state++; // ->> From `Game.Collections.DeviceState.BEGIN` to `Game.Collections.DeviceState.END` and beyond

            if (destinationState is not null) {
              for (duplicateIndex = (int) destinationState.Count; 0 != duplicateIndex--; ) {
                ref readonly T subinput = ref destinationState[(uint) duplicateIndex];

                if (input.device == subinput.device && input.id == subinput.id)
                break;
              }

              // … ->> Repress duplicates
              if (duplicateIndex != -1) {
                ref T preinput = ref destinationState[(uint) duplicateIndex];

                // … ->> Update `pre`-existing `input`
                preinput.epoch  = input.epoch;
                preinput.polled = true;

                switch (input) {
                  case Game.Collections.KeyInfo key: {
                    ref Game.Collections.KeyInfo prekey = ref (destinationState as Game.Collections.RefList<Game.Collections.KeyInfo>)![(uint) duplicateIndex];
                    /* Do nothing… */
                  } break;

                  case Game.Collections.PointerInfo pointer: {
                    ref Game.Collections.PointerInfo prepointer = ref (destinationState as Game.Collections.RefList<Game.Collections.PointerInfo>)![(uint) duplicateIndex];

                    // …
                    prepointer.origin           = pointer.origin;
                    prepointer.positionPrevious = pointer.positionPrevious != prepointer.position ? pointer.positionPrevious : prepointer.positionPrevious;
                    prepointer.positionRecent   = pointer.positionRecent == prepointer.positionPrevious || pointer.positionRecent == prepointer.position ? pointer.positionRecent : prepointer.positionRecent;
                    prepointer.sequenced        = System.Math.Max(pointer.sequenced, prepointer.sequenced);
                  } break;
                }
              } else destinationState.Add(in input);
            }

            switch (input) {
              case Game.Collections.KeyInfo key: {
                Util.Keys.IsChanging = !(Util.Keys.IsRemoving = destinationState is null);
              } break;

              case Game.Collections.PointerInfo pointer: {
                Util.Pointers.IsChanging = !(Util.Pointers.IsRemoving = destinationState is null);

                if (Util.Pointers.IsChanging) Util.Pointers.Update(pointer);
                if (Util.Pointers.IsRemoving) Util.Pointers.Remove(pointer);
              } break;
            }

            sourceState.RemoveAt(index);

            continue;
          }

          input.polled = false;
        }
      }

      [GameMethod(AggressiveInlining)]
      internal static void Update(double timestamp) {
        UI.UpdateKeys    (timestamp);
        UI.UpdatePointers(timestamp);
        UI.UpdatePointed (timestamp);
        UI.UpdateTabs    (timestamp);

        UI.OnUpdate(timestamp);
      }

      internal unsafe static void UpdateKeys(double timestamp) {
        [GameMethod(AggressiveInlining)]
        static ref readonly Game.Collections.DeviceState PollDeviceState(in System.ReadOnlySpan<bool> states) => ref (Util.Reference<bool>.First(states) ? ref Game.Collections.DeviceState.BEGIN : ref (Util.Reference<bool>.At(states, 1) ? ref Game.Collections.DeviceState.CURRENT : ref (Util.Reference<bool>.At(states, 2) ? ref Game.Collections.DeviceState.END : ref Game.Collections.DeviceState.INVALID)));

        [GameMethod(AggressiveInlining)]
        static void PollKeys<T>(T key, double epoch, bool invalidate, in System.ReadOnlySpan<bool> states, UnityEngine.InputSystem.InputDevice? device) where T : unmanaged, System.Enum {
          for (uint index = Game.Collections.DeviceState.END; Game.Collections.DeviceState.BEGIN != index; )
          if (Game.Util.Reference<bool>.At(states, (int) --index)) {
            Game.Collections.RefList<Game.Collections.KeyInfo> state    = Util.Keys.States[(int) index];
            int                                                                subindex = (int) state.Count;

            // …
            while (0 != subindex--)
            if (
              key is UnityEngine.KeyCode         key1 ? key1 == state[(uint) subindex].codes.Item1 :
              key is UnityEngine.InputSystem.Key key2 ? key2 == state[(uint) subindex].codes.Item2 :
              false
            ) {
              if (!invalidate) state[(uint) subindex].polled = true;
              else { Util.Keys.IsRemoving = false; Util.Keys.Remove(in state[(uint) subindex]); state.RemoveAt((uint) index); }

              break;
            }

            if (!invalidate && subindex == -1) {
              Util.Keys.IsAdding = true;
              Util.Keys.Add(in state.Append(new() {codes = (
                key is UnityEngine.KeyCode         key1 ? (key1, Game.Collections.KeyInfo.Translate(key1)) :
                key is UnityEngine.InputSystem.Key key2 ? (Game.Collections.KeyInfo.Translate(key2), key2) :
                (UnityEngine.KeyCode.None, UnityEngine.InputSystem.Key.None)
              ), device = device, epoch = epoch, polled = true, state = Game.Collections.DeviceState.GetDeviceState(index)}));
            }
          }
        }

        /* … */
        (
          Game.Collections.DeviceState A,               Game.Collections.DeviceState D,         Game.Collections.DeviceState S,          Game.Collections.DeviceState W,
          Game.Collections.DeviceState DownArrow,       Game.Collections.DeviceState LeftArrow, Game.Collections.DeviceState RightArrow, Game.Collections.DeviceState UpArrow,
          Game.Collections.DeviceState Escape,          Game.Collections.DeviceState Tab,
          Game.Collections.DeviceState F1,              Game.Collections.DeviceState F2,          Game.Collections.DeviceState F3,       Game.Collections.DeviceState F4,            Game.Collections.DeviceState F5,              Game.Collections.DeviceState F6,              Game.Collections.DeviceState F7,              Game.Collections.DeviceState F8, Game.Collections.DeviceState F9, Game.Collections.DeviceState F10, Game.Collections.DeviceState F11, Game.Collections.DeviceState F12, Game.Collections.DeviceState F13, Game.Collections.DeviceState F14, Game.Collections.DeviceState F15, Game.Collections.DeviceState F16, Game.Collections.DeviceState F17, Game.Collections.DeviceState F18, Game.Collections.DeviceState F19, Game.Collections.DeviceState F20, Game.Collections.DeviceState F21, Game.Collections.DeviceState F22, Game.Collections.DeviceState F23, Game.Collections.DeviceState F24,
          Game.Collections.DeviceState LeftAlt,         Game.Collections.DeviceState LeftControl, Game.Collections.DeviceState LeftMeta, Game.Collections.DeviceState LeftMetaApple, Game.Collections.DeviceState LeftMetaCommand, Game.Collections.DeviceState LeftMetaWindows, Game.Collections.DeviceState LeftShift,
          Game.Collections.DeviceState NumberpadReturn, Game.Collections.DeviceState Return,
          Game.Collections.DeviceState RightAlt,        Game.Collections.DeviceState RightControl, Game.Collections.DeviceState RightMeta, Game.Collections.DeviceState RightMetaApple, Game.Collections.DeviceState RightMetaCommand, Game.Collections.DeviceState RightMetaWindows, Game.Collections.DeviceState RightShift,
          Game.Collections.DeviceState Space
        ) polled = (Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID, Game.Collections.DeviceState.INVALID);

        /* … */
        Util.Keys.IsAdding   = false;
        Util.Keys.IsChanging = false;
        Util.Keys.IsRemoving = false;

        if (!UI.Blurred) {
          // … ->> Acknowledge `UnityEngine.Input.GetKey*(…)` key binds
          fixed (UnityEngine.KeyCode* address = Util.Keys.All.Item1.Items)
          for (UnityEngine.KeyCode* iterator = address + Util.Keys.All.Item1.Count; address != iterator; ) {
            ref readonly UnityEngine.KeyCode                  key    = ref *--iterator;
            System.ReadOnlySpan<bool>                         states = stackalloc[] {UnityEngine.Input.GetKeyDown(key), UnityEngine.Input.GetKey(key), UnityEngine.Input.GetKeyUp(key)};
            ref readonly Game.Collections.DeviceState state  = ref PollDeviceState(in states);

            // …
            PollKeys(key, timestamp, false, in states, null);

            if (UnityEngine.KeyCode.A            == key) polled.A                = state;
            if (UnityEngine.KeyCode.D            == key) polled.D                = state;
            if (UnityEngine.KeyCode.DownArrow    == key) polled.DownArrow        = state;
            if (UnityEngine.KeyCode.Escape       == key) polled.Escape           = state;
            if (UnityEngine.KeyCode.F1           == key) polled.F1               = state;
            if (UnityEngine.KeyCode.F10          == key) polled.F10              = state;
            if (UnityEngine.KeyCode.F11          == key) polled.F11              = state;
            if (UnityEngine.KeyCode.F12          == key) polled.F12              = state;
            if (UnityEngine.KeyCode.F13          == key) polled.F13              = state;
            if (UnityEngine.KeyCode.F14          == key) polled.F14              = state;
            if (UnityEngine.KeyCode.F15          == key) polled.F15              = state;
            if (UnityEngine.KeyCode.F2           == key) polled.F2               = state;
            if (UnityEngine.KeyCode.F3           == key) polled.F3               = state;
            if (UnityEngine.KeyCode.F4           == key) polled.F4               = state;
            if (UnityEngine.KeyCode.F5           == key) polled.F5               = state;
            if (UnityEngine.KeyCode.F6           == key) polled.F6               = state;
            if (UnityEngine.KeyCode.F7           == key) polled.F7               = state;
            if (UnityEngine.KeyCode.F8           == key) polled.F8               = state;
            if (UnityEngine.KeyCode.F9           == key) polled.F9               = state;
            if (UnityEngine.KeyCode.KeypadEnter  == key) polled.NumberpadReturn  = state;
            if (UnityEngine.KeyCode.LeftAlt      == key) polled.LeftAlt          = state;
            if (UnityEngine.KeyCode.LeftApple    == key) polled.LeftMetaApple    = state;
            if (UnityEngine.KeyCode.LeftArrow    == key) polled.LeftArrow        = state;
            if (UnityEngine.KeyCode.LeftCommand  == key) polled.LeftMetaCommand  = state;
            if (UnityEngine.KeyCode.LeftControl  == key) polled.LeftControl      = state;
            if (UnityEngine.KeyCode.LeftMeta     == key) polled.LeftMeta         = state;
            if (UnityEngine.KeyCode.LeftShift    == key) polled.LeftShift        = state;
            if (UnityEngine.KeyCode.LeftWindows  == key) polled.LeftMetaWindows  = state;
            if (UnityEngine.KeyCode.Return       == key) polled.Return           = state;
            if (UnityEngine.KeyCode.RightAlt     == key) polled.RightAlt         = state;
            if (UnityEngine.KeyCode.RightApple   == key) polled.RightMetaApple   = state;
            if (UnityEngine.KeyCode.RightArrow   == key) polled.RightArrow       = state;
            if (UnityEngine.KeyCode.RightCommand == key) polled.RightMetaCommand = state;
            if (UnityEngine.KeyCode.RightControl == key) polled.RightControl     = state;
            if (UnityEngine.KeyCode.RightMeta    == key) polled.RightMeta        = state;
            if (UnityEngine.KeyCode.RightShift   == key) polled.RightShift       = state;
            if (UnityEngine.KeyCode.RightWindows == key) polled.RightMetaWindows = state;
            if (UnityEngine.KeyCode.S            == key) polled.S                = state;
            if (UnityEngine.KeyCode.Space        == key) polled.Space            = state;
            if (UnityEngine.KeyCode.Tab          == key) polled.Tab              = state;
            if (UnityEngine.KeyCode.UpArrow      == key) polled.UpArrow          = state;
            if (UnityEngine.KeyCode.UpArrow      == key) polled.UpArrow          = state;
            if (UnityEngine.KeyCode.W            == key) polled.W                = state;
          }

          // … ->> Acknowledge `UnityEngine.InputSystem.*` key binds
          foreach (UnityEngine.InputSystem.Controls.KeyControl keyControl in UI.Keyboard.Value?.allKeys ?? new UnityEngine.InputSystem.Utilities.ReadOnlyArray<UnityEngine.InputSystem.Controls.KeyControl>(System.Array.Empty<UnityEngine.InputSystem.Controls.KeyControl>()))
          if (keyControl is not null) {
            UnityEngine.InputSystem.Key                       key    = keyControl.keyCode;
            System.ReadOnlySpan<bool>                         states = stackalloc[] {keyControl.wasPressedThisFrame, keyControl.isPressed, keyControl.wasReleasedThisFrame};
            ref readonly Game.Collections.DeviceState state  = ref PollDeviceState(in states);

            // …
            PollKeys(key, timestamp, false, in states, (UnityEngine.InputSystem.Keyboard) UI.Keyboard);

            if (UnityEngine.InputSystem.Key.A            == key) polled.A                = state;
            if (UnityEngine.InputSystem.Key.D            == key) polled.D                = state;
            if (UnityEngine.InputSystem.Key.DownArrow    == key) polled.DownArrow        = state;
            if (UnityEngine.InputSystem.Key.Enter        == key) polled.Return           = state;
            if (UnityEngine.InputSystem.Key.Escape       == key) polled.Escape           = state;
            if (UnityEngine.InputSystem.Key.F1           == key) polled.F1               = state;
            if (UnityEngine.InputSystem.Key.F10          == key) polled.F10              = state;
            if (UnityEngine.InputSystem.Key.F11          == key) polled.F11              = state;
            if (UnityEngine.InputSystem.Key.F12          == key) polled.F12              = state;
            if (UnityEngine.InputSystem.Key.F2           == key) polled.F2               = state;
            if (UnityEngine.InputSystem.Key.F3           == key) polled.F3               = state;
            if (UnityEngine.InputSystem.Key.F4           == key) polled.F4               = state;
            if (UnityEngine.InputSystem.Key.F5           == key) polled.F5               = state;
            if (UnityEngine.InputSystem.Key.F6           == key) polled.F6               = state;
            if (UnityEngine.InputSystem.Key.F7           == key) polled.F7               = state;
            if (UnityEngine.InputSystem.Key.F8           == key) polled.F8               = state;
            if (UnityEngine.InputSystem.Key.F9           == key) polled.F9               = state;
            if (UnityEngine.InputSystem.Key.LeftAlt      == key) polled.LeftAlt          = state;
            if (UnityEngine.InputSystem.Key.LeftApple    == key) polled.LeftMetaApple    = state;
            if (UnityEngine.InputSystem.Key.LeftArrow    == key) polled.LeftArrow        = state;
            if (UnityEngine.InputSystem.Key.LeftCommand  == key) polled.LeftMetaCommand  = state;
            if (UnityEngine.InputSystem.Key.LeftCtrl     == key) polled.LeftControl      = state;
            if (UnityEngine.InputSystem.Key.LeftMeta     == key) polled.LeftMeta         = state;
            if (UnityEngine.InputSystem.Key.LeftShift    == key) polled.LeftShift        = state;
            if (UnityEngine.InputSystem.Key.LeftWindows  == key) polled.LeftMetaWindows  = state;
            if (UnityEngine.InputSystem.Key.NumpadEnter  == key) polled.NumberpadReturn  = state;
            if (UnityEngine.InputSystem.Key.RightAlt     == key) polled.RightAlt         = state;
            if (UnityEngine.InputSystem.Key.RightApple   == key) polled.RightMetaApple   = state;
            if (UnityEngine.InputSystem.Key.RightArrow   == key) polled.RightArrow       = state;
            if (UnityEngine.InputSystem.Key.RightCommand == key) polled.RightMetaCommand = state;
            if (UnityEngine.InputSystem.Key.RightCtrl    == key) polled.RightControl     = state;
            if (UnityEngine.InputSystem.Key.RightMeta    == key) polled.RightMeta        = state;
            if (UnityEngine.InputSystem.Key.RightShift   == key) polled.RightShift       = state;
            if (UnityEngine.InputSystem.Key.RightWindows == key) polled.RightMetaWindows = state;
            if (UnityEngine.InputSystem.Key.S            == key) polled.S                = state;
            if (UnityEngine.InputSystem.Key.Space        == key) polled.Space            = state;
            if (UnityEngine.InputSystem.Key.Tab          == key) polled.Tab              = state;
            if (UnityEngine.InputSystem.Key.UpArrow      == key) polled.UpArrow          = state;
            if (UnityEngine.InputSystem.Key.W            == key) polled.W                = state;
          }
        }

        // … ->> Update prior keys
        UI.Progress(in Util.Keys.EndState,     null);
        UI.Progress(in Util.Keys.CurrentState, Util.Keys.EndState);
        UI.Progress(in Util.Keys.BeginState,   Util.Keys.CurrentState);

        Util.Keys.IsPrompted                 = Game.Collections.DeviceState.END == polled.NumberpadReturn || Game.Collections.DeviceState.END == polled.Return;
        Util.Keys.Functions.F1               = !polled.F1               ? Util.Keys.Functions.F1               + 1u : polled.F1;
        Util.Keys.Functions.F2               = !polled.F2               ? Util.Keys.Functions.F2               + 1u : polled.F2;
        Util.Keys.Functions.F3               = !polled.F3               ? Util.Keys.Functions.F3               + 1u : polled.F3;
        Util.Keys.Functions.F4               = !polled.F4               ? Util.Keys.Functions.F4               + 1u : polled.F4;
        Util.Keys.Functions.F5               = !polled.F5               ? Util.Keys.Functions.F5               + 1u : polled.F5;
        Util.Keys.Functions.F6               = !polled.F6               ? Util.Keys.Functions.F6               + 1u : polled.F6;
        Util.Keys.Functions.F7               = !polled.F7               ? Util.Keys.Functions.F7               + 1u : polled.F7;
        Util.Keys.Functions.F8               = !polled.F8               ? Util.Keys.Functions.F8               + 1u : polled.F8;
        Util.Keys.Functions.F9               = !polled.F9               ? Util.Keys.Functions.F9               + 1u : polled.F9;
        Util.Keys.Functions.F10              = !polled.F10              ? Util.Keys.Functions.F10              + 1u : polled.F10;
        Util.Keys.Functions.F11              = !polled.F11              ? Util.Keys.Functions.F11              + 1u : polled.F11;
        Util.Keys.Functions.F12              = !polled.F12              ? Util.Keys.Functions.F12              + 1u : polled.F12;
        Util.Keys.Functions.F13              = !polled.F13              ? Util.Keys.Functions.F13              + 1u : polled.F13;
        Util.Keys.Functions.F14              = !polled.F14              ? Util.Keys.Functions.F14              + 1u : polled.F14;
        Util.Keys.Functions.F15              = !polled.F15              ? Util.Keys.Functions.F15              + 1u : polled.F15;
        Util.Keys.Functions.F16              = !polled.F16              ? Util.Keys.Functions.F16              + 1u : polled.F16;
        Util.Keys.Functions.F17              = !polled.F17              ? Util.Keys.Functions.F17              + 1u : polled.F17;
        Util.Keys.Functions.F18              = !polled.F18              ? Util.Keys.Functions.F18              + 1u : polled.F18;
        Util.Keys.Functions.F19              = !polled.F19              ? Util.Keys.Functions.F19              + 1u : polled.F19;
        Util.Keys.Functions.F20              = !polled.F20              ? Util.Keys.Functions.F20              + 1u : polled.F20;
        Util.Keys.Functions.F21              = !polled.F21              ? Util.Keys.Functions.F21              + 1u : polled.F21;
        Util.Keys.Functions.F22              = !polled.F22              ? Util.Keys.Functions.F22              + 1u : polled.F22;
        Util.Keys.Functions.F23              = !polled.F23              ? Util.Keys.Functions.F23              + 1u : polled.F23;
        Util.Keys.Functions.F24              = !polled.F24              ? Util.Keys.Functions.F24              + 1u : polled.F24;
        Util.Keys.Modifiers.LeftAlt          = !polled.LeftAlt          ? Util.Keys.Modifiers.LeftAlt          + 1u : polled.LeftAlt;
        Util.Keys.Modifiers.LeftControl      = !polled.LeftControl      ? Util.Keys.Modifiers.LeftControl      + 1u : polled.LeftControl;
        Util.Keys.Modifiers.LeftMeta         = !polled.LeftMeta         ? Util.Keys.Modifiers.LeftMeta         + 1u : polled.LeftMeta;
        Util.Keys.Modifiers.LeftMetaApple    = !polled.LeftMetaApple    ? Util.Keys.Modifiers.LeftMetaApple    + 1u : polled.LeftMetaApple;
        Util.Keys.Modifiers.LeftMetaCommand  = !polled.LeftMetaCommand  ? Util.Keys.Modifiers.LeftMetaCommand  + 1u : polled.LeftMetaCommand;
        Util.Keys.Modifiers.LeftMetaWindows  = !polled.LeftMetaWindows  ? Util.Keys.Modifiers.LeftMetaWindows  + 1u : polled.LeftMetaWindows;
        Util.Keys.Modifiers.LeftShift        = !polled.LeftShift        ? Util.Keys.Modifiers.LeftShift        + 1u : polled.LeftShift;
        Util.Keys.Modifiers.RightAlt         = !polled.RightAlt         ? Util.Keys.Modifiers.RightAlt         + 1u : polled.RightAlt;
        Util.Keys.Modifiers.RightControl     = !polled.RightControl     ? Util.Keys.Modifiers.RightControl     + 1u : polled.RightControl;
        Util.Keys.Modifiers.RightMeta        = !polled.RightMeta        ? Util.Keys.Modifiers.RightMeta        + 1u : polled.RightMeta;
        Util.Keys.Modifiers.RightMetaApple   = !polled.RightMetaApple   ? Util.Keys.Modifiers.RightMetaApple   + 1u : polled.RightMetaApple;
        Util.Keys.Modifiers.RightMetaCommand = !polled.RightMetaCommand ? Util.Keys.Modifiers.RightMetaCommand + 1u : polled.RightMetaCommand;
        Util.Keys.Modifiers.RightMetaWindows = !polled.RightMetaWindows ? Util.Keys.Modifiers.RightMetaWindows + 1u : polled.RightMetaWindows;
        Util.Keys.Modifiers.RightShift       = !polled.RightShift       ? Util.Keys.Modifiers.RightShift       + 1u : polled.RightShift;
        Util.Keys.Specials .A                = !polled.A                ? Util.Keys.Specials .A                + 1u : polled.A;
        Util.Keys.Specials .D                = !polled.D                ? Util.Keys.Specials .D                + 1u : polled.D;
        Util.Keys.Specials .DownArrow        = !polled.DownArrow        ? Util.Keys.Specials .DownArrow        + 1u : polled.DownArrow;
        Util.Keys.Specials .Escape           = !polled.Escape           ? Util.Keys.Specials .Escape           + 1u : polled.Escape;
        Util.Keys.Specials .LeftArrow        = !polled.LeftArrow        ? Util.Keys.Specials .LeftArrow        + 1u : polled.LeftArrow;
        Util.Keys.Specials .RightArrow       = !polled.RightArrow       ? Util.Keys.Specials .RightArrow       + 1u : polled.RightArrow;
        Util.Keys.Specials .S                = !polled.S                ? Util.Keys.Specials .S                + 1u : polled.S;
        Util.Keys.Specials .Space            = !polled.Space            ? Util.Keys.Specials .Space            + 1u : polled.Space;
        Util.Keys.Specials .Tab              = !polled.Tab              ? Util.Keys.Specials .Tab              + 1u : polled.Tab;
        Util.Keys.Specials .UpArrow          = !polled.UpArrow          ? Util.Keys.Specials .UpArrow          + 1u : polled.UpArrow;
        Util.Keys.Specials .W                = !polled.W                ? Util.Keys.Specials .W                + 1u : polled.W;

        if (Util.Keys.IsPrompted)
        Util.Keys.Prompt();
      }

      internal static void UpdatePointed(double timestamp) {
        [GameMethod(AggressiveInlining)]
        static void PollPointed(in Game.Collections.RefList<Game.Collections.PointerInfo> state, double epoch) {
          if (null == Util.Pointed.EventSystem || null == Util.Pointed.GraphicRaycaster)
          return;

          foreach (ref readonly Game.Collections.PointerInfo pointer in state)
          foreach (UnityEngine.UI.Graphic pointed in Util.Pointers.Raycast(Util.Pointed.GraphicRaycaster, Util.Pointed.EventSystem, in pointer)) {
            int index = (int) Util.Pointed.Any.Count;

            // … ->> Track prior pointed objects
            while (0 != index--) {
              ref Game.Collections.PointedInfo subpointed = ref Util.Pointed.Any[(uint) index];

              // … ->> Disregard assumption about pointed object no longer being pointed at
              if (pointed == subpointed.graphic) {
                subpointed.pointersList.Add(in pointer);
                subpointed.state = Game.Collections.DeviceState.CURRENT;

                break;
              }
            }

            // … ->> Acknowledge newly pointed object
            if (index == -1)
            Util.Pointed.Any.Add(new() {epoch = epoch, graphic = pointed, pointersList = new(2u) {pointer}, state = Game.Collections.DeviceState.BEGIN});
          }
        }

        // … ->> Assume pointed objects are no longer being pointed at and remove them
        for (uint index = Util.Pointed.Any.Count; 0u != index--; ) {
          ref Game.Collections.PointedInfo pointed = ref Util.Pointed.Any[index];

          // …
          if (Game.Collections.DeviceState.END == pointed.state) Util.Pointed.Any.RemoveAt(index); // ->> Act on the assumption afterward
          else { pointed.pointersList.Clear(); pointed.state = Game.Collections.DeviceState.END; } // ->> Make the assumption
        }

        // … ->> Track pointed `UnityEngine.UI.Graphic` objects
        PollPointed(in Util.Pointers.BeginState,   timestamp);
        PollPointed(in Util.Pointers.CurrentState, timestamp);
        PollPointed(in Util.Pointers.EndState,     timestamp);

        // … ->> Acknowledge objects no longer being pointed at
        foreach (ref Game.Collections.PointedInfo pointed in Util.Pointed.Any) {
          if (Game.Collections.DeviceState.END == pointed.state)
          pointed.epoch = timestamp;
        }
      }

      internal static void UpdatePointers(double timestamp) {
        [GameMethod(AggressiveInlining)]
        static void PollPointers(long id, double epoch, uint count, bool inverted, in UnityEngine.Vector2 position, float pressure, in UnityEngine.Vector2 origin, in UnityEngine.Vector2 radius, bool invalidate, in System.ReadOnlySpan<bool> states, UnityEngine.InputSystem.InputDevice? device) {
          for (uint index = Game.Collections.DeviceState.END; Game.Collections.DeviceState.BEGIN != index; )
          if (Game.Util.Reference<bool>.At(states, (int) --index)) {
            Game.Collections.RefList<Game.Collections.PointerInfo> state    = Util.Pointers.States[(int) index];
            int                                                                    subindex = (int) state.Count;

            // …
            while (0 != subindex--) {
              ref Game.Collections.PointerInfo pointer = ref state[(uint) subindex];

              // …
              if (device == pointer.device && id == pointer.id) {
                if (!invalidate) {
                  if (pointer.position != position) {
                    Util.Pointers.IsChanging = Util.Pointers.IsChanging || pointer.positionPrevious != pointer.position;
                    pointer.positionPrevious = pointer.position;
                  }

                  Util.Pointers.IsChanging = Util.Pointers.IsChanging || pointer.inverted != inverted || pointer.position != position || pointer.positionRecent != pointer.position || pointer.pressure != pressure || pointer.radius != radius || pointer.sequenced != count;
                  pointer.inverted        = inverted;
                  pointer.positionRecent  = pointer.position;
                  pointer.position        = position;
                  pointer.polled          = true;
                  pointer.pressure        = pressure;
                  pointer.radius          = radius;
                  pointer.sequenced       = count;

                  if (Util.Pointers.IsChanging)
                  Util.Pointers.Update(in pointer);
                } else { Util.Pointers.IsRemoving = true; Util.Pointers.Remove(in pointer); state.RemoveAt((uint) subindex); }

                break;
              }
            }

            if (!invalidate && subindex == -1) {
              Util.Pointers.IsAdding = true;
              Util.Pointers.Add(in state.Append(new() {device = device, epoch = epoch, id = id, inverted = inverted, origin = origin, polled = true, position = position, positionPrevious = position, positionRecent = position, pressure = pressure, radius = radius, sequenced = count, state = Game.Collections.DeviceState.GetDeviceState(index)}));
            }
          }
        }

        [GameMethod(AggressiveInlining)]
        static void PollStates(in Game.Collections.RefList<Game.Collections.PointerInfo> state) {
          ref readonly Game.Collections.DeviceState substate = ref (Util.Pointers.BeginState == state ? ref Game.Collections.DeviceState.BEGIN : ref (Util.Pointers.CurrentState == state ? ref Game.Collections.DeviceState.CURRENT : ref (Util.Pointers.EndState == state ? ref Game.Collections.DeviceState.END : ref Game.Collections.DeviceState.UNKNOWN)));

          // …
          foreach (ref readonly Game.Collections.PointerInfo pointer in state) {
            Util.Pointers.IsMoving = pointer.IsMoving();

            if (Util.Pointers.IsId(pointer.id))
            continue;

            #pragma warning disable CS0665 // ->> “AsSiGnMeNt iN CoNdItIoNaL ExPrEsSiOn iS AlWaYs cOnStAnT; dId yOu mEaN To uSe == InStEaD Of = ?”
              if (Util.Pointers.IsPointing = true)                 Util.Pointers.Point(in pointer);
              if (Util.Pointers.IsClicking = pointer.IsClicking()) Util.Pointers.Click(in pointer);
            #pragma warning restore CS0665

            if (Util.Pointers.IsMouseId(pointer.id)) {
              switch (Util.Pointers.UnmakeMouseId(pointer.id)) {
                case (uint) Util.Pointers.MouseButtonBack   : Util.Pointers.PointerState = Util.Pointers.MouseButtonBackState    = substate; break;
                case (uint) Util.Pointers.MouseButtonForward: Util.Pointers.PointerState = Util.Pointers.MouseButtonForwardState = substate; break;
                case (uint) Util.Pointers.MouseButtonLeft   : Util.Pointers.PointerState = Util.Pointers.MouseButtonLeftState    = substate; break;
                case (uint) Util.Pointers.MouseButtonMiddle : Util.Pointers.PointerState = Util.Pointers.MouseButtonMiddleState  = substate; break;
                case (uint) Util.Pointers.MouseButtonRight  : Util.Pointers.PointerState = Util.Pointers.MouseButtonRightState   = substate; break;
              }

              continue;
            }

            if (Util.Pointers.IsPenId(pointer.id)) {
              switch (Util.Pointers.UnmakePenId(pointer.id)) {
                case (uint) Util.Pointers.PenButtonEraser                    : Util.Pointers.PointerState = Util.Pointers.PenButtonEraserState = substate; break;
                case (uint) Util.Pointers.PenButtonTip                       : Util.Pointers.PointerState = Util.Pointers.PenButtonTipState    = substate; break;
                case uint barrel when barrel >= Util.Pointers.PenButtonBarrel: Util.Pointers.PointerState = Util.Pointers.PenButtonBarrelState = substate; break;
              }

              continue;
            }

            if (Util.Pointers.IsTouchId(pointer.id)) {
              Util.Pointers.PointerState = Util.Pointers.TouchState = substate;
              continue;
            }
          }
        }

        // …
        Util.Pointers.IsAdding   = false;
        Util.Pointers.IsChanging = false;
        Util.Pointers.IsClicking = false;
        Util.Pointers.IsMoving   = false;
        Util.Pointers.IsPointing = false;
        Util.Pointers.IsRemoving = false;

        if (!UI.Blurred) {
          UnityEngine.Vector2 pointerPosition = (
            UI.Mouse                                                           ? UI.Mouse      .Value.position.ReadValue() :
            UI.Pen                                                             ? UI.Pen        .Value.position.ReadValue() :
            UI.Touchscreen.HasValue && !UI.Touchscreen.Value.touches.IsEmpty() ? UI.Touchscreen.Value.position.ReadValue() : // ->> `UI.Touchscreen.Value.primaryTouch.position.ReadValue()`
            UI.Pointer                                                         ? Util.Vector.Coalesce(UI.Pointer.Value.position.ReadValue(), (UnityEngine.Vector2) UnityEngine.Input.mousePosition) :
            (UnityEngine.Vector2) UnityEngine.Input.mousePosition
          );

          // …
          Util.Pointers.ScrollPreviousValue = Util.Pointers.ScrollValue;
          Util.Pointers.ScrollValue         = UnityEngine.Vector2.zero;

          // … ->> Acknowledge `UnityEngine.Input.GetMouse*(…)` pointer (e.g. mouse, pen, touch, e.t.c.) binds
          if (UnityEngine.Input.mousePresent) {
            if (UnityEngine.Vector2.zero != (Util.Pointers.ScrollValue = Util.Vector.ExcludeX(UnityEngine.Input.mouseScrollDelta)))
            Util.Pointers.Scrolls(Util.Pointers.ScrollValue, Util.Pointers.ScrollDelta);

            for (sbyte button = Util.Pointers.MouseButtonMiddle; Util.Pointers.MouseButtonLeft != button--; )
            PollPointers(Util.Pointers.MakeMouseId((uint) button), timestamp, 1u, false, in pointerPosition, 1.0f, in pointerPosition, UnityEngine.Vector2.one, false, stackalloc[] {UnityEngine.Input.GetMouseButtonDown(button), UnityEngine.Input.GetMouseButton(button), UnityEngine.Input.GetMouseButtonUp(button)}, null);
          }

          // … ->> Acknowledge `UnityEngine.Touch` touch binds
          if (UnityEngine.Input.touchSupported)
          for (int index = UnityEngine.Input.touchCount; 0 != index--; ) {
            UnityEngine.Touch touch = UnityEngine.Input.GetTouch(index);
            PollPointers(Util.Pointers.MakeTouchId((uint) touch.fingerId), timestamp /* ->> Not `UnityEngine.Touch::deltaTime` */, (uint) touch.tapCount, false, touch.position, UnityEngine.Input.touchPressureSupported ? touch.pressure : 1.0f, touch.rawPosition, UnityEngine.Vector2.one * touch.radius, false, stackalloc[] {UnityEngine.TouchPhase.Began == touch.phase, UnityEngine.TouchPhase.Moved == touch.phase || UnityEngine.TouchPhase.Stationary == touch.phase, UnityEngine.TouchPhase.Canceled == touch.phase || UnityEngine.TouchPhase.Ended == touch.phase}, null);
          }

          // … ->> Acknowledge `UnityEngine.InputSystem.*` mouse binds
          if (UI.Mouse) {
            uint                id       = (uint) UI.Mouse.Value.deviceId; // ->> Unsure about `::pointerId.ReadValue()`
            UnityEngine.Vector2 position = UI.Mouse.Value.position.ReadValue();
            UnityEngine.Vector2 scroll   = UI.Mouse.Value.scroll  .ReadValue();

            // …
            if (UnityEngine.Vector2.zero != (Util.Pointers.ScrollValue = scroll))
            Util.Pointers.Scrolls(Util.Pointers.ScrollValue, Util.Pointers.ScrollDelta);

            if (UI.Mouse.Value.leftButton    is not null) PollPointers(Util.Pointers.MakeMouseId(/* id + */ (uint) Util.Pointers.MouseButtonLeft)    /* ->> `UI.Mouse.Value.leftButton   .path` */, timestamp, 1u, false, in position, 1.0f, in position, UnityEngine.Vector2.one, false, stackalloc[] {UI.Mouse.Value.leftButton   .wasPressedThisFrame, UI.Mouse.Value.leftButton   .isPressed, UI.Mouse.Value.leftButton   .wasReleasedThisFrame}, (UnityEngine.InputSystem.Mouse) UI.Mouse);
            if (UI.Mouse.Value.middleButton  is not null) PollPointers(Util.Pointers.MakeMouseId(/* id + */ (uint) Util.Pointers.MouseButtonMiddle)  /* ->> `UI.Mouse.Value.middleButton .path` */, timestamp, 1u, false, in position, 1.0f, in position, UnityEngine.Vector2.one, false, stackalloc[] {UI.Mouse.Value.middleButton .wasPressedThisFrame, UI.Mouse.Value.middleButton .isPressed, UI.Mouse.Value.middleButton .wasReleasedThisFrame}, (UnityEngine.InputSystem.Mouse) UI.Mouse);
            if (UI.Mouse.Value.rightButton   is not null) PollPointers(Util.Pointers.MakeMouseId(/* id + */ (uint) Util.Pointers.MouseButtonRight)   /* ->> `UI.Mouse.Value.rightButton  .path` */, timestamp, 1u, false, in position, 1.0f, in position, UnityEngine.Vector2.one, false, stackalloc[] {UI.Mouse.Value.rightButton  .wasPressedThisFrame, UI.Mouse.Value.rightButton  .isPressed, UI.Mouse.Value.rightButton  .wasReleasedThisFrame}, (UnityEngine.InputSystem.Mouse) UI.Mouse);
            if (UI.Mouse.Value.forwardButton is not null) PollPointers(Util.Pointers.MakeMouseId(/* id + */ (uint) Util.Pointers.MouseButtonForward) /* ->> `UI.Mouse.Value.forwardButton.path` */, timestamp, 1u, false, in position, 1.0f, in position, UnityEngine.Vector2.one, false, stackalloc[] {UI.Mouse.Value.forwardButton.wasPressedThisFrame, UI.Mouse.Value.forwardButton.isPressed, UI.Mouse.Value.forwardButton.wasReleasedThisFrame}, (UnityEngine.InputSystem.Mouse) UI.Mouse);
            if (UI.Mouse.Value.backButton    is not null) PollPointers(Util.Pointers.MakeMouseId(/* id + */ (uint) Util.Pointers.MouseButtonBack)    /* ->> `UI.Mouse.Value.backButton   .path` */, timestamp, 1u, false, in position, 1.0f, in position, UnityEngine.Vector2.one, false, stackalloc[] {UI.Mouse.Value.backButton   .wasPressedThisFrame, UI.Mouse.Value.backButton   .isPressed, UI.Mouse.Value.backButton   .wasReleasedThisFrame}, (UnityEngine.InputSystem.Mouse) UI.Mouse);
          }

          // … ->> Acknowledge `UnityEngine.InputSystem.*` pen binds
          if (UI.Pen) {
            uint                id       = (uint) UI.Pen.Value.deviceId; // ->> Unsure about `::pointerId.ReadValue()`
            UnityEngine.Vector2 position = UI.Pen.Value.position.ReadValue();

            // …
            if (UI.Pen.Value.tip                                        is not null) PollPointers(Util.Pointers.MakePenId(id + (uint) Util.Pointers.PenButtonTip)        /* ->> `UI.Pen.Value.tip                                       .path` */, timestamp, 1u, UI.Pen.Value.tip                                       .invert, in position, UI.Pen.Value.pressure.ReadValue(), in position, UnityEngine.Vector2.one, false, stackalloc[] {UI.Pen.Value.tip                                       .wasPressedThisFrame, UI.Pen.Value.tip                                       .isPressed, UI.Pen.Value.tip                                       .wasReleasedThisFrame}, (UnityEngine.InputSystem.Pen) UI.Pen);
            if (UI.Pen.Value.eraser                                     is not null) PollPointers(Util.Pointers.MakePenId(id + (uint) Util.Pointers.PenButtonEraser)     /* ->> `UI.Pen.Value.eraser                                    .path` */, timestamp, 1u, UI.Pen.Value.eraser                                    .invert, in position, UI.Pen.Value.pressure.ReadValue(), in position, UnityEngine.Vector2.one, false, stackalloc[] {UI.Pen.Value.eraser                                    .wasPressedThisFrame, UI.Pen.Value.eraser                                    .isPressed, UI.Pen.Value.eraser                                    .wasReleasedThisFrame}, (UnityEngine.InputSystem.Pen) UI.Pen);
            if (UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel1] is not null) PollPointers(Util.Pointers.MakePenId(id + (uint) Util.Pointers.PenButtonBarrel + 0) /* ->> `UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel1].path` */, timestamp, 1u, UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel1].invert, in position, UI.Pen.Value.pressure.ReadValue(), in position, UnityEngine.Vector2.one, false, stackalloc[] {UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel1].wasPressedThisFrame, UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel1].isPressed, UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel1].wasReleasedThisFrame}, (UnityEngine.InputSystem.Pen) UI.Pen);
            if (UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel2] is not null) PollPointers(Util.Pointers.MakePenId(id + (uint) Util.Pointers.PenButtonBarrel + 1) /* ->> `UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel2].path` */, timestamp, 1u, UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel2].invert, in position, UI.Pen.Value.pressure.ReadValue(), in position, UnityEngine.Vector2.one, false, stackalloc[] {UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel2].wasPressedThisFrame, UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel2].isPressed, UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel2].wasReleasedThisFrame}, (UnityEngine.InputSystem.Pen) UI.Pen);
            if (UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel3] is not null) PollPointers(Util.Pointers.MakePenId(id + (uint) Util.Pointers.PenButtonBarrel + 2) /* ->> `UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel3].path` */, timestamp, 1u, UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel3].invert, in position, UI.Pen.Value.pressure.ReadValue(), in position, UnityEngine.Vector2.one, false, stackalloc[] {UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel3].wasPressedThisFrame, UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel3].isPressed, UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel3].wasReleasedThisFrame}, (UnityEngine.InputSystem.Pen) UI.Pen);
            if (UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel4] is not null) PollPointers(Util.Pointers.MakePenId(id + (uint) Util.Pointers.PenButtonBarrel + 3) /* ->> `UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel4].path` */, timestamp, 1u, UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel4].invert, in position, UI.Pen.Value.pressure.ReadValue(), in position, UnityEngine.Vector2.one, false, stackalloc[] {UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel4].wasPressedThisFrame, UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel4].isPressed, UI.Pen.Value[UnityEngine.InputSystem.PenButton.Barrel4].wasReleasedThisFrame}, (UnityEngine.InputSystem.Pen) UI.Pen);
          }

          // … ->> Acknowledge `UnityEngine.InputSystem.*` touch binds
          if (UI.Touchscreen) {
            UnityEngine.InputSystem.Utilities.ReadOnlyArray<UnityEngine.InputSystem.Controls.TouchControl> touches = UI.Touchscreen.Value.touches;

            // …
            if (!touches.IsEmpty()) {
              UnityEngine.InputSystem.Controls.TouchControl      primaryTouch      = UI.Touchscreen.Value.primaryTouch;
              UnityEngine.InputSystem.TouchPhase                 primaryTouchPhase = primaryTouch?.phase.ReadValue() ?? UnityEngine.InputSystem.TouchPhase.None;
              UnityEngine.InputSystem.Controls.TouchPressControl primaryTouchPress = primaryTouch?.press!;

              // …
              foreach (UnityEngine.InputSystem.Controls.TouchControl touch in touches)
              if (touch is not null) {
                UnityEngine.InputSystem.TouchPhase                 phase = touch.phase.ReadValue();
                UnityEngine.InputSystem.Controls.TouchPressControl press = touch.press;

                if (press is not null)
                PollPointers(Util.Pointers.MakeTouchId((uint) touch.touchId.ReadValue()) /* ->> `touch.path` */, timestamp, (uint) touch.tapCount.ReadValue(), false, touch.position.ReadValue(), touch.pressure.ReadValue(), touch.startPosition.ReadValue(), touch.radius.ReadValue(), UnityEngine.InputSystem.TouchPhase.None == phase, stackalloc[] {press.wasPressedThisFrame || UnityEngine.InputSystem.TouchPhase.Began == phase, press.isPressed || UnityEngine.InputSystem.TouchPhase.Moved == phase || UnityEngine.InputSystem.TouchPhase.Stationary == phase, press.wasReleasedThisFrame || UnityEngine.InputSystem.TouchPhase.Canceled == phase || UnityEngine.InputSystem.TouchPhase.Ended == phase}, (UnityEngine.InputSystem.Touchscreen) UI.Touchscreen);
              }

              if (primaryTouch is not null && primaryTouchPress is not null)
              PollPointers(Util.Pointers.MakeTouchId((uint) primaryTouch.touchId.ReadValue()) /* ->> `primaryTouch.path` */, timestamp, (uint) primaryTouch.tapCount.ReadValue(), false, primaryTouch.position.ReadValue(), primaryTouch.pressure.ReadValue(), primaryTouch.startPosition.ReadValue(), primaryTouch.radius.ReadValue(), UnityEngine.InputSystem.TouchPhase.None == primaryTouchPhase, stackalloc[] {primaryTouchPress.wasPressedThisFrame || UnityEngine.InputSystem.TouchPhase.Began == primaryTouchPhase, primaryTouchPress.isPressed || UnityEngine.InputSystem.TouchPhase.Moved == primaryTouchPhase || UnityEngine.InputSystem.TouchPhase.Stationary == primaryTouchPhase, primaryTouchPress.wasReleasedThisFrame || UnityEngine.InputSystem.TouchPhase.Canceled == primaryTouchPhase || UnityEngine.InputSystem.TouchPhase.Ended == primaryTouchPhase}, (UnityEngine.InputSystem.Touchscreen) UI.Touchscreen);
            }
          }

          if (UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.enabled)
          foreach (UnityEngine.InputSystem.EnhancedTouch.Touch touch in UnityEngine.InputSystem.EnhancedTouch.Touch.activeTouches) {
            UnityEngine.InputSystem.TouchPhase phase = touch.phase;
            PollPointers(Util.Pointers.MakeEnhancedTouchId((uint) touch.touchId), touch.startTime, (uint) touch.tapCount, false, touch.screenPosition, touch.pressure, touch.startScreenPosition, touch.radius, !touch.valid || UnityEngine.InputSystem.TouchPhase.None == phase, stackalloc[] {UnityEngine.InputSystem.TouchPhase.Began == phase, UnityEngine.InputSystem.TouchPhase.Moved == phase || UnityEngine.InputSystem.TouchPhase.Stationary == phase, UnityEngine.InputSystem.TouchPhase.Canceled == phase || UnityEngine.InputSystem.TouchPhase.Ended == phase}, (UnityEngine.InputSystem.Touchscreen) UI.Touchscreen);
          }

          // … ->> Acknowledge `UnityEngine.InputSystem.*` pointer binds
          if (UI.Pointer) {
            UnityEngine.Vector2 position = UI.Pointer.Value.position.ReadValue();
            PollPointers(Util.Pointers.MakePointerId((uint) UI.Pointer.Value.deviceId) /* ->> Unsure about `::pointerId.ReadValue()` */, timestamp, 1u, false, in position, 1.0f, in position, UnityEngine.Vector2.one, false, stackalloc[] {UI.Pointer.Value.press.wasPressedThisFrame, UI.Pointer.Value.press.isPressed, UI.Pointer.Value.press.wasReleasedThisFrame}, (UnityEngine.InputSystem.Pointer) UI.Pointer);
          }

          // … ->> Acknowledge (mouse) cursor movement at least
          if (UnityEngine.Input.mousePresent) {
            if (0u != UI.PointerAcknowledged)
              PollPointers(Util.Pointers.MakeId(), timestamp, 0u, false, in pointerPosition, 0.0f, in pointerPosition, UnityEngine.Vector2.one, false, stackalloc[] {UI.PointerAcknowledged == 1u, UI.PointerAcknowledged >= 2u, false}, null);

            UI.PointerAcknowledged = (byte) System.Math.Min(UI.PointerAcknowledged + 1u, 2u);
          }
        }

        // … ->> Update prior pointers
        Util.Pointers.MouseButtonBackState    = Game.Collections.DeviceState.UNKNOWN;
        Util.Pointers.MouseButtonForwardState = Game.Collections.DeviceState.UNKNOWN;
        Util.Pointers.MouseButtonLeftState    = Game.Collections.DeviceState.UNKNOWN;
        Util.Pointers.MouseButtonMiddleState  = Game.Collections.DeviceState.UNKNOWN;
        Util.Pointers.MouseButtonRightState   = Game.Collections.DeviceState.UNKNOWN;
        Util.Pointers.PenButtonBarrelState    = Game.Collections.DeviceState.UNKNOWN;
        Util.Pointers.PenButtonEraserState    = Game.Collections.DeviceState.UNKNOWN;
        Util.Pointers.PenButtonTipState       = Game.Collections.DeviceState.UNKNOWN;
        Util.Pointers.PointerState            = Game.Collections.DeviceState.UNKNOWN;
        Util.Pointers.TouchState              = Game.Collections.DeviceState.UNKNOWN;

        PollStates(in Util.Pointers.EndState);
        PollStates(in Util.Pointers.CurrentState);
        PollStates(in Util.Pointers.BeginState);

        UI.Progress(in Util.Pointers.EndState,     null);
        UI.Progress(in Util.Pointers.CurrentState, Util.Pointers.EndState);
        UI.Progress(in Util.Pointers.BeginState,   Util.Pointers.CurrentState);
      }

      internal static void UpdateTabs(double timestamp) {
        if (UI.TabList.IsEmpty() || Util.Keys.Specials.Escape < Game.Collections.DeviceState.END) {
          UI.BlurTabs();
          return;
        }

        UI.TabIsChanging = false;

        if (!UI.Blurred) {
          UI.TabIsBlurred = false;

          if (Util.Keys.Specials.Tab < Game.Collections.DeviceState.END) {
            int   count = UI.TabList.Count;
            sbyte shift = Util.Keys.Modifiers.Shift < Game.Collections.DeviceState.END ? (sbyte) -1 : (sbyte) +1;

            // …
            if (0.0 == UI.TabDelayElapsed || Util.Keys.RepeatDelay <= UI.TabDelayElapsed) {
              if (UI.TabIndex == -1 && UI.TabIndexPreserved && UI.TabPreviousIndex < count && UI.TabPreviousIndex != -1)
                UI.TabIndex = UI.TabPreviousIndex;

              else {
                UI.TabIndex = (UI.TabIndex == -1 && shift == -1 ? count     : UI.TabIndex) + shift;
                UI.TabIndex = (UI.TabIndex == -1                ? count - 1 : UI.TabIndex) % UI.TabList.Count;
              }

              UI.TabIsChanging    = true;
              UI.TabPreviousIndex = UI.TabIndex;
            }

            UI.TabDelayElapsed = System.Math.Min((float) Util.Keys.RepeatDelay, UI.TabDelayElapsed + (UnityEngine.Time.unscaledDeltaTime + float.Epsilon));
            return;
          }
        }

        UI.TabDelayElapsed = 0.0f;
      }

      #if UNITY_EDITOR
        public static Game.GUIField? DelegateGUIField<T>() {
          if (typeof(T) == typeof(bool))                              return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.Toggle         (position,                              (System.Boolean)             value)                  as object;
          if (typeof(T) == typeof(double))                            return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.DoubleField    (position,                              (System.Double)              value)                  as object;
          if (typeof(T) == typeof(float))                             return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.FloatField     (position,                              (System.Single)              value)                  as object;
          if (typeof(T) == typeof(int))                               return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.IntField       (position,                              (System.Int32)               value)                  as object;
          if (typeof(T) == typeof(long))                              return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.LongField      (position,                              (System.Int64)               value)                  as object;
          if (typeof(T) == typeof(string))                            return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.TextField      (position,                              (System.String)              value)                  as object;
          if (typeof(T) == typeof(UnityEngine.AnimationCurve))        return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.CurveField     (position,                              (UnityEngine.AnimationCurve) value)                  as object;
          if (typeof(T) == typeof(UnityEngine.Bounds))                return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.BoundsField    (position,                              (UnityEngine.Bounds)         value)                  as object;
          if (typeof(T) == typeof(UnityEngine.BoundsInt))             return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.BoundsIntField (position,                              (UnityEngine.BoundsInt)      value)                  as object;
          if (typeof(T) == typeof(UnityEngine.Color))                 return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.ColorField     (position,                              (UnityEngine.Color)          value)                  as object;
          if (typeof(T) == typeof(UnityEngine.Gradient))              return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.GradientField  (position,                              (UnityEngine.Gradient)       value)                  as object;
          if (typeof(T) == typeof(UnityEngine.Rect))                  return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.RectField      (position,                              (UnityEngine.Rect)           value)                  as object;
          if (typeof(T) == typeof(UnityEngine.RectInt))               return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.RectIntField   (position,                              (UnityEngine.RectInt)        value)                  as object;
          if (typeof(T) == typeof(UnityEngine.Vector2))               return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.Vector2Field   (position, UnityEngine.GUIContent.none, (UnityEngine.Vector2)        value)                  as object;
          if (typeof(T) == typeof(UnityEngine.Vector2Int))            return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.Vector2IntField(position, UnityEngine.GUIContent.none, (UnityEngine.Vector2Int)     value)                  as object;
          if (typeof(T) == typeof(UnityEngine.Vector3))               return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.Vector3Field   (position, UnityEngine.GUIContent.none, (UnityEngine.Vector3)        value)                  as object;
          if (typeof(T) == typeof(UnityEngine.Vector3Int))            return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.Vector3IntField(position, UnityEngine.GUIContent.none, (UnityEngine.Vector3Int)     value)                  as object;
          if (typeof(T) == typeof(UnityEngine.Vector4))               return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.Vector4Field   (position, UnityEngine.GUIContent.none, (UnityEngine.Vector4)        value)                  as object;
          if (typeof(T).IsEnum)                                       return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.EnumPopup      (position,                              (System.Enum)                value)                  as object;
          if (typeof(UnityEngine.Object).IsAssignableFrom(typeof(T))) return [GameMethod(AggressiveInlining)] static (in UnityEngine.Rect position, object value) => UnityEditor.EditorGUI.ObjectField    (position,                              (UnityEngine.Object)         value, typeof(T), true) as object;

          return null;
        }
      #endif
    }

    public static class Vector {
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Clamp              (in UnityEngine.Vector2    vector,  in UnityEngine.Vector2    minimum, in UnityEngine.Vector2    maximum) => new(System.Math.Clamp(vector.x, minimum.x, maximum.x), System.Math.Clamp(vector.y, minimum.y, maximum.y));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               Clamp              (in UnityEngine.Vector2Int vector,  in UnityEngine.Vector2Int minimum, in UnityEngine.Vector2Int maximum) => new(System.Math.Clamp(vector.x, minimum.x, maximum.x), System.Math.Clamp(vector.y, minimum.y, maximum.y));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Clamp              (in UnityEngine.Vector3    vector,  in UnityEngine.Vector3    minimum, in UnityEngine.Vector3    maximum) => new(System.Math.Clamp(vector.x, minimum.x, maximum.x), System.Math.Clamp(vector.y, minimum.y, maximum.y), System.Math.Clamp(vector.z, minimum.z, maximum.z));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Clamp              (in UnityEngine.Vector3Int vector,  in UnityEngine.Vector3Int minimum, in UnityEngine.Vector3Int maximum) => new(System.Math.Clamp(vector.x, minimum.x, maximum.x), System.Math.Clamp(vector.y, minimum.y, maximum.y), System.Math.Clamp(vector.z, minimum.z, maximum.z));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Clamp              (in UnityEngine.Vector4    vector,  in UnityEngine.Vector4    minimum, in UnityEngine.Vector4    maximum) => new(System.Math.Clamp(vector.x, minimum.x, maximum.x), System.Math.Clamp(vector.y, minimum.y, maximum.y), System.Math.Clamp(vector.z, minimum.z, maximum.z), System.Math.Clamp(vector.w, minimum.w, maximum.w));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly UnityEngine.Vector2                  Coalesce           (in UnityEngine.Vector2    vectorA, in UnityEngine.Vector2    vectorB)                                    => ref (UnityEngine.Vector2   .zero != vectorA ? ref vectorA : ref vectorB);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly UnityEngine.Vector2Int               Coalesce           (in UnityEngine.Vector2Int vectorA, in UnityEngine.Vector2Int vectorB)                                    => ref (UnityEngine.Vector2Int.zero != vectorA ? ref vectorA : ref vectorB);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly UnityEngine.Vector3                  Coalesce           (in UnityEngine.Vector3    vectorA, in UnityEngine.Vector3    vectorB)                                    => ref (UnityEngine.Vector3   .zero != vectorA ? ref vectorA : ref vectorB);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly UnityEngine.Vector3Int               Coalesce           (in UnityEngine.Vector3Int vectorA, in UnityEngine.Vector3Int vectorB)                                    => ref (UnityEngine.Vector3Int.zero != vectorA ? ref vectorA : ref vectorB);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly UnityEngine.Vector4                  Coalesce           (in UnityEngine.Vector4    vectorA, in UnityEngine.Vector4    vectorB)                                    => ref (UnityEngine.Vector4   .zero != vectorA ? ref vectorA : ref vectorB);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                Distance           (in UnityEngine.Vector2    vectorA, in UnityEngine.Vector2    vectorB)                                    =>       UnityEngine.Vector2   .Distance(vectorA, vectorB);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  Distance           (in UnityEngine.Vector2Int vectorA, in UnityEngine.Vector2Int vectorB)                                    => (int) UnityEngine.Vector2Int.Distance(vectorA, vectorB);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                Distance           (in UnityEngine.Vector3    vectorA, in UnityEngine.Vector3    vectorB)                                    =>       UnityEngine.Vector3   .Distance(vectorA, vectorB);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  Distance           (in UnityEngine.Vector3Int vectorA, in UnityEngine.Vector3Int vectorB)                                    => (int) UnityEngine.Vector3Int.Distance(vectorA, vectorB);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                Distance           (in UnityEngine.Vector4    vectorA, in UnityEngine.Vector4    vectorB)                                    =>       UnityEngine.Vector4   .Distance(vectorA, vectorB);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                DistanceSquared    (in UnityEngine.Vector2    vectorA, in UnityEngine.Vector2    vectorB)                                    => (vectorA - vectorB).sqrMagnitude;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  DistanceSquared    (in UnityEngine.Vector2Int vectorA, in UnityEngine.Vector2Int vectorB)                                    => (vectorA - vectorB).sqrMagnitude;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                DistanceSquared    (in UnityEngine.Vector3    vectorA, in UnityEngine.Vector3    vectorB)                                    => (vectorA - vectorB).sqrMagnitude;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  DistanceSquared    (in UnityEngine.Vector3Int vectorA, in UnityEngine.Vector3Int vectorB)                                    => (vectorA - vectorB).sqrMagnitude;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                DistanceSquared    (in UnityEngine.Vector4    vectorA, in UnityEngine.Vector4    vectorB)                                    => (vectorA - vectorB).sqrMagnitude;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly T                                    Epsilon<T>         () where T : struct                                                                                       => ref Util.Vector<T>.Epsilon;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Exclude            (in UnityEngine.Vector2    vector, uint                                    index, float value = 0.0f)     { switch (index) { case 0u: return Vector.Exclude(in vector, new Game.Collections.Vector2Bool(true, false),               value); case 1u: return Vector.Exclude(in vector, new Game.Collections.Vector2Bool(false, true),               value); }                                                                                                                                                                                                                                               throw new System.IndexOutOfRangeException("Invalid `Vector2` index!"); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               Exclude            (in UnityEngine.Vector2Int vector, uint                                    index, int   value = 0)        { switch (index) { case 0u: return Vector.Exclude(in vector, new Game.Collections.Vector2Bool(true, false),               value); case 1u: return Vector.Exclude(in vector, new Game.Collections.Vector2Bool(false, true),               value); }                                                                                                                                                                                                                                               throw new System.IndexOutOfRangeException("Invalid `Vector2Int` index!"); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Exclude            (in UnityEngine.Vector3    vector, uint                                    index, float value = 0.0f)     { switch (index) { case 0u: return Vector.Exclude(in vector, new Game.Collections.Vector3Bool(true, false, false),        value); case 1u: return Vector.Exclude(in vector, new Game.Collections.Vector3Bool(false, true, false),        value); case 2u: return Vector.Exclude(in vector, new Game.Collections.Vector3Bool(false, false, true),        value); }                                                                                                                        throw new System.IndexOutOfRangeException("Invalid `Vector3` index!"); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Exclude            (in UnityEngine.Vector3Int vector, uint                                    index, int   value = 0)        { switch (index) { case 0u: return Vector.Exclude(in vector, new Game.Collections.Vector3Bool(true, false, false),        value); case 1u: return Vector.Exclude(in vector, new Game.Collections.Vector3Bool(false, true, false),        value); case 2u: return Vector.Exclude(in vector, new Game.Collections.Vector3Bool(false, false, true),        value); }                                                                                                                        throw new System.IndexOutOfRangeException("Invalid `Vector3Int` index!"); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Exclude            (in UnityEngine.Vector4    vector, uint                                    index, float value = 0.0f)     { switch (index) { case 0u: return Vector.Exclude(in vector, new Game.Collections.Vector4Bool(true, false, false, false), value); case 1u: return Vector.Exclude(in vector, new Game.Collections.Vector4Bool(false, true, false, false), value); case 2u: return Vector.Exclude(in vector, new Game.Collections.Vector4Bool(false, false, true, false), value); case 3u: return Vector.Exclude(in vector, new Game.Collections.Vector4Bool(false, false, false, true), value); } throw new System.IndexOutOfRangeException("Invalid `Vector4` index!"); }
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              UnityEngine.Vector2                  Exclude            (in UnityEngine.Vector2    vector, in Game.Collections.Vector2Bool axes,  float value = 0.0f)     => new(axes.x ? value : vector.x, axes.y ? value : vector.y);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Exclude            (in UnityEngine.Vector2    vector, in Game.Collections.Vector3Bool axes,  float value = 0.0f)     => Vector.Exclude(in vector, (Game.Collections.Vector2Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Exclude            (in UnityEngine.Vector2    vector, in Game.Collections.Vector4Bool axes,  float value = 0.0f)     => Vector.Exclude(in vector, (Game.Collections.Vector2Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Exclude            (in UnityEngine.Vector2    vector, in UnityEngine.Vector2                  axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector2Bool(axes.x == 1.0f, axes.y == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Exclude            (in UnityEngine.Vector2    vector, in UnityEngine.Vector2Int               axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector2Bool(axes.x == 1,    axes.y == 1),    value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Exclude            (in UnityEngine.Vector2    vector, in UnityEngine.Vector3                  axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector2Bool(axes.x == 1.0f, axes.y == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Exclude            (in UnityEngine.Vector2    vector, in UnityEngine.Vector3Int               axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector2Bool(axes.x == 1,    axes.y == 1),    value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Exclude            (in UnityEngine.Vector2    vector, in UnityEngine.Vector4                  axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector2Bool(axes.x == 1.0f, axes.y == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              UnityEngine.Vector2Int               Exclude            (in UnityEngine.Vector2Int vector, in Game.Collections.Vector2Bool axes,  int   value = 0)        => new(axes.x ? value : vector.x, axes.y ? value : vector.y);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               Exclude            (in UnityEngine.Vector2Int vector, in Game.Collections.Vector3Bool axes,  int   value = 0)        => Vector.Exclude(in vector, (Game.Collections.Vector2Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               Exclude            (in UnityEngine.Vector2Int vector, in Game.Collections.Vector4Bool axes,  int   value = 0)        => Vector.Exclude(in vector, (Game.Collections.Vector2Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Exclude            (in UnityEngine.Vector2Int vector, in UnityEngine.Vector2                  axes,  int   value = 0)        => Vector.Exclude(in vector, new Game.Collections.Vector2Bool(axes.x == 1.0f, axes.y == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Exclude            (in UnityEngine.Vector2Int vector, in UnityEngine.Vector2Int               axes,  int   value = 0)        => Vector.Exclude(in vector, new Game.Collections.Vector2Bool(axes.x == 1,    axes.y == 1),    value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Exclude            (in UnityEngine.Vector2Int vector, in UnityEngine.Vector3                  axes,  int   value = 0)        => Vector.Exclude(in vector, new Game.Collections.Vector2Bool(axes.x == 1.0f, axes.y == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Exclude            (in UnityEngine.Vector2Int vector, in UnityEngine.Vector3Int               axes,  int   value = 0)        => Vector.Exclude(in vector, new Game.Collections.Vector2Bool(axes.x == 1,    axes.y == 1),    value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Exclude            (in UnityEngine.Vector2Int vector, in UnityEngine.Vector4                  axes,  int   value = 0)        => Vector.Exclude(in vector, new Game.Collections.Vector2Bool(axes.x == 1.0f, axes.y == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Exclude            (in UnityEngine.Vector3    vector, in Game.Collections.Vector2Bool axes,  float value = 0.0f)     => Vector.Exclude(in vector, (Game.Collections.Vector3Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              UnityEngine.Vector3                  Exclude            (in UnityEngine.Vector3    vector, in Game.Collections.Vector3Bool axes,  float value = 0.0f)     => new(axes.x ? value : vector.x, axes.y ? value : vector.y, axes.z ? value : vector.z);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Exclude            (in UnityEngine.Vector3    vector, in Game.Collections.Vector4Bool axes,  float value = 0.0f)     => Vector.Exclude(in vector, (Game.Collections.Vector3Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Exclude            (in UnityEngine.Vector3    vector, in UnityEngine.Vector2                  axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector3Bool(axes.x == 1.0f, axes.y == 1.0f, true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Exclude            (in UnityEngine.Vector3    vector, in UnityEngine.Vector2Int               axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector3Bool(axes.x == 1,    axes.y == 1,    true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Exclude            (in UnityEngine.Vector3    vector, in UnityEngine.Vector3                  axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector3Bool(axes.x == 1.0f, axes.y == 1.0f, axes.z == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Exclude            (in UnityEngine.Vector3    vector, in UnityEngine.Vector3Int               axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector3Bool(axes.x == 1,    axes.y == 1,    axes.z == 1),    value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Exclude            (in UnityEngine.Vector3    vector, in UnityEngine.Vector4                  axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector3Bool(axes.x == 1.0f, axes.y == 1.0f, axes.z == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Exclude            (in UnityEngine.Vector3Int vector, in Game.Collections.Vector2Bool axes,  int   value = 0)        => Vector.Exclude(in vector, (Game.Collections.Vector3Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              UnityEngine.Vector3Int               Exclude            (in UnityEngine.Vector3Int vector, in Game.Collections.Vector3Bool axes,  int   value = 0)        => new(axes.x ? value : vector.x, axes.y ? value : vector.y, axes.z ? value : vector.z);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Exclude            (in UnityEngine.Vector3Int vector, in Game.Collections.Vector4Bool axes,  int   value = 0)        => Vector.Exclude(in vector, (Game.Collections.Vector3Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Exclude            (in UnityEngine.Vector3Int vector, in UnityEngine.Vector2                  axes,  int   value = 0)        => Vector.Exclude(in vector, new Game.Collections.Vector3Bool(axes.x == 1.0f, axes.y == 1.0f, true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Exclude            (in UnityEngine.Vector3Int vector, in UnityEngine.Vector2Int               axes,  int   value = 0)        => Vector.Exclude(in vector, new Game.Collections.Vector3Bool(axes.x == 1,    axes.y == 1,    true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Exclude            (in UnityEngine.Vector3Int vector, in UnityEngine.Vector3                  axes,  int   value = 0)        => Vector.Exclude(in vector, new Game.Collections.Vector3Bool(axes.x == 1.0f, axes.y == 1.0f, axes.z == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Exclude            (in UnityEngine.Vector3Int vector, in UnityEngine.Vector3Int               axes,  int   value = 0)        => Vector.Exclude(in vector, new Game.Collections.Vector3Bool(axes.x == 1,    axes.y == 1,    axes.z == 1),    value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Exclude            (in UnityEngine.Vector3Int vector, in UnityEngine.Vector4                  axes,  int   value = 0)        => Vector.Exclude(in vector, new Game.Collections.Vector3Bool(axes.x == 1.0f, axes.y == 1.0f, axes.z == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Exclude            (in UnityEngine.Vector4    vector, in Game.Collections.Vector2Bool axes,  float value = 0.0f)     => Vector.Exclude(in vector, (Game.Collections.Vector4Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Exclude            (in UnityEngine.Vector4    vector, in Game.Collections.Vector3Bool axes,  float value = 0.0f)     => Vector.Exclude(in vector, (Game.Collections.Vector4Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              UnityEngine.Vector4                  Exclude            (in UnityEngine.Vector4    vector, in Game.Collections.Vector4Bool axes,  float value = 0.0f)     => new(axes.x ? value : vector.x, axes.y ? value : vector.y, axes.z ? value : vector.z, axes.w ? value : vector.w);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Exclude            (in UnityEngine.Vector4    vector, in UnityEngine.Vector2                  axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector4Bool(axes.x == 1.0f, axes.y == 1.0f, true,           true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Exclude            (in UnityEngine.Vector4    vector, in UnityEngine.Vector2Int               axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector4Bool(axes.x == 1,    axes.y == 1,    true,           true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Exclude            (in UnityEngine.Vector4    vector, in UnityEngine.Vector3                  axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector4Bool(axes.x == 1.0f, axes.y == 1.0f, axes.z == 1.0f, true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Exclude            (in UnityEngine.Vector4    vector, in UnityEngine.Vector3Int               axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector4Bool(axes.x == 1,    axes.y == 1,    axes.z == 1,    true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Exclude            (in UnityEngine.Vector4    vector, in UnityEngine.Vector4                  axes,  float value = 0.0f)     => Vector.Exclude(in vector, new Game.Collections.Vector4Bool(axes.x == 1.0f, axes.y == 1.0f, axes.z == 1.0f, axes.w == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  ExcludeBack        (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, in Game.Collections.Vector3Bool.back,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               ExcludeBack        (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, in Game.Collections.Vector3Bool.back,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  ExcludeDown        (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, in Game.Collections.Vector2Bool.down,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               ExcludeDown        (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, in Game.Collections.Vector2Bool.down,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  ExcludeDown        (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, in Game.Collections.Vector3Bool.down,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               ExcludeDown        (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, in Game.Collections.Vector3Bool.down,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  ExcludeForward     (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, in Game.Collections.Vector3Bool.forward,                      value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               ExcludeForward     (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, in Game.Collections.Vector3Bool.forward,                      value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  ExcludeLeft        (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, in Game.Collections.Vector2Bool.left,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               ExcludeLeft        (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, in Game.Collections.Vector2Bool.left,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  ExcludeLeft        (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, in Game.Collections.Vector3Bool.left,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               ExcludeLeft        (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, in Game.Collections.Vector3Bool.left,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  ExcludeRight       (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, in Game.Collections.Vector2Bool.right,                        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               ExcludeRight       (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, in Game.Collections.Vector2Bool.right,                        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  ExcludeRight       (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, in Game.Collections.Vector3Bool.right,                        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               ExcludeRight       (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, in Game.Collections.Vector3Bool.right,                        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  ExcludeUp          (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, in Game.Collections.Vector2Bool.up,                           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               ExcludeUp          (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, in Game.Collections.Vector2Bool.up,                           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  ExcludeUp          (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, in Game.Collections.Vector3Bool.up,                           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               ExcludeUp          (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, in Game.Collections.Vector3Bool.up,                           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  ExcludeDepth       (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.ExcludeForward(in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               ExcludeDepth       (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.ExcludeForward(in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  ExcludeHeight      (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.ExcludeUp     (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               ExcludeHeight      (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.ExcludeUp     (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  ExcludeHeight      (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.ExcludeUp     (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               ExcludeHeight      (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.ExcludeUp     (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  ExcludeWidth       (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.ExcludeRight  (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               ExcludeWidth       (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.ExcludeRight  (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  ExcludeWidth       (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.ExcludeRight  (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               ExcludeWidth       (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.ExcludeRight  (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  ExcludeX           (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, new Game.Collections.Vector2Bool(true,  false),               value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               ExcludeX           (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, new Game.Collections.Vector2Bool(true,  false),               value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  ExcludeX           (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, new Game.Collections.Vector3Bool(true,  false, false),        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               ExcludeX           (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, new Game.Collections.Vector3Bool(true,  false, false),        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  ExcludeX           (in UnityEngine.Vector4    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, new Game.Collections.Vector4Bool(true,  false, false, false), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  ExcludeY           (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, new Game.Collections.Vector2Bool(false, true),                value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               ExcludeY           (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, new Game.Collections.Vector2Bool(false, true),                value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  ExcludeY           (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, new Game.Collections.Vector3Bool(false, true,  false),        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               ExcludeY           (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, new Game.Collections.Vector3Bool(false, true,  false),        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  ExcludeY           (in UnityEngine.Vector4    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, new Game.Collections.Vector4Bool(false, true,  false, false), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  ExcludeZ           (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, new Game.Collections.Vector3Bool(false, false, true),         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               ExcludeZ           (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Exclude       (in vector, new Game.Collections.Vector3Bool(false, false, true),         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  ExcludeZ           (in UnityEngine.Vector4    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, new Game.Collections.Vector4Bool(false, false, true, false),  value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  ExcludeW           (in UnityEngine.Vector4    vector,                                                float value = 0.0f)     => Vector.Exclude       (in vector, new Game.Collections.Vector4Bool(false, false, false, true),  value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector2    vector, uint                                    index)                         => index < 2u ? vector[(int) index] : float.NaN;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetAxis            (in UnityEngine.Vector2Int vector, uint                                    index)                         => index < 2u ? vector[(int) index] : int  .MinValue;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector3    vector, uint                                    index)                         => index < 3u ? vector[(int) index] : float.NaN;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetAxis            (in UnityEngine.Vector3Int vector, uint                                    index)                         => index < 3u ? vector[(int) index] : int  .MinValue;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector4    vector, uint                                    index)                         => index < 4u ? vector[(int) index] : float.NaN;
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              float                                GetAxis            (in UnityEngine.Vector2    vector, in Game.Collections.Vector2Bool axes)                          => axes.x ? vector.x : axes.y ? vector.y : float.NaN;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector2    vector, in Game.Collections.Vector3Bool axes)                          => Vector.GetAxis(in vector, (Game.Collections.Vector2Bool) axes);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector2    vector, in Game.Collections.Vector4Bool axes)                          => Vector.GetAxis(in vector, (Game.Collections.Vector2Bool) axes);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector2    vector, in UnityEngine.Vector2                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector2Bool(0.0f != axes.x, 0.0f != axes.y));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector2    vector, in UnityEngine.Vector2Int               axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector2Bool(0    != axes.x, 0    != axes.y));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector2    vector, in UnityEngine.Vector3                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector2Bool(0.0f != axes.x, 0.0f != axes.y));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector2    vector, in UnityEngine.Vector3Int               axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector2Bool(0    != axes.x, 0    != axes.y));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector2    vector, in UnityEngine.Vector4                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector2Bool(0.0f != axes.x, 0.0f != axes.y));
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              int                                  GetAxis            (in UnityEngine.Vector2Int vector, in Game.Collections.Vector2Bool axes)                          => axes.x ? vector.x : axes.y ? vector.y : int.MinValue;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetAxis            (in UnityEngine.Vector2Int vector, in Game.Collections.Vector3Bool axes)                          => Vector.GetAxis(in vector, (Game.Collections.Vector2Bool) axes);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetAxis            (in UnityEngine.Vector2Int vector, in Game.Collections.Vector4Bool axes)                          => Vector.GetAxis(in vector, (Game.Collections.Vector2Bool) axes);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector2Int vector, in UnityEngine.Vector2                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector2Bool(0.0f != axes.x, 0.0f != axes.y));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector2Int vector, in UnityEngine.Vector2Int               axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector2Bool(0    != axes.x, 0    != axes.y));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector2Int vector, in UnityEngine.Vector3                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector2Bool(0.0f != axes.x, 0.0f != axes.y));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector2Int vector, in UnityEngine.Vector3Int               axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector2Bool(0    != axes.x, 0    != axes.y));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector2Int vector, in UnityEngine.Vector4                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector2Bool(0.0f != axes.x, 0.0f != axes.y));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector3    vector, in Game.Collections.Vector2Bool axes)                          => Vector.GetAxis(in vector, (Game.Collections.Vector3Bool) axes);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              float                                GetAxis            (in UnityEngine.Vector3    vector, in Game.Collections.Vector3Bool axes)                          => axes.x ? vector.x : axes.y ? vector.y : axes.z ? vector.z : float.NaN;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector3    vector, in Game.Collections.Vector4Bool axes)                          => Vector.GetAxis(in vector, (Game.Collections.Vector3Bool) axes);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector3    vector, in UnityEngine.Vector2                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector3Bool(0.0f != axes.x, 0.0f != axes.y, true));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector3    vector, in UnityEngine.Vector2Int               axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector3Bool(0    != axes.x, 0    != axes.y, true));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector3    vector, in UnityEngine.Vector3                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector3Bool(0.0f != axes.x, 0.0f != axes.y, 0.0f != axes.z));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector3    vector, in UnityEngine.Vector3Int               axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector3Bool(0    != axes.x, 0    != axes.y, 0    != axes.z));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector3    vector, in UnityEngine.Vector4                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector3Bool(0.0f != axes.x, 0.0f != axes.y, 0.0f != axes.z));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetAxis            (in UnityEngine.Vector3Int vector, in Game.Collections.Vector2Bool axes)                          => Vector.GetAxis(in vector, (Game.Collections.Vector3Bool) axes);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              int                                  GetAxis            (in UnityEngine.Vector3Int vector, in Game.Collections.Vector3Bool axes)                          => axes.x ? vector.x : axes.y ? vector.y : axes.z ? vector.z : int.MinValue;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetAxis            (in UnityEngine.Vector3Int vector, in Game.Collections.Vector4Bool axes)                          => Vector.GetAxis(in vector, (Game.Collections.Vector3Bool) axes);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetAxis            (in UnityEngine.Vector3Int vector, in UnityEngine.Vector2                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector3Bool(0.0f != axes.x, 0.0f != axes.y, true));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetAxis            (in UnityEngine.Vector3Int vector, in UnityEngine.Vector2Int               axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector3Bool(0    != axes.x, 0    != axes.y, true));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetAxis            (in UnityEngine.Vector3Int vector, in UnityEngine.Vector3                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector3Bool(0.0f != axes.x, 0.0f != axes.y, 0.0f != axes.z));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetAxis            (in UnityEngine.Vector3Int vector, in UnityEngine.Vector3Int               axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector3Bool(0    != axes.x, 0    != axes.y, 0    != axes.z));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetAxis            (in UnityEngine.Vector3Int vector, in UnityEngine.Vector4                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector3Bool(0.0f != axes.x, 0.0f != axes.y, 0.0f != axes.z));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector4    vector, in Game.Collections.Vector2Bool axes)                          => Vector.GetAxis(in vector, (Game.Collections.Vector4Bool) axes);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector4    vector, in Game.Collections.Vector3Bool axes)                          => Vector.GetAxis(in vector, (Game.Collections.Vector4Bool) axes);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              float                                GetAxis            (in UnityEngine.Vector4    vector, in Game.Collections.Vector4Bool axes)                          => axes.x ? vector.x : axes.y ? vector.y : axes.z ? vector.z : axes.w ? vector.w : float.NaN;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector4    vector, in UnityEngine.Vector2                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector4Bool(0.0f != axes.x, 0.0f != axes.y, true,           true));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector4    vector, in UnityEngine.Vector2Int               axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector4Bool(0    != axes.x, 0    != axes.y, true,           true));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector4    vector, in UnityEngine.Vector3                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector4Bool(0.0f != axes.x, 0.0f != axes.y, 0.0f != axes.z, true));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector4    vector, in UnityEngine.Vector3Int               axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector4Bool(0    != axes.x, 0    != axes.y, 0    != axes.z, true));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetAxis            (in UnityEngine.Vector4    vector, in UnityEngine.Vector4                  axes)                          => Vector.GetAxis(in vector, new Game.Collections.Vector4Bool(0.0f != axes.x, 0.0f != axes.y, 0.0f != axes.z, 0.0f != axes.w));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetBackAxis        (in UnityEngine.Vector3    vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector3Bool.back);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetBackAxis        (in UnityEngine.Vector3Int vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector3Bool.back);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetDownAxis        (in UnityEngine.Vector2    vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector2Bool.down);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetDownAxis        (in UnityEngine.Vector2Int vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector2Bool.down);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetDownAxis        (in UnityEngine.Vector3    vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector3Bool.down);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetDownAxis        (in UnityEngine.Vector3Int vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector3Bool.down);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetForwardAxis     (in UnityEngine.Vector3    vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector3Bool.forward);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetForwardAxis     (in UnityEngine.Vector3Int vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector3Bool.forward);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetLeftAxis        (in UnityEngine.Vector2    vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector2Bool.left);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetLeftAxis        (in UnityEngine.Vector2Int vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector2Bool.left);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetLeftAxis        (in UnityEngine.Vector3    vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector3Bool.left);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetLeftAxis        (in UnityEngine.Vector3Int vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector3Bool.left);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetRightAxis       (in UnityEngine.Vector2    vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector2Bool.right);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetRightAxis       (in UnityEngine.Vector2Int vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector2Bool.right);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetRightAxis       (in UnityEngine.Vector3    vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector3Bool.right);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetRightAxis       (in UnityEngine.Vector3Int vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector3Bool.right);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetUpAxis          (in UnityEngine.Vector2    vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector2Bool.up);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetUpAxis          (in UnityEngine.Vector2Int vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector2Bool.up);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetUpAxis          (in UnityEngine.Vector3    vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector3Bool.up);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetUpAxis          (in UnityEngine.Vector3Int vector)                                                                        => Vector.GetAxis       (in vector, in Game.Collections.Vector3Bool.up);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetDepthAxis       (in UnityEngine.Vector3    vector)                                                                        => Vector.GetForwardAxis(in vector);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetDepthAxis       (in UnityEngine.Vector3Int vector)                                                                        => Vector.GetForwardAxis(in vector);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetHeightAxis      (in UnityEngine.Vector2    vector)                                                                        => Vector.GetUpAxis     (in vector);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetHeightAxis      (in UnityEngine.Vector2Int vector)                                                                        => Vector.GetUpAxis     (in vector);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetHeightAxis      (in UnityEngine.Vector3    vector)                                                                        => Vector.GetUpAxis     (in vector);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetHeightAxis      (in UnityEngine.Vector3Int vector)                                                                        => Vector.GetUpAxis     (in vector);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetWidthAxis       (in UnityEngine.Vector2    vector)                                                                        => Vector.GetRightAxis  (in vector);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetWidthAxis       (in UnityEngine.Vector2Int vector)                                                                        => Vector.GetRightAxis  (in vector);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetWidthAxis       (in UnityEngine.Vector3    vector)                                                                        => Vector.GetRightAxis  (in vector);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetWidthAxis       (in UnityEngine.Vector3Int vector)                                                                        => Vector.GetRightAxis  (in vector);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetXAxis           (in UnityEngine.Vector2    vector)                                                                        => Vector.GetAxis       (in vector, new Game.Collections.Vector2Bool(true,  false));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetXAxis           (in UnityEngine.Vector2Int vector)                                                                        => Vector.GetAxis       (in vector, new Game.Collections.Vector2Bool(true,  false));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetXAxis           (in UnityEngine.Vector3    vector)                                                                        => Vector.GetAxis       (in vector, new Game.Collections.Vector3Bool(true,  false, false));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetXAxis           (in UnityEngine.Vector3Int vector)                                                                        => Vector.GetAxis       (in vector, new Game.Collections.Vector3Bool(true,  false, false));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetXAxis           (in UnityEngine.Vector4    vector)                                                                        => Vector.GetAxis       (in vector, new Game.Collections.Vector4Bool(true,  false, false, false));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetYAxis           (in UnityEngine.Vector2    vector)                                                                        => Vector.GetAxis       (in vector, new Game.Collections.Vector2Bool(false, true));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetYAxis           (in UnityEngine.Vector2Int vector)                                                                        => Vector.GetAxis       (in vector, new Game.Collections.Vector2Bool(false, true));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetYAxis           (in UnityEngine.Vector3    vector)                                                                        => Vector.GetAxis       (in vector, new Game.Collections.Vector3Bool(false, true,  false));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetYAxis           (in UnityEngine.Vector3Int vector)                                                                        => Vector.GetAxis       (in vector, new Game.Collections.Vector3Bool(false, true,  false));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetYAxis           (in UnityEngine.Vector4    vector)                                                                        => Vector.GetAxis       (in vector, new Game.Collections.Vector4Bool(false, true,  false, false));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetZAxis           (in UnityEngine.Vector3    vector)                                                                        => Vector.GetAxis       (in vector, new Game.Collections.Vector3Bool(false, false, true));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              int                                  GetZAxis           (in UnityEngine.Vector3Int vector)                                                                        => Vector.GetAxis       (in vector, new Game.Collections.Vector3Bool(false, false, true));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetZAxis           (in UnityEngine.Vector4    vector)                                                                        => Vector.GetAxis       (in vector, new Game.Collections.Vector4Bool(false, false, true, false));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              float                                GetWAxis           (in UnityEngine.Vector4    vector)                                                                        => Vector.GetAxis       (in vector, new Game.Collections.Vector4Bool(false, false, false, true));
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly T                                    Half            <T>() where T : struct                                                                                       => ref Util.Vector<T>.Half;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Mask               (in UnityEngine.Vector2    vector, uint                                    index, float value = 0.0f)     { switch (index) { case 0u: return Vector.Mask(in vector, new Game.Collections.Vector2Bool(true, false),               value); case 1u: return Vector.Mask(in vector, new Game.Collections.Vector2Bool(false, true),               value); }                                                                                                                                                                                                                                         throw new System.IndexOutOfRangeException("Invalid `Vector2` index!"); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               Mask               (in UnityEngine.Vector2Int vector, uint                                    index, int   value = 0)        { switch (index) { case 0u: return Vector.Mask(in vector, new Game.Collections.Vector2Bool(true, false),               value); case 1u: return Vector.Mask(in vector, new Game.Collections.Vector2Bool(false, true),               value); }                                                                                                                                                                                                                                         throw new System.IndexOutOfRangeException("Invalid `Vector2Int` index!"); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Mask               (in UnityEngine.Vector3    vector, uint                                    index, float value = 0.0f)     { switch (index) { case 0u: return Vector.Mask(in vector, new Game.Collections.Vector3Bool(true, false, false),        value); case 1u: return Vector.Mask(in vector, new Game.Collections.Vector3Bool(false, true, false),        value); case 2u: return Vector.Mask(in vector, new Game.Collections.Vector3Bool(false, false, true),        value); }                                                                                                                     throw new System.IndexOutOfRangeException("Invalid `Vector3` index!"); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Mask               (in UnityEngine.Vector3Int vector, uint                                    index, int   value = 0)        { switch (index) { case 0u: return Vector.Mask(in vector, new Game.Collections.Vector3Bool(true, false, false),        value); case 1u: return Vector.Mask(in vector, new Game.Collections.Vector3Bool(false, true, false),        value); case 2u: return Vector.Mask(in vector, new Game.Collections.Vector3Bool(false, false, true),        value); }                                                                                                                     throw new System.IndexOutOfRangeException("Invalid `Vector3Int` index!"); }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Mask               (in UnityEngine.Vector4    vector, uint                                    index, float value = 0.0f)     { switch (index) { case 0u: return Vector.Mask(in vector, new Game.Collections.Vector4Bool(true, false, false, false), value); case 1u: return Vector.Mask(in vector, new Game.Collections.Vector4Bool(false, true, false, false), value); case 2u: return Vector.Mask(in vector, new Game.Collections.Vector4Bool(false, false, true, false), value); case 3u: return Vector.Mask(in vector, new Game.Collections.Vector4Bool(false, false, false, true), value); } throw new System.IndexOutOfRangeException("Invalid `Vector4` index!"); }
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              UnityEngine.Vector2                  Mask               (in UnityEngine.Vector2    vector, in Game.Collections.Vector2Bool axes,  float value = 0.0f)     => new(axes.x ? vector.x : value, axes.y ? vector.y : value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Mask               (in UnityEngine.Vector2    vector, in Game.Collections.Vector3Bool axes,  float value = 0.0f)     => Vector.Mask(in vector, (Game.Collections.Vector2Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Mask               (in UnityEngine.Vector2    vector, in Game.Collections.Vector4Bool axes,  float value = 0.0f)     => Vector.Mask(in vector, (Game.Collections.Vector2Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Mask               (in UnityEngine.Vector2    vector, in UnityEngine.Vector2                  axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector2Bool(axes.x == 1.0f, axes.y == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Mask               (in UnityEngine.Vector2    vector, in UnityEngine.Vector2Int               axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector2Bool(axes.x == 1,    axes.y == 1),    value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Mask               (in UnityEngine.Vector2    vector, in UnityEngine.Vector3                  axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector2Bool(axes.x == 1.0f, axes.y == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Mask               (in UnityEngine.Vector2    vector, in UnityEngine.Vector3Int               axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector2Bool(axes.x == 1,    axes.y == 1),    value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Mask               (in UnityEngine.Vector2    vector, in UnityEngine.Vector4                  axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector2Bool(axes.x == 1.0f, axes.y == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              UnityEngine.Vector2Int               Mask               (in UnityEngine.Vector2Int vector, in Game.Collections.Vector2Bool axes,  int   value = 0)        => new(axes.x ? vector.x : value, axes.y ? vector.y : value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               Mask               (in UnityEngine.Vector2Int vector, in Game.Collections.Vector3Bool axes,  int   value = 0)        => Vector.Mask(in vector, (Game.Collections.Vector2Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               Mask               (in UnityEngine.Vector2Int vector, in Game.Collections.Vector4Bool axes,  int   value = 0)        => Vector.Mask(in vector, (Game.Collections.Vector2Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Mask               (in UnityEngine.Vector2Int vector, in UnityEngine.Vector2                  axes,  int   value = 0)        => Vector.Mask(in vector, new Game.Collections.Vector2Bool(axes.x == 1.0f, axes.y == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Mask               (in UnityEngine.Vector2Int vector, in UnityEngine.Vector2Int               axes,  int   value = 0)        => Vector.Mask(in vector, new Game.Collections.Vector2Bool(axes.x == 1,    axes.y == 1),    value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Mask               (in UnityEngine.Vector2Int vector, in UnityEngine.Vector3                  axes,  int   value = 0)        => Vector.Mask(in vector, new Game.Collections.Vector2Bool(axes.x == 1.0f, axes.y == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Mask               (in UnityEngine.Vector2Int vector, in UnityEngine.Vector3Int               axes,  int   value = 0)        => Vector.Mask(in vector, new Game.Collections.Vector2Bool(axes.x == 1,    axes.y == 1),    value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  Mask               (in UnityEngine.Vector2Int vector, in UnityEngine.Vector4                  axes,  int   value = 0)        => Vector.Mask(in vector, new Game.Collections.Vector2Bool(axes.x == 1.0f, axes.y == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Mask               (in UnityEngine.Vector3    vector, in Game.Collections.Vector2Bool axes,  float value = 0.0f)     => Vector.Mask(in vector, (Game.Collections.Vector3Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              UnityEngine.Vector3                  Mask               (in UnityEngine.Vector3    vector, in Game.Collections.Vector3Bool axes,  float value = 0.0f)     => new(axes.x ? vector.x : value, axes.y ? vector.y : value, axes.z ? vector.z : value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Mask               (in UnityEngine.Vector3    vector, in Game.Collections.Vector4Bool axes,  float value = 0.0f)     => Vector.Mask(in vector, (Game.Collections.Vector3Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Mask               (in UnityEngine.Vector3    vector, in UnityEngine.Vector2                  axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector3Bool(axes.x == 1.0f, axes.y == 1.0f, true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Mask               (in UnityEngine.Vector3    vector, in UnityEngine.Vector2Int               axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector3Bool(axes.x == 1,    axes.y == 1,    true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Mask               (in UnityEngine.Vector3    vector, in UnityEngine.Vector3                  axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector3Bool(axes.x == 1.0f, axes.y == 1.0f, axes.z == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Mask               (in UnityEngine.Vector3    vector, in UnityEngine.Vector3Int               axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector3Bool(axes.x == 1,    axes.y == 1,    axes.z == 1),    value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  Mask               (in UnityEngine.Vector3    vector, in UnityEngine.Vector4                  axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector3Bool(axes.x == 1.0f, axes.y == 1.0f, axes.z == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Mask               (in UnityEngine.Vector3Int vector, in Game.Collections.Vector2Bool axes,  int   value = 0)        => Vector.Mask(in vector, (Game.Collections.Vector3Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              UnityEngine.Vector3Int               Mask               (in UnityEngine.Vector3Int vector, in Game.Collections.Vector3Bool axes,  int   value = 0)        => new(axes.x ? vector.x : value, axes.y ? vector.y : value, axes.z ? vector.z : value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Mask               (in UnityEngine.Vector3Int vector, in Game.Collections.Vector4Bool axes,  int   value = 0)        => Vector.Mask(in vector, (Game.Collections.Vector3Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Mask               (in UnityEngine.Vector3Int vector, in UnityEngine.Vector2                  axes,  int   value = 0)        => Vector.Mask(in vector, new Game.Collections.Vector3Bool(axes.x == 1.0f, axes.y == 1.0f, true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Mask               (in UnityEngine.Vector3Int vector, in UnityEngine.Vector2Int               axes,  int   value = 0)        => Vector.Mask(in vector, new Game.Collections.Vector3Bool(axes.x == 1,    axes.y == 1,    true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Mask               (in UnityEngine.Vector3Int vector, in UnityEngine.Vector3                  axes,  int   value = 0)        => Vector.Mask(in vector, new Game.Collections.Vector3Bool(axes.x == 1.0f, axes.y == 1.0f, axes.z == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Mask               (in UnityEngine.Vector3Int vector, in UnityEngine.Vector3Int               axes,  int   value = 0)        => Vector.Mask(in vector, new Game.Collections.Vector3Bool(axes.x == 1,    axes.y == 1,    axes.z == 1),    value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               Mask               (in UnityEngine.Vector3Int vector, in UnityEngine.Vector4                  axes,  int   value = 0)        => Vector.Mask(in vector, new Game.Collections.Vector3Bool(axes.x == 1.0f, axes.y == 1.0f, axes.z == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Mask               (in UnityEngine.Vector4    vector, in Game.Collections.Vector2Bool axes,  float value = 0.0f)     => Vector.Mask(in vector, (Game.Collections.Vector4Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Mask               (in UnityEngine.Vector4    vector, in Game.Collections.Vector3Bool axes,  float value = 0.0f)     => Vector.Mask(in vector, (Game.Collections.Vector4Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static              UnityEngine.Vector4                  Mask               (in UnityEngine.Vector4    vector, in Game.Collections.Vector4Bool axes,  float value = 0.0f)     => new(axes.x ? vector.x : value, axes.y ? vector.y : value, axes.z ? vector.z : value, axes.w ? vector.w : value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Mask               (in UnityEngine.Vector4    vector, in UnityEngine.Vector2                  axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector4Bool(axes.x == 1.0f, axes.y == 1.0f, true,           true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Mask               (in UnityEngine.Vector4    vector, in UnityEngine.Vector2Int               axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector4Bool(axes.x == 1,    axes.y == 1,    true,           true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Mask               (in UnityEngine.Vector4    vector, in UnityEngine.Vector3                  axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector4Bool(axes.x == 1.0f, axes.y == 1.0f, axes.z == 1.0f, true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Mask               (in UnityEngine.Vector4    vector, in UnityEngine.Vector3Int               axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector4Bool(axes.x == 1,    axes.y == 1,    axes.z == 1,    true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  Mask               (in UnityEngine.Vector4    vector, in UnityEngine.Vector4                  axes,  float value = 0.0f)     => Vector.Mask(in vector, new Game.Collections.Vector4Bool(axes.x == 1.0f, axes.y == 1.0f, axes.z == 1.0f, axes.w == 1.0f), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  MaskBack           (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, in Game.Collections.Vector3Bool.back,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               MaskBack           (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, in Game.Collections.Vector3Bool.back,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  MaskDown           (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, in Game.Collections.Vector2Bool.down,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               MaskDown           (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, in Game.Collections.Vector2Bool.down,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  MaskDown           (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, in Game.Collections.Vector3Bool.down,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               MaskDown           (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, in Game.Collections.Vector3Bool.down,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  MaskForward        (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, in Game.Collections.Vector3Bool.forward,                      value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               MaskForward        (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, in Game.Collections.Vector3Bool.forward,                      value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  MaskLeft           (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, in Game.Collections.Vector2Bool.left,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               MaskLeft           (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, in Game.Collections.Vector2Bool.left,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  MaskLeft           (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, in Game.Collections.Vector3Bool.left,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               MaskLeft           (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, in Game.Collections.Vector3Bool.left,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  MaskRight          (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, in Game.Collections.Vector2Bool.right,                        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               MaskRight          (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, in Game.Collections.Vector2Bool.right,                        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  MaskRight          (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, in Game.Collections.Vector3Bool.right,                        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               MaskRight          (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, in Game.Collections.Vector3Bool.right,                        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  MaskUp             (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, in Game.Collections.Vector2Bool.up,                           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               MaskUp             (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, in Game.Collections.Vector2Bool.up,                           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  MaskUp             (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, in Game.Collections.Vector3Bool.up,                           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               MaskUp             (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, in Game.Collections.Vector3Bool.up,                           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  MaskDepth          (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.MaskForward(in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               MaskDepth          (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.MaskForward(in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  MaskHeight         (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.MaskUp     (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               MaskHeight         (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.MaskUp     (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  MaskHeight         (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.MaskUp     (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               MaskHeight         (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.MaskUp     (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  MaskWidth          (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.MaskRight  (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               MaskWidth          (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.MaskRight  (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  MaskWidth          (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.MaskRight  (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               MaskWidth          (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.MaskRight  (in vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  MaskX              (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, new Game.Collections.Vector2Bool(true,  false),               value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               MaskX              (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, new Game.Collections.Vector2Bool(true,  false),               value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  MaskX              (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, new Game.Collections.Vector3Bool(true,  false, false),        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               MaskX              (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, new Game.Collections.Vector3Bool(true,  false, false),        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  MaskX              (in UnityEngine.Vector4    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, new Game.Collections.Vector4Bool(true,  false, false, false), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  MaskY              (in UnityEngine.Vector2    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, new Game.Collections.Vector2Bool(false, true),                value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               MaskY              (in UnityEngine.Vector2Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, new Game.Collections.Vector2Bool(false, true),                value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  MaskY              (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, new Game.Collections.Vector3Bool(false, true,  false),        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               MaskY              (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, new Game.Collections.Vector3Bool(false, true,  false),        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  MaskY              (in UnityEngine.Vector4    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, new Game.Collections.Vector4Bool(false, true,  false, false), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  MaskZ              (in UnityEngine.Vector3    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, new Game.Collections.Vector3Bool(false, false, true),         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               MaskZ              (in UnityEngine.Vector3Int vector,                                                int   value = 0)        => Vector.Mask       (in vector, new Game.Collections.Vector3Bool(false, false, true),         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  MaskZ              (in UnityEngine.Vector4    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, new Game.Collections.Vector4Bool(false, false, true, false),  value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector4                  MaskW              (in UnityEngine.Vector4    vector,                                                float value = 0.0f)     => Vector.Mask       (in vector, new Game.Collections.Vector4Bool(false, false, false, true),  value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly T                                    NegativeHalf    <T>() where T : struct                                                                                       => ref Util.Vector<T>.NegativeHalf;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly T                                    NegativeIdentity<T>() where T : struct                                                                                       => ref Util.Vector<T>.NegativeIdentity;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly T                                    NegativeInfinity<T>() where T : struct                                                                                       => ref Util.Vector<T>.NegativeInfinity;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly T                                    One             <T>() where T : struct                                                                                       => ref Util.Vector<T>.One;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly T                                    PositiveHalf    <T>() where T : struct                                                                                       => ref Util.Vector<T>.PositiveHalf;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly T                                    PositiveIdentity<T>() where T : struct                                                                                       => ref Util.Vector<T>.PositiveIdentity;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly T                                    PositiveInfinity<T>() where T : struct                                                                                       => ref Util.Vector<T>.PositiveInfinity;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              T                                    Random          <T>() where T : struct                                                                                       => typeof(T) == typeof(UnityEngine.Vector2) ? (T) (object) new UnityEngine.Vector2((float) Util.Random(), (float) Util.Random()) : typeof(T) == typeof(UnityEngine.Vector2Int) ? (T) (object) new UnityEngine.Vector2Int(Util.RandomBoolean() ? 1 : 0, Util.RandomBoolean() ? 1 : 0) : typeof(T) == typeof(UnityEngine.Vector3) ? (T) (object) new UnityEngine.Vector3((float) Util.Random(), (float) Util.Random(), (float) Util.Random()) : typeof(T) == typeof(UnityEngine.Vector3Int) ? (T) (object) new UnityEngine.Vector3Int(Util.RandomBoolean() ? 1 : 0, Util.RandomBoolean() ? 1 : 0, Util.RandomBoolean() ? 1 : 0) : typeof(T) == typeof(UnityEngine.Vector3) ? (T) (object) new UnityEngine.Vector4((float) Util.Random(), (float) Util.Random(), (float) Util.Random(), (float) Util.Random()) : default;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetAxis            (ref UnityEngine.Vector2    vector, uint                                    index, float value)           { if (index < 2u) vector[(int) index] = value; else throw new System.IndexOutOfRangeException("Invalid `Vector2` index!");    return ref vector; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetAxis            (ref UnityEngine.Vector2Int vector, uint                                    index, int   value)           { if (index < 2u) vector[(int) index] = value; else throw new System.IndexOutOfRangeException("Invalid `Vector2Int` index!"); return ref vector; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetAxis            (ref UnityEngine.Vector3    vector, uint                                    index, float value)           { if (index < 3u) vector[(int) index] = value; else throw new System.IndexOutOfRangeException("Invalid `Vector3` index!");    return ref vector; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetAxis            (ref UnityEngine.Vector3Int vector, uint                                    index, int   value)           { if (index < 3u) vector[(int) index] = value; else throw new System.IndexOutOfRangeException("Invalid `Vector3Int` index!"); return ref vector; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector4                  SetAxis            (ref UnityEngine.Vector4    vector, uint                                    index, float value)           { if (index < 4u) vector[(int) index] = value; else throw new System.IndexOutOfRangeException("Invalid `Vector4` index!");    return ref vector; }
      [GameMethod(AggressiveInlining), GameResolution(1)] public static ref          UnityEngine.Vector2                  SetAxis            (ref UnityEngine.Vector2    vector, Game.Collections.Vector2Bool    axes,  float value)           { vector.x = axes.x ? value : vector.x; vector.y = axes.y ? value : vector.y; return ref vector; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetAxis            (ref UnityEngine.Vector2    vector, in Game.Collections.Vector3Bool axes,  float value)           => ref Vector.SetAxis(ref vector, (Game.Collections.Vector2Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetAxis            (ref UnityEngine.Vector2    vector, in Game.Collections.Vector4Bool axes,  float value)           => ref Vector.SetAxis(ref vector, (Game.Collections.Vector2Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetAxis            (ref UnityEngine.Vector2    vector, in UnityEngine.Vector2                  axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector2Bool(0.0f != axes.x, 0.0f != axes.y), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetAxis            (ref UnityEngine.Vector2    vector, in UnityEngine.Vector2Int               axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector2Bool(0    != axes.x, 0    != axes.y), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetAxis            (ref UnityEngine.Vector2    vector, in UnityEngine.Vector3                  axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector2Bool(0.0f != axes.x, 0.0f != axes.y), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetAxis            (ref UnityEngine.Vector2    vector, in UnityEngine.Vector3Int               axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector2Bool(0    != axes.x, 0    != axes.y), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetAxis            (ref UnityEngine.Vector2    vector, in UnityEngine.Vector4                  axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector2Bool(0.0f != axes.x, 0.0f != axes.y), value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static ref          UnityEngine.Vector2Int               SetAxis            (ref UnityEngine.Vector2Int vector, Game.Collections.Vector2Bool    axes,  int   value)           { vector.x = axes.x ? value : vector.x; vector.y = axes.y ? value : vector.y; return ref vector; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetAxis            (ref UnityEngine.Vector2Int vector, in Game.Collections.Vector3Bool axes,  int   value)           => ref Vector.SetAxis(ref vector, (Game.Collections.Vector2Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetAxis            (ref UnityEngine.Vector2Int vector, in Game.Collections.Vector4Bool axes,  int   value)           => ref Vector.SetAxis(ref vector, (Game.Collections.Vector2Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetAxis            (ref UnityEngine.Vector2Int vector, in UnityEngine.Vector2                  axes,  int   value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector2Bool(0.0f != axes.x, 0.0f != axes.y), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetAxis            (ref UnityEngine.Vector2Int vector, in UnityEngine.Vector2Int               axes,  int   value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector2Bool(0    != axes.x, 0    != axes.y), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetAxis            (ref UnityEngine.Vector2Int vector, in UnityEngine.Vector3                  axes,  int   value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector2Bool(0.0f != axes.x, 0.0f != axes.y), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetAxis            (ref UnityEngine.Vector2Int vector, in UnityEngine.Vector3Int               axes,  int   value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector2Bool(0    != axes.x, 0    != axes.y), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetAxis            (ref UnityEngine.Vector2Int vector, in UnityEngine.Vector4                  axes,  int   value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector2Bool(0.0f != axes.x, 0.0f != axes.y), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetAxis            (ref UnityEngine.Vector3    vector, in Game.Collections.Vector2Bool axes,  float value)           => ref Vector.SetAxis(ref vector, (Game.Collections.Vector3Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static ref          UnityEngine.Vector3                  SetAxis            (ref UnityEngine.Vector3    vector, Game.Collections.Vector3Bool    axes,  float value)           { vector.x = axes.x ? value : vector.x; vector.y = axes.y ? value : vector.y; vector.z = axes.z ? value : vector.z; return ref vector; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetAxis            (ref UnityEngine.Vector3    vector, in Game.Collections.Vector4Bool axes,  float value)           => ref Vector.SetAxis(ref vector, (Game.Collections.Vector3Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetAxis            (ref UnityEngine.Vector3    vector, in UnityEngine.Vector2                  axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector3Bool(0.0f != axes.x, 0.0f != axes.y, true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetAxis            (ref UnityEngine.Vector3    vector, in UnityEngine.Vector2Int               axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector3Bool(0    != axes.x, 0    != axes.y, true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetAxis            (ref UnityEngine.Vector3    vector, in UnityEngine.Vector3                  axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector3Bool(0.0f != axes.x, 0.0f != axes.y, 0.0f != axes.z), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetAxis            (ref UnityEngine.Vector3    vector, in UnityEngine.Vector3Int               axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector3Bool(0    != axes.x, 0    != axes.y, 0    != axes.z), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetAxis            (ref UnityEngine.Vector3    vector, in UnityEngine.Vector4                  axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector3Bool(0.0f != axes.x, 0.0f != axes.y, 0.0f != axes.z), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetAxis            (ref UnityEngine.Vector3Int vector, in Game.Collections.Vector2Bool axes,  int   value)           => ref Vector.SetAxis(ref vector, (Game.Collections.Vector3Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static ref          UnityEngine.Vector3Int               SetAxis            (ref UnityEngine.Vector3Int vector, Game.Collections.Vector3Bool    axes,  int   value)           { vector.x = axes.x ? value : vector.x; vector.y = axes.y ? value : vector.y; vector.z = axes.z ? value : vector.z; return ref vector; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetAxis            (ref UnityEngine.Vector3Int vector, in Game.Collections.Vector4Bool axes,  int   value)           => ref Vector.SetAxis(ref vector, (Game.Collections.Vector3Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetAxis            (ref UnityEngine.Vector3Int vector, in UnityEngine.Vector2                  axes,  int   value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector3Bool(0.0f != axes.x, 0.0f != axes.y, true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetAxis            (ref UnityEngine.Vector3Int vector, in UnityEngine.Vector2Int               axes,  int   value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector3Bool(0    != axes.x, 0    != axes.y, true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetAxis            (ref UnityEngine.Vector3Int vector, in UnityEngine.Vector3                  axes,  int   value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector3Bool(0.0f != axes.x, 0.0f != axes.y, 0.0f != axes.z), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetAxis            (ref UnityEngine.Vector3Int vector, in UnityEngine.Vector3Int               axes,  int   value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector3Bool(0    != axes.x, 0    != axes.y, 0    != axes.z), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetAxis            (ref UnityEngine.Vector3Int vector, in UnityEngine.Vector4                  axes,  int   value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector3Bool(0.0f != axes.x, 0.0f != axes.y, 0.0f != axes.z), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector4                  SetAxis            (ref UnityEngine.Vector4    vector, in Game.Collections.Vector2Bool axes,  float value)           => ref Vector.SetAxis(ref vector, (Game.Collections.Vector4Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector4                  SetAxis            (ref UnityEngine.Vector4    vector, in Game.Collections.Vector3Bool axes,  float value)           => ref Vector.SetAxis(ref vector, (Game.Collections.Vector4Bool) axes, value);
      [GameMethod(AggressiveInlining), GameResolution(1)] public static ref          UnityEngine.Vector4                  SetAxis            (ref UnityEngine.Vector4    vector, Game.Collections.Vector4Bool    axes,  float value)           { vector.x = axes.x ? value : vector.x; vector.y = axes.y ? value : vector.y; vector.z = axes.z ? value : vector.z; vector.w = axes.w ? value : vector.w; return ref vector; }
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector4                  SetAxis            (ref UnityEngine.Vector4    vector, in UnityEngine.Vector2                  axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector4Bool(0.0f != axes.x, 0.0f != axes.y, true,           true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector4                  SetAxis            (ref UnityEngine.Vector4    vector, in UnityEngine.Vector2Int               axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector4Bool(0    != axes.x, 0    != axes.y, true,           true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector4                  SetAxis            (ref UnityEngine.Vector4    vector, in UnityEngine.Vector3                  axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector4Bool(0.0f != axes.x, 0.0f != axes.y, 0.0f != axes.z, true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector4                  SetAxis            (ref UnityEngine.Vector4    vector, in UnityEngine.Vector3Int               axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector4Bool(0    != axes.x, 0    != axes.y, 0    != axes.z, true),           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector4                  SetAxis            (ref UnityEngine.Vector4    vector, in UnityEngine.Vector4                  axes,  float value)           => ref Vector.SetAxis(ref vector, new Game.Collections.Vector4Bool(0.0f != axes.x, 0.0f != axes.y, 0.0f != axes.z, 0.0f != axes.w), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetBackAxis        (ref UnityEngine.Vector3    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector3Bool.back,                            value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetBackAxis        (ref UnityEngine.Vector3Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector3Bool.back,                            value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetDownAxis        (ref UnityEngine.Vector2    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector2Bool.down,                            value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetDownAxis        (ref UnityEngine.Vector2Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector2Bool.down,                            value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetDownAxis        (ref UnityEngine.Vector3    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector3Bool.down,                            value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetDownAxis        (ref UnityEngine.Vector3Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector3Bool.down,                            value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetForwardAxis     (ref UnityEngine.Vector3    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector3Bool.forward,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetForwardAxis     (ref UnityEngine.Vector3Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector3Bool.forward,                         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetLeftAxis        (ref UnityEngine.Vector2    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector2Bool.left,                            value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetLeftAxis        (ref UnityEngine.Vector2Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector2Bool.left,                            value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetLeftAxis        (ref UnityEngine.Vector3    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector3Bool.left,                            value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetLeftAxis        (ref UnityEngine.Vector3Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector3Bool.left,                            value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetRightAxis       (ref UnityEngine.Vector2    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector2Bool.right,                           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetRightAxis       (ref UnityEngine.Vector2Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector2Bool.right,                           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetRightAxis       (ref UnityEngine.Vector3    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector3Bool.right,                           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetRightAxis       (ref UnityEngine.Vector3Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector3Bool.right,                           value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetUpAxis          (ref UnityEngine.Vector2    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector2Bool.up,                              value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetUpAxis          (ref UnityEngine.Vector2Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector2Bool.up,                              value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetUpAxis          (ref UnityEngine.Vector3    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector3Bool.up,                              value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetUpAxis          (ref UnityEngine.Vector3Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, Game.Collections.Vector3Bool.up,                              value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetDepthAxis       (ref UnityEngine.Vector3    vector,                                                float value)           => ref Vector.SetForwardAxis(ref vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetDepthAxis       (ref UnityEngine.Vector3Int vector,                                                int   value)           => ref Vector.SetForwardAxis(ref vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetHeightAxis      (ref UnityEngine.Vector2    vector,                                                float value)           => ref Vector.SetUpAxis     (ref vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetHeightAxis      (ref UnityEngine.Vector2Int vector,                                                int   value)           => ref Vector.SetUpAxis     (ref vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetHeightAxis      (ref UnityEngine.Vector3    vector,                                                float value)           => ref Vector.SetUpAxis     (ref vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetHeightAxis      (ref UnityEngine.Vector3Int vector,                                                int   value)           => ref Vector.SetUpAxis     (ref vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetWidthAxis       (ref UnityEngine.Vector2    vector,                                                float value)           => ref Vector.SetRightAxis  (ref vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetWidthAxis       (ref UnityEngine.Vector2Int vector,                                                int   value)           => ref Vector.SetRightAxis  (ref vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetWidthAxis       (ref UnityEngine.Vector3    vector,                                                float value)           => ref Vector.SetRightAxis  (ref vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetWidthAxis       (ref UnityEngine.Vector3Int vector,                                                int   value)           => ref Vector.SetRightAxis  (ref vector,                                                                       value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetXAxis           (ref UnityEngine.Vector2    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, new Game.Collections.Vector2Bool(true,  false),               value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetXAxis           (ref UnityEngine.Vector2Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, new Game.Collections.Vector2Bool(true,  false),               value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetXAxis           (ref UnityEngine.Vector3    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, new Game.Collections.Vector3Bool(true,  false, false),        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetXAxis           (ref UnityEngine.Vector3Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, new Game.Collections.Vector3Bool(true,  false, false),        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector4                  SetXAxis           (ref UnityEngine.Vector4    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, new Game.Collections.Vector4Bool(true,  false, false, false), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2                  SetYAxis           (ref UnityEngine.Vector2    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, new Game.Collections.Vector2Bool(false, true),                value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector2Int               SetYAxis           (ref UnityEngine.Vector2Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, new Game.Collections.Vector2Bool(false, true),                value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetYAxis           (ref UnityEngine.Vector3    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, new Game.Collections.Vector3Bool(false, true,  false),        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetYAxis           (ref UnityEngine.Vector3Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, new Game.Collections.Vector3Bool(false, true,  false),        value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector4                  SetYAxis           (ref UnityEngine.Vector4    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, new Game.Collections.Vector4Bool(false, true,  false, false), value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3                  SetZAxis           (ref UnityEngine.Vector3    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, new Game.Collections.Vector3Bool(false, false, true),         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector3Int               SetZAxis           (ref UnityEngine.Vector3Int vector,                                                int   value)           => ref Vector.SetAxis       (ref vector, new Game.Collections.Vector3Bool(false, false, true),         value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector4                  SetZAxis           (ref UnityEngine.Vector4    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, new Game.Collections.Vector4Bool(false, false, true, false),  value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref          UnityEngine.Vector4                  SetWAxis           (ref UnityEngine.Vector4    vector,                                                float value)           => ref Vector.SetAxis       (ref vector, new Game.Collections.Vector4Bool(false, false, false, true),  value);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              Game.Collections.Vector2Bool ToBool             (in  UnityEngine.Vector2    vector)                                                                       => new(0.0f != vector.x, 0.0f != vector.y);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              Game.Collections.Vector2Bool ToBool             (in  UnityEngine.Vector2Int vector)                                                                       => new(0    != vector.x, 0    != vector.y);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              Game.Collections.Vector3Bool ToBool             (in  UnityEngine.Vector3    vector)                                                                       => new(0.0f != vector.x, 0.0f != vector.y, 0.0f != vector.z);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              Game.Collections.Vector3Bool ToBool             (in  UnityEngine.Vector3Int vector)                                                                       => new(0    != vector.x, 0    != vector.y, 0    != vector.z);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              Game.Collections.Vector4Bool ToBool             (in  UnityEngine.Vector4    vector)                                                                       => new(0.0f != vector.x, 0.0f != vector.y, 0.0f != vector.z, 0.0f != vector.w);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2                  ToInt              (in  UnityEngine.Vector2    vector)                                                                       => new(vector.x, vector.y);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector2Int               ToInt              (in  UnityEngine.Vector2Int vector)                                                                       => vector;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3                  ToInt              (in  UnityEngine.Vector3    vector)                                                                       => new(vector.x, vector.y, vector.z);
      [GameMethod(AggressiveInlining), GameResolution(0)] public static              UnityEngine.Vector3Int               ToInt              (in  UnityEngine.Vector3Int vector)                                                                       => vector;
      [GameMethod(AggressiveInlining), GameResolution(0)] public static ref readonly T                                    Zero<T>            () where T : struct                                                                                       => ref Util.Vector<T>.Zero;
    }

    private static class Vector<T> where T : struct {
      public static ref readonly T Half => ref Vector<T>.PositiveHalf; // ->> `Double` considered but rejected

      public static readonly T NegativeHalf = (
        typeof(T) == typeof(UnityEngine.Vector2) ? (T) (object) new UnityEngine.Vector2(-0.5f, -0.5f)               :
        typeof(T) == typeof(UnityEngine.Vector3) ? (T) (object) new UnityEngine.Vector3(-0.5f, -0.5f, -0.5f)        :
        typeof(T) == typeof(UnityEngine.Vector4) ? (T) (object) new UnityEngine.Vector4(-0.5f, -0.5f, -0.5f, -0.5f) :
        Vector<T>.Zero
      );

      public static readonly T NegativeIdentity = (
        typeof(T) == typeof(UnityEngine.Vector2)    ? (T) (object) -UnityEngine.Vector2   .one :
        typeof(T) == typeof(UnityEngine.Vector2Int) ? (T) (object) -UnityEngine.Vector2Int.one :
        typeof(T) == typeof(UnityEngine.Vector3)    ? (T) (object) -UnityEngine.Vector3   .one :
        typeof(T) == typeof(UnityEngine.Vector3Int) ? (T) (object) -UnityEngine.Vector3Int.one :
        typeof(T) == typeof(UnityEngine.Vector4)    ? (T) (object) -UnityEngine.Vector4   .one :
        default
      );

      public static readonly T NegativeInfinity = (
        typeof(T) == typeof(UnityEngine.Vector2) ? (T) (object) UnityEngine.Vector2.negativeInfinity :
        typeof(T) == typeof(UnityEngine.Vector3) ? (T) (object) UnityEngine.Vector3.negativeInfinity :
        typeof(T) == typeof(UnityEngine.Vector4) ? (T) (object) UnityEngine.Vector4.negativeInfinity :
        Vector<T>.NegativeIdentity
      );

      public static ref readonly T One => ref Vector<T>.PositiveIdentity;

      public static readonly T PositiveHalf = (
        typeof(T) == typeof(UnityEngine.Vector2) ? (T) (object) new UnityEngine.Vector2(+0.5f, +0.5f)               :
        typeof(T) == typeof(UnityEngine.Vector3) ? (T) (object) new UnityEngine.Vector3(+0.5f, +0.5f, +0.5f)        :
        typeof(T) == typeof(UnityEngine.Vector4) ? (T) (object) new UnityEngine.Vector4(+0.5f, +0.5f, +0.5f, +0.5f) :
        Vector<T>.Zero
      );

      public static readonly T PositiveIdentity = (
        typeof(T) == typeof(UnityEngine.Vector2)    ? (T) (object) UnityEngine.Vector2   .one :
        typeof(T) == typeof(UnityEngine.Vector2Int) ? (T) (object) UnityEngine.Vector2Int.one :
        typeof(T) == typeof(UnityEngine.Vector3)    ? (T) (object) UnityEngine.Vector3   .one :
        typeof(T) == typeof(UnityEngine.Vector3Int) ? (T) (object) UnityEngine.Vector3Int.one :
        typeof(T) == typeof(UnityEngine.Vector4)    ? (T) (object) UnityEngine.Vector4   .one :
        default
      );

      public static readonly T PositiveInfinity = (
        typeof(T) == typeof(UnityEngine.Vector2) ? (T) (object) UnityEngine.Vector2.positiveInfinity :
        typeof(T) == typeof(UnityEngine.Vector3) ? (T) (object) UnityEngine.Vector3.positiveInfinity :
        typeof(T) == typeof(UnityEngine.Vector4) ? (T) (object) UnityEngine.Vector4.positiveInfinity :
        Vector<T>.PositiveIdentity
      );

      public static readonly T Zero = (
        typeof(T) == typeof(UnityEngine.Vector2)    ? (T) (object) UnityEngine.Vector2   .zero :
        typeof(T) == typeof(UnityEngine.Vector2Int) ? (T) (object) UnityEngine.Vector2Int.zero :
        typeof(T) == typeof(UnityEngine.Vector3)    ? (T) (object) UnityEngine.Vector3   .zero :
        typeof(T) == typeof(UnityEngine.Vector3Int) ? (T) (object) UnityEngine.Vector3Int.zero :
        typeof(T) == typeof(UnityEngine.Vector4)    ? (T) (object) UnityEngine.Vector4   .zero :
        default
      );

      public static readonly T Epsilon = (
        typeof(T) == typeof(UnityEngine.Vector2) ? (T) (object) new UnityEngine.Vector2(float.Epsilon, float.Epsilon) :
        typeof(T) == typeof(UnityEngine.Vector3) ? (T) (object) new UnityEngine.Vector3(float.Epsilon, float.Epsilon, float.Epsilon) :
        typeof(T) == typeof(UnityEngine.Vector4) ? (T) (object) new UnityEngine.Vector4(float.Epsilon, float.Epsilon, float.Epsilon, float.Epsilon) :
        Vector<T>.Zero
      );
    }

    public static class Wait {
      internal sealed   class  MonoBehaviour : UnityEngine.MonoBehaviour {}
      internal readonly struct TimerIndex                                {}

      /* … */
      internal static readonly Game.Collections.RefSortedCollection<double, Game.Collections.WaitInfo> Pending = new(16u) {{double.NaN, new()}};                                                                                                 // ->> Used `System.Collections.Generic.SortedDictionary<double, Game.Collections.WaitInfo>` prior
      internal static readonly Wait.MonoBehaviour                                                                      Waiter  = Util.Eval(static waiter => waiter.PreserveFromSceneLoad(), new UnityEngine.GameObject("⏱️").AddComponent<Wait.MonoBehaviour>()); // ->> Use coroutines for asynchronicity

      /* … */
      [GameMethod(AggressiveInlining)] public static uint Check         () => Wait.CheckCoroutine();
      [GameMethod(AggressiveInlining)] public static uint CheckCoroutine() => 0u; // ->> Number of coroutines stopped

      public static uint CheckTimer() {
        uint                                                                                    count     = 0u;
        Game.Collections.SharedList<Game.Collections.IndexFor<Wait.TimerIndex>> resolved  = new();
        double                                                                                  timestamp = UnityEngine.Time.realtimeSinceStartupAsDouble;
        ref readonly Game.Collections.WaitInfo                                          wait      = ref Wait.Pending[0]; // ->> `Wait.Pending.GetValueByRank(double.NaN)`

        // … ->> Enumeration is messy because the final design could not succinctly account for a timer-based model
        for (uint index = resolved.IsEmpty() ? wait.events.CountInvocationList() : resolved[resolved.Count - 1u].value; 0u != index--; ) {
          ref Game.Collections.HandlerInfo<Game.Events.WaitEvent> waitHandler = ref wait.events[index];
          ref Game.Events.WaitEvent                                       waitEvent   = ref waitHandler.metadata;

          // …
          if (!(timestamp < waitEvent.data.timestamp)) {
            if (!waitEvent.data.repeating) resolved.Add(index);               // ->> Remove `Wait.ForTimerUntil(…)` handlers, or
            else waitEvent.data.timestamp = timestamp + waitEvent.data.delay; // ->> Update `Wait.ForTimerEvery(…)` handlers

            waitHandler.Invoke(); // ->> Assumes `CheckTimer()` is not simultaneously invoked here
          }
        }

        foreach (uint index in resolved)
          wait.events.RemoveAt(index);

        resolved.Clear();

        return count;
      }

      [GameMethod(AggressiveInlining)] public static void Every(double delay, Game.Handler<Game.Events.WaitEvent> callback, object? metadata = null) => Wait.ForCoroutineEvery(delay, callback,                                                                       metadata);
      [GameMethod(AggressiveInlining)] public static void Every(double delay, System.Action       <object?>                       callback, object? metadata = null) => Wait.Every            (delay, Game.Events.ToMetadataHandler<Game.Events.WaitEvent>(callback), metadata);

      private static void ForCoroutine(double delay, Game.Handler<Game.Events.WaitEvent> callback, object? metadata, bool forever) {
        [GameMethod(AggressiveInlining)]
        static System.Collections.IEnumerator EnumerateRoutine(double delay, bool forever) {
          do {
            yield return new UnityEngine.WaitForSecondsRealtime((float) delay);
            Game.Collections.WaitInfo wait = Wait.Pending.GetValueByRank(delay); // ->> Could be a reference local

            // …
            if (0u == wait.events.CountInvocationList())
            break;

            wait.events.Invoke();
          } while (forever);

          uint index = (uint) Wait.Pending.IndexOfRank(delay);

          Wait.Waiter .StopCoroutine(Wait.Pending[index].coroutine);
          Wait.Pending.RemoveAt     (index); // TODO: Reentrancy check with adding new `WaitInfo`s?
        }

        ref Game.Collections.WaitInfo wait = ref Wait.Pending.TryAppend(delay, new(Wait.Waiter.StartCoroutine(EnumerateRoutine(delay, forever))));
        wait.events += new Game.Collections.HandlerInfo<Game.Events.WaitEvent>(callback, wait.coroutine, new() {callback = callback, data = (delay, UnityEngine.Time.realtimeSinceStartupAsDouble + delay, forever), metadata = metadata});
      }

      [GameMethod(AggressiveInlining)] public  static void ForCoroutineEvery (double                                                                   delay,  System.Action<object?>                              callback, object? metadata = null)                                   => Wait.ForCoroutine (delay, Game.Events.ToMetadataHandler<Game.Events.WaitEvent>(callback), metadata, true);
      [GameMethod(AggressiveInlining)] public  static void ForCoroutineEvery (double                                                                   delay,  Game.Handler<Game.Events.WaitEvent> callback, object? metadata = null)                                   => Wait.ForCoroutine (delay, callback,                                                                       metadata, true);
      [GameMethod(AggressiveInlining)] public  static void ForCoroutineUntil (double                                                                   delay,  System.Action<object?>                              callback, object? metadata = null)                                   => Wait.ForCoroutine (delay, Game.Events.ToMetadataHandler<Game.Events.WaitEvent>(callback), metadata, false);
      [GameMethod(AggressiveInlining)] public  static void ForCoroutineUntil (double                                                                   delay,  Game.Handler<Game.Events.WaitEvent> callback, object? metadata = null)                                   => Wait.ForCoroutine (delay, callback,                                                                       metadata, false);
      [GameMethod(AggressiveInlining)] public  static void ForTimerEvery     (double                                                                   delay,  System.Action<object?>                              callback, object? metadata = null)                                   => Wait.ForTimerEvery(delay, Game.Events.ToMetadataHandler<Game.Events.WaitEvent>(callback), metadata);
      [GameMethod(AggressiveInlining)] public  static void ForTimerEvery     (double                                                                   delay,  Game.Handler<Game.Events.WaitEvent> callback, object? metadata = null)                                   => Wait.Pending[0].events += new Game.Collections.HandlerInfo<Game.Events.WaitEvent>(callback, null, new() {callback = callback, data = (delay, UnityEngine.Time.realtimeSinceStartupAsDouble + delay, true),  metadata = metadata});
      [GameMethod(AggressiveInlining)] public  static void ForTimerUntil     (double                                                                   delay,  System.Action<object?>                              callback, object? metadata = null)                                   => Wait.ForTimerUntil(delay, Game.Events.ToMetadataHandler<Game.Events.WaitEvent>(callback), metadata);
      [GameMethod(AggressiveInlining)] public  static void ForTimerUntil     (double                                                                   delay,  Game.Handler<Game.Events.WaitEvent> callback, object? metadata = null)                                   => Wait.Pending[0].events += new Game.Collections.HandlerInfo<Game.Events.WaitEvent>(callback, null, new() {callback = callback, data = (delay, UnityEngine.Time.realtimeSinceStartupAsDouble + delay, false), metadata = metadata});
      [GameMethod(AggressiveInlining)] public  static bool IsCoroutinePending(Game.Handler<Game.Events.WaitEvent>                      callback)                                                                                                                        { foreach (double delay in Wait.Pending.Keys) { if (Wait.IsCoroutinePending(delay, callback)) return true; } return false; }
      [GameMethod(AggressiveInlining)] public  static bool IsCoroutinePending(double                                                                   delay)                                                                                                                           => Wait.Pending.IndexOfRank(delay) > 0;
      [GameMethod(AggressiveInlining)] public  static bool IsCoroutinePending(double                                                                   delay, Game.Handler<Game.Events.WaitEvent> callback)                                                             { int index = Wait.Pending.IndexOfRank(delay); if (index > 0) { return Wait.IsPending(ref Wait.Pending[(uint) index].events, callback); } return false; }
      [GameMethod(AggressiveInlining)] public  static bool IsPending         (Game.Handler<Game.Events.WaitEvent>                      callback)                                                                                                                        => Wait.IsCoroutinePending(callback)        || Wait.IsTimerPending(callback);
      [GameMethod(AggressiveInlining)] public  static bool IsPending         (double                                                                   delay)                                                                                                                           => Wait.IsCoroutinePending(delay)           || Wait.IsTimerPending(delay);
      [GameMethod(AggressiveInlining)] public  static bool IsPending         (Game.Handler<Game.Events.WaitEvent>                      callback, double                                              delay)                                                             => Wait.IsCoroutinePending(delay, callback) || Wait.IsTimerPending(delay, callback);
      [GameMethod(AggressiveInlining)] private static bool IsPending         (ref Game.Collections.EventHandler<Game.Events.WaitEvent> events,   Game.Handler<Game.Events.WaitEvent> callback)                                                          { for (uint index = events.CountInvocationList(); 0u != index--; ) { if (callback == events[index].value)                                          return true; } return false; }
      [GameMethod(AggressiveInlining)] private static bool IsPending         (ref Game.Collections.EventHandler<Game.Events.WaitEvent> events,   double                                              delay)                                                             { for (uint index = events.CountInvocationList(); 0u != index--; ) { if (delay    == events[index].metadata.delay)                                 return true; } return false; }
      [GameMethod(AggressiveInlining)] private static bool IsPending         (ref Game.Collections.EventHandler<Game.Events.WaitEvent> events,   Game.Handler<Game.Events.WaitEvent> callback, double delay)                                            { for (uint index = events.CountInvocationList(); 0u != index--; ) { if (callback == events[index].value && delay == events[index].metadata.delay) return true; } return false; }
      [GameMethod(AggressiveInlining)] public  static bool IsTimerPending    (Game.Handler<Game.Events.WaitEvent>                      callback)                                                                                                                        => Wait.IsPending(ref Wait.Pending[0].events, callback);
      [GameMethod(AggressiveInlining)] public  static bool IsTimerPending    (double                                                                   delay)                                                                                                                           => Wait.IsPending(ref Wait.Pending[0].events, delay);
      [GameMethod(AggressiveInlining)] public  static bool IsTimerPending    (double                                                                   delay,  Game.Handler<Game.Events.WaitEvent> callback)                                                            => Wait.IsPending(ref Wait.Pending[0].events, callback, delay);
      [GameMethod(AggressiveInlining)] private static uint Stop              (ref Game.Collections.EventHandler<Game.Events.WaitEvent> events, Game.Handler<Game.Events.WaitEvent> callback)                                                            { uint count = 0u; for (uint index = events.CountInvocationList(); 0u != index--; ) if (callback == events[index].value)                                          { ++count; events.RemoveAt(index); } return count; }
      [GameMethod(AggressiveInlining)] private static uint Stop              (ref Game.Collections.EventHandler<Game.Events.WaitEvent> events, double                                              delay, Game.Handler<Game.Events.WaitEvent> callback) { uint count = 0u; for (uint index = events.CountInvocationList(); 0u != index--; ) if (callback == events[index].value && delay == events[index].metadata.delay) { ++count; events.RemoveAt(index); } return count; }
      [GameMethod(AggressiveInlining)] private static uint StopAll           (ref Game.Collections.EventHandler<Game.Events.WaitEvent> events)                                                                                                                          { uint count = events.CountInvocationList(); events.Clear();                                                                                                                                           return count; }
      [GameMethod(AggressiveInlining)] public  static uint StopCoroutine     ()                                                                                                                                                                                                         { uint count = 0u; for (uint index = Wait.Pending.Count; 0u != --index; ) { count += Wait.StopAll(ref Wait.Pending[index].events); }           return count; }
      [GameMethod(AggressiveInlining)] public  static uint StopCoroutine     (Game.Handler<Game.Events.WaitEvent> callback)                                                                                                                                             { uint count = 0u; for (uint index = Wait.Pending.Count; 0u != --index; ) { count += Wait.Stop   (ref Wait.Pending[index].events, callback); } return count; }
      [GameMethod(AggressiveInlining)] public  static uint StopCoroutine     (double                                              delay, Game.Handler<Game.Events.WaitEvent> callback)                                                                                  { int index = Wait.Pending.IndexOfRank(delay); return index > 0 ? Wait.Stop(ref Wait.Pending[(uint) index].events, callback) : 0u; }
      [GameMethod(AggressiveInlining)] public  static uint StopTimer         ()                                                                                                                                                                                                         => Wait.StopAll          (ref Wait.Pending[0].events);
      [GameMethod(AggressiveInlining)] public  static uint StopTimer         (Game.Handler<Game.Events.WaitEvent> callback)                                                                                                                                             => Wait.Stop             (ref Wait.Pending[0].events, callback);
      [GameMethod(AggressiveInlining)] public  static uint StopTimer         (double                                              delay, Game.Handler<Game.Events.WaitEvent> callback)                                                                                  => Wait.Stop             (ref Wait.Pending[0].events, delay, callback);
      [GameMethod(AggressiveInlining)] public  static void Until             (double                                              delay, System.Action       <object?>                       callback, object? metadata = null)                                                         => Wait.Until            (delay, Game.Events.ToMetadataHandler<Game.Events.WaitEvent>(callback), metadata);
      [GameMethod(AggressiveInlining)] public  static void Until             (double                                              delay, Game.Handler<Game.Events.WaitEvent> callback, object? metadata = null)                                                         => Wait.ForCoroutineUntil(delay, callback,                                                                                                        metadata);
    }

    /* … */
    private  static readonly System.Collections.Generic.Dictionary            <(System.Type, System.Type), System.Delegate>                                 Casters              = new(1);
    internal static readonly Game.Collections.RefReadOnlyDictionary   <string, UnityEngine.Color>                                                   Colors               = ((System.Func<string[], UnityEngine.Color[], Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Color>>) ([GameMethod(AggressiveInlining)] static (names, colors) => { Game.Collections.RefReadOnlyDictionary<string, UnityEngine.Color> dictionary = new(); dictionary.keys = new(names); dictionary.values = new(colors); return dictionary; }))(new[] {"antiqueWhite", "aquamarine", "azure", "beige", "bisque", "black", "blanchedAlmond", "blue", "blueViolet", "brown", "burlywood", "cadetBlue", "chartreuse", "chocolate", "clear", "coral", "cornflowerBlue", "cornsilk", "crimson", "cyan", "darkBlue", "darkCyan", "darkGoldenRod", "darkGray", "darkGreen", "darkKhaki", "darkMagenta", "darkOliveGreen", "darkOrange", "darkOrchid", "darkRed", "darkSalmon", "darkSeaGreen", "darkSlateBlue", "darkSlateGray", "darkTurquoise", "darkViolet", "deepPink", "deepSkyBlue", "dimGray", "dodgerBlue", "firebrick", "floralWhite", "forestGreen", "gainsboro", "ghostWhite", "gold", "goldenRod", "gray", "gray1", "gray2", "gray3", "gray4", "gray5", "gray6", "gray7", "gray8", "gray9", "green", "greenYellow", "grey", "honeydew", "hotPink", "indianRed", "indigo", "ivory", "khaki", "lavender", "lavenderBlush", "lawnGreen", "lemonChiffon", "lightBlue", "lightCoral", "lightCyan", "lightGoldenRod", "lightGoldenRodYellow", "lightGray", "lightGreen", "lightPink", "lightSalmon", "lightSeaGreen", "lightSkyBlue", "lightSlateBlue", "lightSlateGray", "lightSteelBlue", "lightYellow", "limeGreen", "linen", "magenta", "maroon", "mediumAquamarine", "mediumBlue", "mediumOrchid", "mediumPurple", "mediumSeaGreen", "mediumSlateBlue", "mediumSpringGreen", "mediumTurquoise", "mediumVioletRed", "midnightBlue", "mintCream", "mistyRose", "moccasin", "navajoWhite", "navyBlue", "oldLace", "olive", "oliveDrab", "orange", "orangeRed", "orchid", "paleGoldenRod", "paleGreen", "paleTurquoise", "paleVioletRed", "papayaWhip", "peachPuff", "peru", "pink", "plum", "powderBlue", "purple", "rebeccaPurple", "red", "rosyBrown", "royalBlue", "saddleBrown", "salmon", "sandyBrown", "seaGreen", "seashell", "sienna", "silver", "skyBlue", "slateBlue", "slateGray", "snow", "softBlue", "softGreen", "softRed", "softYellow", "springGreen", "steelBlue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "violetRed", "wheat", "white", "whiteSmoke", "yellow", "yellowGreen", "yellowNice"}, /* ->> `stackalloc` */ new[] {UnityEngine.Color.antiqueWhite, UnityEngine.Color.aquamarine, UnityEngine.Color.azure, UnityEngine.Color.beige, UnityEngine.Color.bisque, UnityEngine.Color.black, UnityEngine.Color.blanchedAlmond, UnityEngine.Color.blue, UnityEngine.Color.blueViolet, UnityEngine.Color.brown, UnityEngine.Color.burlywood, UnityEngine.Color.cadetBlue, UnityEngine.Color.chartreuse, UnityEngine.Color.chocolate, UnityEngine.Color.clear, UnityEngine.Color.coral, UnityEngine.Color.cornflowerBlue, UnityEngine.Color.cornsilk, UnityEngine.Color.crimson, UnityEngine.Color.cyan, UnityEngine.Color.darkBlue, UnityEngine.Color.darkCyan, UnityEngine.Color.darkGoldenRod, UnityEngine.Color.darkGray, UnityEngine.Color.darkGreen, UnityEngine.Color.darkKhaki, UnityEngine.Color.darkMagenta, UnityEngine.Color.darkOliveGreen, UnityEngine.Color.darkOrange, UnityEngine.Color.darkOrchid, UnityEngine.Color.darkRed, UnityEngine.Color.darkSalmon, UnityEngine.Color.darkSeaGreen, UnityEngine.Color.darkSlateBlue, UnityEngine.Color.darkSlateGray, UnityEngine.Color.darkTurquoise, UnityEngine.Color.darkViolet, UnityEngine.Color.deepPink, UnityEngine.Color.deepSkyBlue, UnityEngine.Color.dimGray, UnityEngine.Color.dodgerBlue, UnityEngine.Color.firebrick, UnityEngine.Color.floralWhite, UnityEngine.Color.forestGreen, UnityEngine.Color.gainsboro, UnityEngine.Color.ghostWhite, UnityEngine.Color.gold, UnityEngine.Color.goldenRod, UnityEngine.Color.gray, UnityEngine.Color.gray1, UnityEngine.Color.gray2, UnityEngine.Color.gray3, UnityEngine.Color.gray4, UnityEngine.Color.gray5, UnityEngine.Color.gray6, UnityEngine.Color.gray7, UnityEngine.Color.gray8, UnityEngine.Color.gray9, UnityEngine.Color.green, UnityEngine.Color.greenYellow, UnityEngine.Color.grey, UnityEngine.Color.honeydew, UnityEngine.Color.hotPink, UnityEngine.Color.indianRed, UnityEngine.Color.indigo, UnityEngine.Color.ivory, UnityEngine.Color.khaki, UnityEngine.Color.lavender, UnityEngine.Color.lavenderBlush, UnityEngine.Color.lawnGreen, UnityEngine.Color.lemonChiffon, UnityEngine.Color.lightBlue, UnityEngine.Color.lightCoral, UnityEngine.Color.lightCyan, UnityEngine.Color.lightGoldenRod, UnityEngine.Color.lightGoldenRodYellow, UnityEngine.Color.lightGray, UnityEngine.Color.lightGreen, UnityEngine.Color.lightPink, UnityEngine.Color.lightSalmon, UnityEngine.Color.lightSeaGreen, UnityEngine.Color.lightSkyBlue, UnityEngine.Color.lightSlateBlue, UnityEngine.Color.lightSlateGray, UnityEngine.Color.lightSteelBlue, UnityEngine.Color.lightYellow, UnityEngine.Color.limeGreen, UnityEngine.Color.linen, UnityEngine.Color.magenta, UnityEngine.Color.maroon, UnityEngine.Color.mediumAquamarine, UnityEngine.Color.mediumBlue, UnityEngine.Color.mediumOrchid, UnityEngine.Color.mediumPurple, UnityEngine.Color.mediumSeaGreen, UnityEngine.Color.mediumSlateBlue, UnityEngine.Color.mediumSpringGreen, UnityEngine.Color.mediumTurquoise, UnityEngine.Color.mediumVioletRed, UnityEngine.Color.midnightBlue, UnityEngine.Color.mintCream, UnityEngine.Color.mistyRose, UnityEngine.Color.moccasin, UnityEngine.Color.navajoWhite, UnityEngine.Color.navyBlue, UnityEngine.Color.oldLace, UnityEngine.Color.olive, UnityEngine.Color.oliveDrab, UnityEngine.Color.orange, UnityEngine.Color.orangeRed, UnityEngine.Color.orchid, UnityEngine.Color.paleGoldenRod, UnityEngine.Color.paleGreen, UnityEngine.Color.paleTurquoise, UnityEngine.Color.paleVioletRed, UnityEngine.Color.papayaWhip, UnityEngine.Color.peachPuff, UnityEngine.Color.peru, UnityEngine.Color.pink, UnityEngine.Color.plum, UnityEngine.Color.powderBlue, UnityEngine.Color.purple, UnityEngine.Color.rebeccaPurple, UnityEngine.Color.red, UnityEngine.Color.rosyBrown, UnityEngine.Color.royalBlue, UnityEngine.Color.saddleBrown, UnityEngine.Color.salmon, UnityEngine.Color.sandyBrown, UnityEngine.Color.seaGreen, UnityEngine.Color.seashell, UnityEngine.Color.sienna, UnityEngine.Color.silver, UnityEngine.Color.skyBlue, UnityEngine.Color.slateBlue, UnityEngine.Color.slateGray, UnityEngine.Color.snow, UnityEngine.Color.softBlue, UnityEngine.Color.softGreen, UnityEngine.Color.softRed, UnityEngine.Color.softYellow, UnityEngine.Color.springGreen, UnityEngine.Color.steelBlue, UnityEngine.Color.tan, UnityEngine.Color.teal, UnityEngine.Color.thistle, UnityEngine.Color.tomato, UnityEngine.Color.turquoise, UnityEngine.Color.violet, UnityEngine.Color.violetRed, UnityEngine.Color.wheat, UnityEngine.Color.white, UnityEngine.Color.whiteSmoke, UnityEngine.Color.yellow, UnityEngine.Color.yellowGreen, UnityEngine.Color.yellowNice}); // ->> `new(typeof(UnityEngine.Color).GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static).FindAll(static field => field.FieldType == typeof(UnityEngine.Color)).ConvertAll(static field => (UnityEngine.Color) field.GetValue(null)))`
    private  static readonly System.Collections.Generic.Dictionary            <(System.Type, System.Type), System.Delegate>                                 Converters           = new(1);
    private  static readonly System.Collections.ObjectModel.ReadOnlyDictionary<System.Type, System.Collections.ObjectModel.ReadOnlyCollection<System.Type>> ImplicitTypeConverts = new System.Collections.Generic.Dictionary<System.Type, System.Collections.ObjectModel.ReadOnlyCollection<System.Type>>() {
      {typeof(byte),   new[] {typeof(decimal), typeof(double), typeof(float), typeof(int), typeof(long), typeof(nint), typeof(nuint), typeof(short), typeof(uint), typeof(ulong), typeof(ushort)}.AsReadOnly()},
      {typeof(float),  new[] {typeof(double)}                                                                                                                                                    .AsReadOnly()},
      {typeof(int),    new[] {typeof(decimal), typeof(double), typeof(float), typeof(long), typeof(nint)}                                                                                        .AsReadOnly()},
      {typeof(long),   new[] {typeof(decimal), typeof(double), typeof(float)}                                                                                                                    .AsReadOnly()},
      {typeof(nint),   new[] {typeof(decimal), typeof(double), typeof(float), typeof(long)}                                                                                                      .AsReadOnly()},
      {typeof(nuint),  new[] {typeof(decimal), typeof(double), typeof(float), typeof(ulong)}                                                                                                     .AsReadOnly()},
      {typeof(sbyte),  new[] {typeof(decimal), typeof(double), typeof(float), typeof(int),  typeof(long),  typeof(nint), typeof(short)}                                                          .AsReadOnly()},
      {typeof(short),  new[] {typeof(decimal), typeof(double), typeof(float), typeof(int),  typeof(long),  typeof(nint)}                                                                         .AsReadOnly()},
      {typeof(uint),   new[] {typeof(decimal), typeof(double), typeof(float), typeof(long), typeof(nuint), typeof(ulong)}                                                                        .AsReadOnly()},
      {typeof(ulong),  new[] {typeof(decimal), typeof(double), typeof(float)}                                                                                                                    .AsReadOnly()},
      {typeof(ushort), new[] {typeof(decimal), typeof(double), typeof(float), typeof(int), typeof(long), typeof(nint), typeof(nuint), typeof(uint), typeof(ulong)}                               .AsReadOnly()}
    }.AsReadOnly();
    private static readonly System.Random Randomizer = new();

    /* … */
    [GameMethod(AggressiveInlining)] public static T Cast   <T>   (object? value) => value is not null ? Util.GetCaster   <T>   (value.GetType())(value)    : default!;
    [GameMethod(AggressiveInlining)] public static U Convert<T, U>(in T    value) => value is not null ? Util.GetConverter<T, U>()               (in value) : default!;

    [GameMethod(AggressiveInlining)]
    public static UnityEngine.Vector3[] CornersFrom(in UnityEngine.Rect rectangle) => new UnityEngine.Vector3[4] {new(rectangle.xMin, rectangle.yMax, 0.0f), new(rectangle.xMin, rectangle.yMin, 0.0f), new(rectangle.xMax, rectangle.yMin, 0.0f), new(rectangle.xMax, rectangle.yMax, 0.0f)}; // ->> Origin begins from bottom-left rather than top-left

    [GameMethod(AggressiveInlining)] public static ref          T Eval<T>   (Game.RefAction           <T>    evaluator, ref T value) {  evaluator(ref value); return ref value; }
    [GameMethod(AggressiveInlining)] public static ref readonly T Eval<T>   (Game.RefReadOnlyAction   <T>    evaluator, in  T value) {  evaluator(in  value); return ref value; }
    [GameMethod(AggressiveInlining)] public static U              Eval<T, U>(Game.RefConverter        <T, U> evaluator, ref T value) => evaluator(ref value);
    [GameMethod(AggressiveInlining)] public static U              Eval<T, U>(Game.RefReadOnlyConverter<T, U> evaluator, in  T value) => evaluator(in  value);
    [GameMethod(AggressiveInlining)] public static T              Eval<T>   (System.Action                    <T>    evaluator, in  T value) {  evaluator(value); return value; }
    [GameMethod(AggressiveInlining)] public static U              Eval<T, U>(System.Func                      <T, U> evaluator, in  T value) => evaluator(value);

    [GameMethod(AggressiveInlining)]
    public static UnityEngine.AudioType EvaluateAudioTypeFromExtension(string extension) => (
      string.Equals(extension, "bit", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "dat", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "m1a", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "m1v", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "m2a", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "m4a", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "m4b", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "m4p", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "m4r", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "m4v", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "mp1", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "mp2", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "mp3", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "mp4", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "mpa", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "mpeg", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "mpg", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "mpv", System.StringComparison.OrdinalIgnoreCase) ? UnityEngine.AudioType.MPEG      : // ->> Only MP2 and MP3 supported
      string.Equals(extension, "aac", System.StringComparison.OrdinalIgnoreCase)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ? UnityEngine.AudioType.ACC       :
      string.Equals(extension, "aif", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "aifc", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "aiff", System.StringComparison.OrdinalIgnoreCase)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ? UnityEngine.AudioType.AIFF      :
      string.Equals(extension, "it",  System.StringComparison.OrdinalIgnoreCase)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ? UnityEngine.AudioType.IT        :
      string.Equals(extension, "mod", System.StringComparison.OrdinalIgnoreCase)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ? UnityEngine.AudioType.MOD       :
      string.Equals(extension, "oga", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "ogg", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "ogm", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "opus", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "ogv", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "ogx", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "spx", System.StringComparison.OrdinalIgnoreCase)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ? UnityEngine.AudioType.OGGVORBIS :
      string.Equals(extension, "s3m", System.StringComparison.OrdinalIgnoreCase)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ? UnityEngine.AudioType.S3M       :
      string.Equals(extension, "vag", System.StringComparison.OrdinalIgnoreCase)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ? UnityEngine.AudioType.VAG       :
      string.Equals(extension, "wav", System.StringComparison.OrdinalIgnoreCase) || string.Equals(extension, "wave", System.StringComparison.OrdinalIgnoreCase)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ? UnityEngine.AudioType.WAV       :
      string.Equals(extension, "xm",  System.StringComparison.OrdinalIgnoreCase)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ? UnityEngine.AudioType.XM        :
      UnityEngine.AudioType.UNKNOWN
    );

    public static System.Converter<object, T> GetCaster<T>(System.Type type) {
      if (!Util.Casters.TryGetValue((type, typeof(T)), out System.Delegate caster)) {
        [GameMethod(AggressiveInlining)]
        static System.Converter<object, T> GetUnmanagedCaster(System.Type type) {
          System.Linq.Expressions.ParameterExpression parameter = System.Linq.Expressions.Expression.Parameter(typeof(object), "obj");
          return System.Linq.Expressions.Expression.Lambda<System.Converter<object, T>>(System.Linq.Expressions.Expression.Convert(System.Linq.Expressions.Expression.Convert(parameter, type), typeof(T)), parameter).Compile();
        }

        caster = GetUnmanagedCaster(type);
        Util.Casters.Add((type, typeof(T)), caster);
      }

      return (System.Converter<object, T>) caster;
    }

    public static Game.RefReadOnlyConverter<T, U> GetConverter<T, U>() /* ->> Respects type while reflecting constructors and overloads */ {
      if (!Util.Converters.TryGetValue((typeof(T), typeof(U)), out System.Delegate converter)) {
        [GameMethod(AggressiveInlining)]
        static Game.RefReadOnlyConverter<T, U> GetUnmanagedConverter() {
          System.Linq.Expressions.ParameterExpression parameter = System.Linq.Expressions.Expression.Parameter(typeof(T).MakeByRefType());
          return System.Linq.Expressions.Expression.Lambda<Game.RefReadOnlyConverter<T, U>>(System.Linq.Expressions.Expression.Convert(parameter, typeof(U)), parameter).Compile();
        }

        // …
        if (!typeof(U).IsAssignableFrom(typeof(T))) {
          System.Linq.Expressions.ParameterExpression parameter = System.Linq.Expressions.Expression.Parameter(typeof(T).MakeByRefType());

          // …
          converter = (
            typeof(U).GetConstructors(System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Public).Find([GameMethod(AggressiveInlining)] static (constructor) => { System.Reflection.ParameterInfo[]            parameters = constructor.GetParameters();                                                      return (parameters.Length == 1 || (parameters.Length > 1 && Util.Reference<System.Reflection.ParameterInfo>.At(parameters, 1u).HasDefaultValue)) && (Util.Reference<System.Reflection.ParameterInfo>.Only(parameters).ParameterType.GetElementType() ?? Util.Reference<System.Reflection.ParameterInfo>.Only(parameters).ParameterType).IsAssignableFrom(typeof(T)); }) as System.Reflection.MethodBase ??
            typeof(U).GetMethods     (System.Reflection.BindingFlags.Public   | System.Reflection.BindingFlags.Static)                                           .Find([GameMethod(AggressiveInlining)] static (method)      => { ref readonly System.Reflection.ParameterInfo parameter  = ref Util.Reference<System.Reflection.ParameterInfo>.Only(method.GetParameters()); return (method.Name == "op_Explicit" || method.Name == "op_Implicit")                                                                            && (parameter.ParameterType                                                       .GetElementType() ?? parameter                                                       .ParameterType).IsAssignableFrom(typeof(T)); }) as System.Reflection.MethodBase
          ) switch {
            System.Reflection.ConstructorInfo constructor => System.Linq.Expressions.Expression.Lambda<Game.RefReadOnlyConverter<T, U>>(System.Linq.Expressions.Expression.New (constructor, ((System.Func<System.Linq.Expressions.ParameterExpression, System.Reflection.ParameterInfo[], System.Linq.Expressions.Expression[]>) ([GameMethod(AggressiveInlining)] static (parameter, parameters) => { System.Linq.Expressions.Expression[] expressions; Util.Reference<System.Reflection.ParameterInfo>.First(parameters) = Util.Reference<System.Reflection.ParameterInfo>.At(parameters, 1u); expressions = parameters.ConvertAll([GameMethod(AggressiveInlining)] static (parameter) => (System.Linq.Expressions.Expression) System.Linq.Expressions.Expression.Constant(parameter.DefaultValue, parameter.ParameterType)); Util.Reference<System.Linq.Expressions.Expression>.Only(expressions) = parameter; return expressions; }))(parameter, constructor.GetParameters())), parameter).Compile(),
            System.Reflection.MethodInfo      method      => System.Linq.Expressions.Expression.Lambda<Game.RefReadOnlyConverter<T, U>>(System.Linq.Expressions.Expression.Call(method,      parameter),                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               parameter).Compile(),
            _                                             => [GameMethod(AggressiveInlining)] static (in T value) => {
              try { return (U) System.Convert.ChangeType(value, typeof(U), System.Globalization.CultureInfo.InvariantCulture); }
              catch (System.Exception exception) when (exception is System.InvalidCastException || exception is System.OverflowException) {}

              return ((Game.RefReadOnlyConverter<T, U>) (Util.Converters[(typeof(T), typeof(U))] = GetUnmanagedConverter()))(in value);
            } // ->> Implicitly casted by `switch` expression to `Game.RefReadOnlyConverter<T, U>` 😎
          };
        } else converter = GetUnmanagedConverter();

        Util.Converters.Add((typeof(T), typeof(U)), converter);
      }

      return (Game.RefReadOnlyConverter<T, U>) converter;
    }

    [GameMethod(AggressiveInlining)] public static ref T Invalid<T>() => throw new System.InvalidOperationException("Invalid object encountered");

    [GameMethod(AggressiveInlining)] public static byte                   Lerp(double progress, byte                      valueA,      byte                      valueB)      => (byte)    (valueA + (progress           * (double) (valueB - valueA)));
    [GameMethod(AggressiveInlining)] public static decimal                Lerp(double progress, decimal                   valueA,      decimal                   valueB)      => (decimal) (valueA + ((decimal) progress *          (valueB - valueA)));
    [GameMethod(AggressiveInlining)] public static double                 Lerp(double progress, double                    valueA,      double                    valueB)      => (double)  (valueA + (progress           *          (valueB - valueA)));
    [GameMethod(AggressiveInlining)] public static float                  Lerp(double progress, float                     valueA,      float                     valueB)      => (float)   (valueA + (progress           * (double) (valueB - valueA)));
    [GameMethod(AggressiveInlining)] public static int                    Lerp(double progress, int                       valueA,      int                       valueB)      => (int)     (valueA + (progress           * (double) (valueB - valueA)));
    [GameMethod(AggressiveInlining)] public static long                   Lerp(double progress, long                      valueA,      long                      valueB)      => (long)    (valueA + (progress           * (double) (valueB - valueA)));
    [GameMethod(AggressiveInlining)] public static nint                   Lerp(double progress, nint                      valueA,      nint                      valueB)      => (nint)    (valueA + (progress           * (double) (valueB - valueA)));
    [GameMethod(AggressiveInlining)] public static nuint                  Lerp(double progress, nuint                     valueA,      nuint                     valueB)      => (nuint)   Util.Lerp(progress, (decimal) valueA, (decimal) valueB);
    [GameMethod(AggressiveInlining)] public static sbyte                  Lerp(double progress, sbyte                     valueA,      sbyte                     valueB)      => (sbyte)   Util.Lerp(progress, (float)   valueA, (float)   valueB);
    [GameMethod(AggressiveInlining)] public static short                  Lerp(double progress, short                     valueA,      short                     valueB)      => (short)   (valueA + (progress * (double) (valueB - valueA)));
    [GameMethod(AggressiveInlining)] public static uint                   Lerp(double progress, uint                      valueA,      uint                      valueB)      => (uint)    Util.Lerp(progress, (double)  valueA, (double)  valueB);
    [GameMethod(AggressiveInlining)] public static ulong                  Lerp(double progress, ulong                     valueA,      ulong                     valueB)      => (ulong)   Util.Lerp(progress, (decimal) valueA, (decimal) valueB);
    [GameMethod(AggressiveInlining)] public static ushort                 Lerp(double progress, ushort                    valueA,      ushort                    valueB)      => (ushort)  Util.Lerp(progress, (float)   valueA, (float)   valueB);
    [GameMethod(AggressiveInlining)] public static UnityEngine.Color      Lerp(double progress, in UnityEngine.Color      colorA,      in UnityEngine.Color      colorB)      => UnityEngine.Color     .Lerp(colorA,      colorB,      (float) progress);
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector2    Lerp(double progress, in UnityEngine.Vector2    vectorA,     in UnityEngine.Vector2    vectorB)     => UnityEngine.Vector2   .Lerp(vectorA,     vectorB,     (float) progress);
    [GameMethod(AggressiveInlining)] public static UnityEngine.Vector3    Lerp(double progress, in UnityEngine.Vector3    vectorA,     in UnityEngine.Vector3    vectorB)     => UnityEngine.Vector3   .Lerp(vectorA,     vectorB,     (float) progress);
    [GameMethod(AggressiveInlining)] public static UnityEngine.Quaternion Lerp(double progress, in UnityEngine.Quaternion quaternionA, in UnityEngine.Quaternion quaternionB) => UnityEngine.Quaternion.Lerp(quaternionA, quaternionB, (float) progress);

    public static T Lerp<T>(double progress, in T a, in T b) /* ->> `((b - a) * progress) + a` */ {
      if (a is null || b is null) return default!;

      // … ->> Interpolate also between eligible class types
      ((System.Reflection.MethodInfo addition, System.Reflection.MethodInfo multiplication, System.Reflection.MethodInfo subtraction) methods, (sbyte addition, sbyte multiplication, sbyte subtraction) orders, (System.Type, System.Type progress) types) interpolation = ((null!, null!, null!), (+1, +1, +1), (default!, typeof(double)));
      System.Reflection.MethodInfo[] methods = System.Array.Empty<System.Reflection.MethodInfo>();
      (System.Type a, System.Type b) types   = (a.GetType(), b.GetType());

      // …
      [GameMethod(AggressiveInlining)]
      bool AdditionAssert(System.Type typeA, System.Type typeB, System.Type type) => (
        !typeA.IsArray && !typeA.IsPointer && (typeA.GetElementType() ?? typeA).IsAssignableFrom(type) &&
        !typeB.IsArray && !typeB.IsPointer && (typeB.GetElementType() ?? typeB).IsAssignableFrom(types.a)
      );

      [GameMethod(AggressiveInlining)]
      T Evaluate(object a, object b) {
        object subtraction            = interpolation.methods.subtraction.Invoke(null, new[] {b, a});
        object multiplicationProgress = System.Convert.ChangeType(progress, interpolation.types.progress);
        object multiplication         = interpolation.orders.multiplication switch { +1 => interpolation.methods.multiplication.Invoke(null, new[] {subtraction,    multiplicationProgress}), -1 => interpolation.methods.multiplication.Invoke(null, new[] {multiplicationProgress, subtraction}),    _ => null! };
        object addition               = interpolation.orders.addition       switch { +1 => interpolation.methods.addition      .Invoke(null, new[] {multiplication, a}),                      -1 => interpolation.methods.addition      .Invoke(null, new[] {a,                      multiplication}), _ => null! };

        return (T) addition!;
      }

      [GameMethod(AggressiveInlining)]
      bool MultiplicationAssert(System.Type typeA, System.Type typeB, System.Type type) => !typeA.IsArray && !typeA.IsPointer && (typeA.GetElementType() ?? typeA).IsAssignableFrom(type) && (
        typeB == (interpolation.types.progress = typeof(double)) ||
        typeB == (interpolation.types.progress = typeof(float))  ||
        typeB == (interpolation.types.progress = typeof(decimal))
      );

      [GameMethod(AggressiveInlining)]
      bool SubtractionAssert(System.Type typeA, System.Type typeB, System.Type type = null!) => (
        !typeA.IsArray && !typeA.IsPointer && (typeA.GetElementType() ?? typeA).IsAssignableFrom(types.b) &&
        !typeB.IsArray && !typeB.IsPointer && (typeB.GetElementType() ?? typeB).IsAssignableFrom(types.a)
      );

      // …
      if (types.a != types.b)                                                     return default!;
      if (types.a == typeof(byte))                                                return (T) (object) Util.Lerp(progress, (byte)                   (object) a!, (byte)                   (object) b!);
      if (types.a == typeof(decimal))                                             return (T) (object) Util.Lerp(progress, (decimal)                (object) a!, (decimal)                (object) b!);
      if (types.a == typeof(double))                                              return (T) (object) Util.Lerp(progress, (double)                 (object) a!, (double)                 (object) b!);
      if (types.a == typeof(float))                                               return (T) (object) Util.Lerp(progress, (float)                  (object) a!, (float)                  (object) b!);
      if (types.a == typeof(int))                                                 return (T) (object) Util.Lerp(progress, (int)                    (object) a!, (int)                    (object) b!);
      if (types.a == typeof(long))                                                return (T) (object) Util.Lerp(progress, (long)                   (object) a!, (long)                   (object) b!);
      if (types.a == typeof(nint))                                                return (T) (object) Util.Lerp(progress, (nint)                   (object) a!, (nint)                   (object) b!);
      if (types.a == typeof(nuint))                                               return (T) (object) Util.Lerp(progress, (nuint)                  (object) a!, (nuint)                  (object) b!);
      if (types.a == typeof(sbyte))                                               return (T) (object) Util.Lerp(progress, (sbyte)                  (object) a!, (sbyte)                  (object) b!);
      if (types.a == typeof(short))                                               return (T) (object) Util.Lerp(progress, (short)                  (object) a!, (short)                  (object) b!);
      if (types.a == typeof(uint))                                                return (T) (object) Util.Lerp(progress, (uint)                   (object) a!, (uint)                   (object) b!);
      if (types.a == typeof(ulong))                                               return (T) (object) Util.Lerp(progress, (ulong)                  (object) a!, (ulong)                  (object) b!);
      if (types.a == typeof(ushort))                                              return (T) (object) Util.Lerp(progress, (ushort)                 (object) a!, (ushort)                 (object) b!);
      if (types.a == typeof(UnityEngine.Color))                                   return (T) (object) Util.Lerp(progress, (UnityEngine.Color)      (object) a!, (UnityEngine.Color)      (object) b!);
      if (types.a == typeof(UnityEngine.Vector2))                                 return (T) (object) Util.Lerp(progress, (UnityEngine.Vector2)    (object) a!, (UnityEngine.Vector2)    (object) b!);
      if (types.a == typeof(UnityEngine.Vector3))                                 return (T) (object) Util.Lerp(progress, (UnityEngine.Vector3)    (object) a!, (UnityEngine.Vector3)    (object) b!);
      if (types.a == typeof(UnityEngine.Quaternion))                              return (T) (object) Util.Lerp(progress, (UnityEngine.Quaternion) (object) a!, (UnityEngine.Quaternion) (object) b!);
      if (Timeframe.Interpolations.TryGetValue(types, out interpolation)) return Evaluate(a, b);

      foreach (System.Reflection.MethodInfo subtractionMethod in (methods = types.a.GetMethods(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static))) /* ->> `types.b.GetMethods(…)` */ {
        System.Reflection.ParameterInfo[] subtractionParameters = subtractionMethod.GetParameters();

        // …
        if (subtractionMethod.Name == "op_Subtraction" && subtractionParameters.Length == 2 && SubtractionAssert(subtractionParameters[0].ParameterType, subtractionParameters[1].ParameterType)) {
          interpolation.methods.subtraction    = subtractionMethod;
          interpolation.orders .multiplication = 0;
          interpolation.orders .subtraction    = +1;

          if (0 == interpolation.orders.multiplication) foreach (System.Reflection.MethodInfo multiplicationMethod in methods) { System.Reflection.ParameterInfo[] multiplicationParameters = multiplicationMethod.GetParameters(); if (multiplicationMethod.Name == "op_Multiply" && multiplicationParameters.Length == 2 && MultiplicationAssert(multiplicationParameters[0].ParameterType, multiplicationParameters[1].ParameterType, interpolation.methods.subtraction.ReturnType)) { interpolation.methods.multiplication = multiplicationMethod; interpolation.orders.multiplication = +1; break; } }
          if (0 == interpolation.orders.multiplication) foreach (System.Reflection.MethodInfo multiplicationMethod in methods) { System.Reflection.ParameterInfo[] multiplicationParameters = multiplicationMethod.GetParameters(); if (multiplicationMethod.Name == "op_Multiply" && multiplicationParameters.Length == 2 && MultiplicationAssert(multiplicationParameters[1].ParameterType, multiplicationParameters[0].ParameterType, interpolation.methods.subtraction.ReturnType)) { interpolation.methods.multiplication = multiplicationMethod; interpolation.orders.multiplication = -1; break; } }

          // …
          if (0 != interpolation.orders.multiplication) {
            interpolation.orders.addition = 0;

            if (0 == interpolation.orders.addition) foreach (System.Reflection.MethodInfo additionMethod in methods) { System.Reflection.ParameterInfo[] additionParameters = additionMethod.GetParameters(); if (additionMethod.Name == "op_Addition" && additionParameters.Length == 2 && AdditionAssert(additionParameters[0].ParameterType, additionParameters[1].ParameterType, interpolation.methods.multiplication.ReturnType)) { interpolation.methods.addition = additionMethod; interpolation.orders.addition = +1; break; } }
            if (0 == interpolation.orders.addition) foreach (System.Reflection.MethodInfo additionMethod in methods) { System.Reflection.ParameterInfo[] additionParameters = additionMethod.GetParameters(); if (additionMethod.Name == "op_Addition" && additionParameters.Length == 2 && AdditionAssert(additionParameters[1].ParameterType, additionParameters[0].ParameterType, interpolation.methods.multiplication.ReturnType)) { interpolation.methods.addition = additionMethod; interpolation.orders.addition = -1; break; } }

            if (0 != interpolation.orders.addition) {
              Timeframe.Interpolations.Add(types, interpolation);
              return Evaluate(a, b);
            }
          }
        }
      }

      return default!;
    }

    [GameMethod(AggressiveInlining), GameResolution(0)] public   static decimal Perc  (decimal percentage)                => percentage / 100.0m;
    [GameMethod(AggressiveInlining), GameResolution(2)] public   static double  Perc  (double  percentage)                => percentage / 100.0;
    [GameMethod(AggressiveInlining), GameResolution(1)] public   static float   Perc  (float   percentage)                => percentage / 100.0f;
    [GameMethod(AggressiveInlining), GameResolution(0)] public   static decimal PercOf(decimal value, decimal percentage) => System.Math      .Min(value, (decimal) percentage) * (System.Math      .Max(value, (decimal) percentage) / 100.0m);
    [GameMethod(AggressiveInlining), GameResolution(2)] public   static decimal PercOf(decimal value, double  percentage) => System.Math      .Min(value, (decimal) percentage) * (System.Math      .Max(value, (decimal) percentage) / 100.0m);
    [GameMethod(AggressiveInlining), GameResolution(1)] public   static decimal PercOf(decimal value, float   percentage) => System.Math      .Min(value, (decimal) percentage) * (System.Math      .Max(value, (decimal) percentage) / 100.0m);
    [GameMethod(AggressiveInlining), GameResolution(0)] public   static double  PercOf(double  value, decimal percentage) => System.Math      .Min(value, (double)  percentage) * (System.Math      .Max(value, (double)  percentage) / 100.0);
    [GameMethod(AggressiveInlining), GameResolution(2)] public   static double  PercOf(double  value, double  percentage) => System.Math      .Min(value, (double)  percentage) * (System.Math      .Max(value, (double)  percentage) / 100.0);
    [GameMethod(AggressiveInlining), GameResolution(1)] public   static double  PercOf(double  value, float   percentage) => System.Math      .Min(value, (double)  percentage) * (System.Math      .Max(value, (double)  percentage) / 100.0);
    [GameMethod(AggressiveInlining), GameResolution(0)] public   static float   PercOf(float   value, decimal percentage) => UnityEngine.Mathf.Min(value, (float)   percentage) * (UnityEngine.Mathf.Max(value, (float)   percentage) / 100.0f);
    [GameMethod(AggressiveInlining), GameResolution(2)] public   static float   PercOf(float   value, double  percentage) => UnityEngine.Mathf.Min(value, (float)   percentage) * (UnityEngine.Mathf.Max(value, (float)   percentage) / 100.0f);
    [GameMethod(AggressiveInlining), GameResolution(1)] public   static float   PercOf(float   value, float   percentage) => UnityEngine.Mathf.Min(value, (float)   percentage) * (UnityEngine.Mathf.Max(value, (float)   percentage) / 100.0f);

    [GameMethod(AggressiveInlining)] public static UnityEngine.Component  Prefab(UnityEngine.Component  prefabrication, UnityEngine.Transform? parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local) => null != prefabrication ? (UnityEngine.Component)  (null == parent ? UnityEngine.Object.Instantiate(prefabrication, position, rotation) : UnityEngine.Object.Instantiate(prefabrication, position, rotation, parent)) : null!;
    [GameMethod(AggressiveInlining)] public static UnityEngine.Object     Prefab(UnityEngine.Object     prefabrication, UnityEngine.Transform? parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local) => null != prefabrication ? (UnityEngine.Object)     (null == parent ? UnityEngine.Object.Instantiate(prefabrication, position, rotation) : UnityEngine.Object.Instantiate(prefabrication, position, rotation, parent)) : null!;
    [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject Prefab(UnityEngine.GameObject prefabrication, UnityEngine.Transform? parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local) => null != prefabrication ? (UnityEngine.GameObject) (null == parent ? UnityEngine.Object.Instantiate(prefabrication, position, rotation) : UnityEngine.Object.Instantiate(prefabrication, position, rotation, parent)) : null!;
      [GameMethod(AggressiveInlining)] public static UnityEngine.Component  Prefab   (UnityEngine.Component  prefabrication,                                 in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local = false)                                 =>                                                               Util.Prefab   (prefabrication, null as UnityEngine.Transform,            position,                               rotation,                               local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Component  Prefab   (UnityEngine.Component  prefabrication, UnityEngine.Component?  parent = null)                                                                                                                   =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Component  Prefab   (UnityEngine.Component  prefabrication, UnityEngine.Component?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                                                     =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null, position,                               rotation);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Component  Prefab   (UnityEngine.Component  prefabrication, UnityEngine.GameObject? parent = null)                                                                                                                   =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Component  Prefab   (UnityEngine.Component  prefabrication, UnityEngine.GameObject? parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                                                     =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null, position,                               rotation);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Component  Prefab   (UnityEngine.Component  prefabrication, UnityEngine.Transform?  parent = null)                                                                                                                   => null != prefabrication ?                                      Util.Prefab   (prefabrication, parent,                                   prefabrication.transform.localPosition, prefabrication.transform.localRotation, null != parent) : null!;
      [GameMethod(AggressiveInlining)] public static UnityEngine.Component  Prefab   (UnityEngine.Component  prefabrication, UnityEngine.Transform?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                                                     =>                                                               Util.Prefab   (prefabrication, parent,                                   position,                               rotation,                               null != parent);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Component  Prefab   (UnityEngine.Component  prefabrication, UnityEngine.Component?  parent,                                                                      bool local)                                         =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null,                                                                                 local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Component  Prefab   (UnityEngine.Component  prefabrication, UnityEngine.Component?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local)                                         =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null, position,                               rotation,                               local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Component  Prefab   (UnityEngine.Component  prefabrication, UnityEngine.GameObject? parent,                                                                      bool local)                                         =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null,                                                                                 local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Component  Prefab   (UnityEngine.Component  prefabrication, UnityEngine.GameObject? parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local)                                         =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null, position,                               rotation,                               local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Component  Prefab   (UnityEngine.Component  prefabrication, UnityEngine.Transform?  parent,                                                                      bool local)                                         => null != prefabrication ?                                      Util.Prefab   (prefabrication, parent,                                   prefabrication.transform.localPosition, prefabrication.transform.localRotation, local) : null!;
      [GameMethod(AggressiveInlining)] public static UnityEngine.Object     Prefab   (UnityEngine.Object     prefabrication,                                 in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local = false)                                 =>                                                               Util.Prefab   (prefabrication, null as UnityEngine.Transform,            position,                               rotation,                               local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Object     Prefab   (UnityEngine.Object     prefabrication, UnityEngine.Component?  parent = null)                                                                                                                   =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Object     Prefab   (UnityEngine.Object     prefabrication, UnityEngine.Component?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                                                     =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null, position,                               rotation);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Object     Prefab   (UnityEngine.Object     prefabrication, UnityEngine.GameObject? parent = null)                                                                                                                   =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Object     Prefab   (UnityEngine.Object     prefabrication, UnityEngine.GameObject? parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                                                     =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null, position,                               rotation);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Object     Prefab   (UnityEngine.Object     prefabrication, UnityEngine.Transform?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                                                     =>                                                               Util.Prefab   (prefabrication, parent,                                   position,                               rotation,                               null != parent);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Object     Prefab   (UnityEngine.Object     prefabrication, UnityEngine.Component?  parent,                                                                      bool local)                                         =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null,                                                                                 local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Object     Prefab   (UnityEngine.Object     prefabrication, UnityEngine.Component?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local)                                         =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null, position,                               rotation,                               local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Object     Prefab   (UnityEngine.Object     prefabrication, UnityEngine.GameObject? parent,                                                                      bool local)                                         =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null,                                                                                 local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.Object     Prefab   (UnityEngine.Object     prefabrication, UnityEngine.GameObject? parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local)                                         =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null, position,                               rotation,                               local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject Prefab   (UnityEngine.GameObject prefabrication,                                 in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local = false)                                 =>                                                               Util.Prefab   (prefabrication, null as UnityEngine.Transform,            position,                               rotation,                               local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject Prefab   (UnityEngine.GameObject prefabrication, UnityEngine.Component?  parent = null)                                                                                                                   =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null);
      [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject Prefab   (UnityEngine.GameObject prefabrication, UnityEngine.Component?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                                                     =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null, position,                               rotation);
      [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject Prefab   (UnityEngine.GameObject prefabrication, UnityEngine.GameObject? parent = null)                                                                                                                   =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null);
      [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject Prefab   (UnityEngine.GameObject prefabrication, UnityEngine.GameObject? parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                                                     =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null, position,                               rotation);
      [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject Prefab   (UnityEngine.GameObject prefabrication, UnityEngine.Transform?  parent = null)                                                                                                                   => null != prefabrication ?                                      Util.Prefab   (prefabrication, parent,                                   prefabrication.transform.localPosition, prefabrication.transform.localRotation, null != parent) : null!;
      [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject Prefab   (UnityEngine.GameObject prefabrication, UnityEngine.Transform?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                                                     =>                                                               Util.Prefab   (prefabrication, parent,                                   position,                               rotation,                               null != parent);
      [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject Prefab   (UnityEngine.GameObject prefabrication, UnityEngine.Component?  parent,                                                                      bool local)                                         =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null,                                                                                 local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject Prefab   (UnityEngine.GameObject prefabrication, UnityEngine.Component?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local)                                         =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null, position,                               rotation,                               local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject Prefab   (UnityEngine.GameObject prefabrication, UnityEngine.GameObject? parent,                                                                      bool local)                                         =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null,                                                                                 local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject Prefab   (UnityEngine.GameObject prefabrication, UnityEngine.GameObject? parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local)                                         =>                                                               Util.Prefab   (prefabrication, null != parent ? parent.transform : null, position,                               rotation,                               local);
      [GameMethod(AggressiveInlining)] public static UnityEngine.GameObject Prefab   (UnityEngine.GameObject prefabrication, UnityEngine.Transform?  parent,                                                                      bool local)                                         => null != prefabrication ?                                      Util.Prefab   (prefabrication, parent,                                   prefabrication.transform.localPosition, prefabrication.transform.localRotation, local) : null!;
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.Component  prefabrication,                                 in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local = false) where T : UnityEngine.Component => null != prefabrication && prefabrication.HasComponent<T>() && Util.Prefab   (prefabrication,         position, rotation, local) is UnityEngine.Object clone ? ((UnityEngine.Component)  clone).GetComponent<T>() : null!;
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.Component  prefabrication, UnityEngine.Component?  parent = null)                                                                                   where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.Component  prefabrication, UnityEngine.Component?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                     where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null, position, rotation);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.Component  prefabrication, UnityEngine.Component?  parent,                                                                      bool local)         where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null,                     local);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.Component  prefabrication, UnityEngine.Component?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local)         where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null, position, rotation, local);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.Component  prefabrication, UnityEngine.GameObject? parent = null)                                                                                   where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.Component  prefabrication, UnityEngine.GameObject? parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                     where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null, position, rotation);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.Component  prefabrication, UnityEngine.GameObject? parent,                                                                      bool local)         where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null,                     local);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.Component  prefabrication, UnityEngine.GameObject? parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local)         where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null, position, rotation, local);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.Component  prefabrication, UnityEngine.Transform?  parent = null)                                                                                   where T : UnityEngine.Component => null != prefabrication && prefabrication.HasComponent<T>() && Util.Prefab   (prefabrication, parent)                            is UnityEngine.Object clone ? ((UnityEngine.Component)  clone).GetComponent<T>() : null!;
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.Component  prefabrication, UnityEngine.Transform?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                     where T : UnityEngine.Component => null != prefabrication && prefabrication.HasComponent<T>() && Util.Prefab   (prefabrication, parent, position, rotation)        is UnityEngine.Object clone ? ((UnityEngine.Component)  clone).GetComponent<T>() : null!;
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.Component  prefabrication, UnityEngine.Transform?  parent,                                                                      bool local)         where T : UnityEngine.Component => null != prefabrication && prefabrication.HasComponent<T>() && Util.Prefab   (prefabrication, parent,                     local) is UnityEngine.Object clone ? ((UnityEngine.Component)  clone).GetComponent<T>() : null!;
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.Component  prefabrication, UnityEngine.Transform?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local)         where T : UnityEngine.Component => null != prefabrication && prefabrication.HasComponent<T>() && Util.Prefab   (prefabrication, parent, position, rotation, local) is UnityEngine.Object clone ? ((UnityEngine.Component)  clone).GetComponent<T>() : null!;
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.GameObject prefabrication,                                 in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local = false) where T : UnityEngine.Component => null != prefabrication && prefabrication.HasComponent<T>() && Util.Prefab   (prefabrication,         position, rotation, local) is UnityEngine.Object clone ? ((UnityEngine.GameObject) clone).GetComponent<T>() : null!;
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.GameObject prefabrication, UnityEngine.Component?  parent = null)                                                                                   where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.GameObject prefabrication, UnityEngine.Component?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                     where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null, position, rotation);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.GameObject prefabrication, UnityEngine.Component?  parent,                                                                      bool local)         where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null,                     local);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.GameObject prefabrication, UnityEngine.Component?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local)         where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null, position, rotation, local);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.GameObject prefabrication, UnityEngine.GameObject? parent = null)                                                                                   where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.GameObject prefabrication, UnityEngine.GameObject? parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                     where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null, position, rotation);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.GameObject prefabrication, UnityEngine.GameObject? parent,                                                                      bool local)         where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null,                     local);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.GameObject prefabrication, UnityEngine.GameObject? parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local)         where T : UnityEngine.Component =>                                                               Util.Prefab<T>(prefabrication, null != parent ? parent.transform : null, position, rotation, local);
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.GameObject prefabrication, UnityEngine.Transform?  parent = null)                                                                                   where T : UnityEngine.Component => null != prefabrication && prefabrication.HasComponent<T>() && Util.Prefab   (prefabrication, parent)                            is UnityEngine.Object clone ? ((UnityEngine.GameObject) clone).GetComponent<T>() : null!;
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.GameObject prefabrication, UnityEngine.Transform?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation)                     where T : UnityEngine.Component => null != prefabrication && prefabrication.HasComponent<T>() && Util.Prefab   (prefabrication, parent, position, rotation)        is UnityEngine.Object clone ? ((UnityEngine.GameObject) clone).GetComponent<T>() : null!;
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.GameObject prefabrication, UnityEngine.Transform?  parent,                                                                      bool local)         where T : UnityEngine.Component => null != prefabrication && prefabrication.HasComponent<T>() && Util.Prefab   (prefabrication, parent,                     local) is UnityEngine.Object clone ? ((UnityEngine.GameObject) clone).GetComponent<T>() : null!;
      [GameMethod(AggressiveInlining)] public static T                      Prefab<T>(UnityEngine.GameObject prefabrication, UnityEngine.Transform?  parent, in UnityEngine.Vector3 position, in UnityEngine.Quaternion rotation, bool local)         where T : UnityEngine.Component => null != prefabrication && prefabrication.HasComponent<T>() && Util.Prefab   (prefabrication, parent, position, rotation, local) is UnityEngine.Object clone ? ((UnityEngine.GameObject) clone).GetComponent<T>() : null!;

    [GameMethod(AggressiveInlining), GameResolution(0)] public   static double           Random           ()                                                                                                                 { System.Span<byte> bytes = stackalloc byte[sizeof(double) | sizeof(ulong)]; System.Security.Cryptography.RandomNumberGenerator.Fill(bytes); return (System.BitConverter.ToUInt64(bytes) & ((1uL << 53) - 1)) / (double) (1uL << 53); } // ->> `Util.Randomizer.NextDouble ()`
    [GameMethod(AggressiveInlining), GameResolution(0)] public   static bool             RandomBoolean    (double                probability = 0.5)                                                                          { System.Span<byte> bytes = stackalloc byte[sizeof(bool)];                   System.Security.Cryptography.RandomNumberGenerator.Fill(bytes); return (Util.Reference<byte>.Only(bytes) & 1) == 1; }                                      // ->> `Util.Randomizer.NextBoolean(probability)`
    [GameMethod(AggressiveInlining), GameResolution(0)] internal static uint             RandomUInt       (uint                  range)                                                                                      { System.Span<byte> bytes = stackalloc byte[sizeof(uint)];                   System.Security.Cryptography.RandomNumberGenerator.Fill(bytes); return System.BitConverter.ToUInt32(bytes) % range; }                                      // ->> `Util.Randomizer.Next       (0, (int) range)`
    [GameMethod(AggressiveInlining), GameResolution(0)] public   static UnityEngine.Rect RectFrom         (UnityEngine.Vector3[] corners)                                                                                    { ref readonly UnityEngine.Vector3 origin = ref Util.Reference<UnityEngine.Vector3>.First(corners); return new(origin.x, origin.y, Util.Reference<UnityEngine.Vector3>.At(corners, 3u).x - origin.x, Util.Reference<UnityEngine.Vector3>.At(corners, 1u).y - origin.y); } // ->> Origin begins from bottom-left rather than top-left
    [GameMethod(AggressiveInlining), GameResolution(0)] public   static ref U            Reinterpret<T, U>(ref T                 value)                                                                                      => ref System.Runtime.CompilerServices.Unsafe.As<T, U>(ref value);
    [GameMethod(AggressiveInlining), GameResolution(0)] public   static object?          Switch     <T>   (in  T                 value, Game.Collections.RefReadOnlyDictionary<T, object> expression)                =>      expression.ContainsKey(in value) ?     expression[in value] : null;
    [GameMethod(AggressiveInlining), GameResolution(0)] public   static ref readonly U   Switch     <T, U>(in  T                 value, Game.Collections.RefReadOnlyDictionary<T, U>      expression, in U fallback) => ref (expression.ContainsKey(in value) ? ref expression[in value] : ref fallback);
  }

  public readonly ref struct stdout /* ->> For debugging, essentially */ {
    [GameMethod(AggressiveInlining)] public stdout(object?          value)  => Util.Log.Print(value);
    [GameMethod(AggressiveInlining)] public stdout(params object?[] values) => Util.Log.Print(values);
  }
}

[GameExecutionOrder(int.MinValue)] // ->> `-100` instead?
internal sealed class GameBehaviour : UnityEngine.MonoBehaviour {
  public  const  int            DefaultExecutionOrder = 0;            // ->> `UnityEngine.DefaultExecutionOrderAttribute(…)`
  public  const  int            ExecutionOrder        = int.MinValue; //    ^^
  private static GameBehaviour Main                  = null!;        // ->> Only one instance of `GameBehaviour` should exist

  /* … */
  private void Awake() {
    GameBehaviour.Main ??= this;

    if (GameBehaviour.Main == this) {
      Game.Util.Log.StringsDelimited     = false;
      UnityEngine.Input.backButtonLeavesApp      = true;
      UnityEngine.Input.multiTouchEnabled        = true;  // ->> `UnityEngine.Input.touchCount` is accounted for
      UnityEngine.Input.simulateMouseWithTouches = false; // ->> `UnityEngine.Input.touches`    is accounted for

      UnityEngine.InputSystem.EnhancedTouch.EnhancedTouchSupport.Enable();
    } else Game.Extensions.Die(this); // ->> ඞ: Imposter commit 切腹
  }

  private void LateUpdate() {
    double timestamp = UnityEngine.Time.realtimeSinceStartupAsDouble;

    // …
    if (GameBehaviour.Main == this) {
      Game.Util.UI  .LateUpdate(timestamp);
      Game.Util.Game.LateUpdate(timestamp);
      Game.Util.Wait.CheckTimer();
    }
  }

  private void OnApplicationFocus(bool focused) {
    if (GameBehaviour.Main == this) {
      if (focused) Game.Util.UI.Focus();
      else         Game.Util.UI.Blur ();
    }
  }

  private void OnApplicationQuit() {
    if (GameBehaviour.Main == this && !Game.Util.Game.IsQuitting) {
      this.OnApplicationFocus(false);
      Game.Util.Game.IsQuitting = true;
    }

    if (Game.Util.Load.AudioClipData.IsCreated) // ->> “LeAk dEtEcTeD : PeRsIsTeNt aLlOcAtEs 1 iNdIvIdUaL AlLoCaTiOnS. tO FiNd oUt mOrE PlEaSe eNaBlE 'pReFeReNcEs > jObS > LeAk dEtEcTiOn lEvEl > eNaBlEd wItH StAcK TrAcE' aNd rEpRoDuCe tHe lEaK AgAiN.”
    Game.Util.Load.AudioClipData.Dispose();     // ->> `Unity.Collections.Allocator.Persistent`
  }

  private void OnDestroy() {
    if (GameBehaviour.Main == this) {
      if (!Game.Util.Game.IsQuitting) {
        string message = $"Unexpected exit: God object `{typeof(GameBehaviour)} Game.Util.Game.Object` was destroyed"; // ->> Not a `System.Exception`

        // …
        System.Console.WriteLine(message);
        #if UNITY_EDITOR
          UnityEngine.Debug.Log(Game.Util.Log.Formatted ? $"{"<color=#" + UnityEngine.ColorUtility.ToHtmlStringRGB(Game.Util.Log.ErrorColor) + '>'}Unexpected exit: God object </color><b>`</b>{"<color=#" + UnityEngine.ColorUtility.ToHtmlStringRGB(Game.Util.Log.TypeColor) + '>'}{typeof(GameBehaviour)}</color>{"<color=#" + UnityEngine.ColorUtility.ToHtmlStringRGB(Game.Util.Log.ErrorColor) + '>'}<b> Game.Util.Game.Object`</b> was destroyed</color>" : message);
        #endif

        Game.Util.Game.Quit(0x1 /* ->> `EXIT_FAILURE` */); // ->> Don’t bother continuing the application/ game if `GameBehaviour` is prematurely destroyed
      }

      Game.Util.Game.End(UnityEngine.Time.realtimeSinceStartupAsDouble);
      Game.Util.Game.Object = null;
    }
  }

  private void OnEnable() /* ->> Runs after the `Awake()` and `OnEnable()` methods of pre-existing `UnityEngine.MonoBehaviour` objects; See `UnityEngine.RuntimeInitializeLoadType.AfterSceneLoad` */ {
    if (GameBehaviour.Main == this) {
      UnityEngine.ISerializationCallbackReceiver[] pending = Game.Collections.RefReadOnlyList<UnityEngine.GameObject>.Pending.ToArray();

      // …
      Game.Util.Game.Object = this.gameObject;

      Game.Collections.RefReadOnlyList<UnityEngine.GameObject>.Pending.Clear();
      for (uint index = (uint) pending.Length; 0u != index--; ) pending[index].OnAfterDeserialize();
    }
  }

  private void Start() {
    if (GameBehaviour.Main == this) {
      Game.Util.Game.IsAnimationSequenceAutomatic = true;
      Game.Util.Game.Start(UnityEngine.Time.realtimeSinceStartupAsDouble);
    }
  }

  private void Update() {
    double timestamp = UnityEngine.Time.realtimeSinceStartupAsDouble;

    // …
    if (GameBehaviour.Main == this) {
      Game.Util.UI  .Update(timestamp);
      Game.Util.Game.Update(timestamp);
    }
  }
}
