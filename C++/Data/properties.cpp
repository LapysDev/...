/* Main */
#include <cstdarg>
#include <cstdio>
#include <cstdlib>
#include <type_traits>
#include <utility>

/* ... */
namespace {
  struct halt final {
    constexpr inline halt(...) noexcept = delete;
  };

  template <typename type>
  constexpr inline static type instanceof() noexcept;

  // ...
  enum operation : unsigned char {
    assign,
    add,         assign_add,
    divide,      assign_divide,
    left_shift,  assign_left_shift,
    modulo,      assign_modulo,
    multiply,    assign_multiply,
    right_shift, assign_right_shift,
    subtract,    assign_subtract,

    bitwise_and, assign_bitwise_and,
    bitwise_or,  assign_bitwise_or,
    bitwise_xor, assign_bitwise_xor,

    boolean_and,
    boolean_or,

    equals,
    greater, equals_greater,
    lesser,  equals_lesser,
    compare,
    unequals,

    member_access,
    member_pointer_access,

    post_decrement,
    post_increment,
    pre_decrement,
    pre_increment,

    address,
    call,
    cast,
    comma,
    complement,
    dereference,
    negate,
    minus,
    plus,
    subscript
  };

  // ...
  template <typename...>
  struct pack final {};
}

namespace {
  template <unsigned char, bool, class, typename = pack<void> >
  struct assess_operation final { typedef halt type; static bool const value = false; };

  template <typename typeA, typename... types> struct assess_operation<call,               false, pack<typeA, types...>, pack<decltype(static_cast<void>(instanceof<typeA>()(instanceof<types>()...)))> >             final { typedef decltype(instanceof<typeA>()(instanceof<types>()...))             type; static bool const value = true; };
  template <typename typeA, typename... types> struct assess_operation<call,               true,  pack<typeA, types...>, pack<decltype(static_cast<void>(instanceof<typeA>().operator ()(instanceof<types>()...)))> > final { typedef decltype(instanceof<typeA>().operator ()(instanceof<types>()...)) type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<address,            false, pack<typeA>,           pack<decltype(static_cast<void>(&instanceof<typeA>()))> >                                    final { typedef decltype(&instanceof<typeA>())                                    type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<address,            true,  pack<typeA>,           pack<decltype(static_cast<void>(instanceof<typeA>().operator &()))> >                        final { typedef decltype(instanceof<typeA>().operator &())                        type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<complement,         false, pack<typeA>,           pack<decltype(static_cast<void>(~instanceof<typeA>()))> >                                    final { typedef decltype(~instanceof<typeA>())                                    type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<complement,         true,  pack<typeA>,           pack<decltype(static_cast<void>(instanceof<typeA>().operator ~()))> >                        final { typedef decltype(instanceof<typeA>().operator ~())                        type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<dereference,        false, pack<typeA>,           pack<decltype(static_cast<void>(*instanceof<typeA>()))> >                                    final { typedef decltype(*instanceof<typeA>())                                    type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<dereference,        true,  pack<typeA>,           pack<decltype(static_cast<void>(instanceof<typeA>().operator *()))> >                        final { typedef decltype(instanceof<typeA>().operator *())                        type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<minus,              false, pack<typeA>,           pack<decltype(static_cast<void>(-instanceof<typeA>()))> >                                    final { typedef decltype(-instanceof<typeA>())                                    type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<minus,              true,  pack<typeA>,           pack<decltype(static_cast<void>(instanceof<typeA>().operator -()))> >                        final { typedef decltype(instanceof<typeA>().operator -())                        type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<negate,             false, pack<typeA>,           pack<decltype(static_cast<void>(!instanceof<typeA>()))> >                                    final { typedef decltype(!instanceof<typeA>())                                    type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<negate,             true,  pack<typeA>,           pack<decltype(static_cast<void>(instanceof<typeA>().operator !()))> >                        final { typedef decltype(instanceof<typeA>().operator !())                        type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<plus,               false, pack<typeA>,           pack<decltype(static_cast<void>(+instanceof<typeA>()))> >                                    final { typedef decltype(+instanceof<typeA>())                                    type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<plus,               true,  pack<typeA>,           pack<decltype(static_cast<void>(instanceof<typeA>().operator +()))> >                        final { typedef decltype(instanceof<typeA>().operator +())                        type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<post_decrement,     false, pack<typeA>,           pack<decltype(static_cast<void>(instanceof<typeA>()--))> >                                   final { typedef decltype(instanceof<typeA>()--)                                   type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<post_decrement,     true,  pack<typeA>,           pack<decltype(static_cast<void>(instanceof<typeA>().operator --(0)))> >                      final { typedef decltype(instanceof<typeA>().operator --(0))                      type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<post_increment,     false, pack<typeA>,           pack<decltype(static_cast<void>(instanceof<typeA>()++))> >                                   final { typedef decltype(instanceof<typeA>()++)                                   type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<post_increment,     true,  pack<typeA>,           pack<decltype(static_cast<void>(instanceof<typeA>().operator ++(0)))> >                      final { typedef decltype(instanceof<typeA>().operator ++(0))                      type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<pre_decrement,      false, pack<typeA>,           pack<decltype(static_cast<void>(--instanceof<typeA>()))> >                                   final { typedef decltype(--instanceof<typeA>())                                   type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<pre_decrement,      true,  pack<typeA>,           pack<decltype(static_cast<void>(instanceof<typeA>().operator --()))> >                       final { typedef decltype(instanceof<typeA>().operator --())                       type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<pre_increment,      false, pack<typeA>,           pack<decltype(static_cast<void>(++instanceof<typeA>()))> >                                   final { typedef decltype(++instanceof<typeA>())                                   type; static bool const value = true; };
  template <typename typeA>                    struct assess_operation<pre_increment,      true,  pack<typeA>,           pack<decltype(static_cast<void>(instanceof<typeA>().operator ++()))> >                       final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<add,                false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() + instanceof<typeB>()))> >               final { typedef decltype(instanceof<typeA>() + instanceof<typeB>())               type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<add,                true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator +(instanceof<typeB>())))> >     final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign,             false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() = instanceof<typeB>()))> >               final { typedef decltype(instanceof<typeA>() = instanceof<typeB>())               type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign,             true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator =(instanceof<typeB>())))> >     final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_add,         false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() += instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() += instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_add,         true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator +=(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_bitwise_and, false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() &= instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() &= instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_bitwise_and, true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator &=(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_bitwise_or,  false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() |= instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() |= instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_bitwise_or,  true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator |=(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_bitwise_xor, false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() ^= instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() ^= instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_bitwise_xor, true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator ^=(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_divide,      false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() /= instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() /= instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_divide,      true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator /=(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_left_shift,  false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() <<= instanceof<typeB>()))> >             final { typedef decltype(instanceof<typeA>() <<= instanceof<typeB>())             type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_left_shift,  true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator <<=(instanceof<typeB>())))> >   final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_modulo,      false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() %= instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() %= instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_modulo,      true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator %=(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_multiply,    false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() *= instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() *= instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_multiply,    true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator *=(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_right_shift, false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() >>= instanceof<typeB>()))> >             final { typedef decltype(instanceof<typeA>() >>= instanceof<typeB>())             type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_right_shift, true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator >>=(instanceof<typeB>())))> >   final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_subtract,    false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() -= instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() -= instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<assign_subtract,    true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator -=(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<bitwise_and,        false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() & instanceof<typeB>()))> >               final { typedef decltype(instanceof<typeA>() & instanceof<typeB>())               type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<bitwise_and,        true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator &(instanceof<typeB>())))> >     final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<bitwise_or,         false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() | instanceof<typeB>()))> >               final { typedef decltype(instanceof<typeA>() | instanceof<typeB>())               type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<bitwise_or,         true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator |(instanceof<typeB>())))> >     final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<bitwise_xor,        false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() ^ instanceof<typeB>()))> >               final { typedef decltype(instanceof<typeA>() ^ instanceof<typeB>())               type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<bitwise_xor,        true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator ^(instanceof<typeB>())))> >     final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<boolean_and,        false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() && instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() && instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<boolean_and,        true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator &&(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator ++())                       type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<boolean_or,         false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() || instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() || instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<boolean_or,         true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator ||(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator ||(instanceof<typeB>()))    type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<cast,               false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(static_cast<typeB>(instanceof<typeA>())))> >                 final { typedef decltype(static_cast<typeB>(instanceof<typeA>()))                 type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<cast,               true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator typeB()))> >                    final { typedef decltype(instanceof<typeA>().operator typeB())                    type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<comma,              false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>(), instanceof<typeB>()))> >                final { typedef decltype(instanceof<typeA>(), instanceof<typeB>())                type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<comma,              true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator !=(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator !=(instanceof<typeB>()))    type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<divide,             false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() / instanceof<typeB>()))> >               final { typedef decltype(instanceof<typeA>() / instanceof<typeB>())               type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<divide,             true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator /(instanceof<typeB>())))> >     final { typedef decltype(instanceof<typeA>().operator /(instanceof<typeB>()))     type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<equals,             false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() == instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() == instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<equals,             true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator ==(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator ==(instanceof<typeB>()))    type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<equals_greater,     false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() >= instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() >= instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<equals_greater,     true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator >=(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator >=(instanceof<typeB>()))    type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<equals_lesser,      false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() <= instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() <= instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<equals_lesser,      true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator <=(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator <=(instanceof<typeB>()))    type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<greater,            false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() > instanceof<typeB>()))> >               final { typedef decltype(instanceof<typeA>() > instanceof<typeB>())               type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<greater,            true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator >(instanceof<typeB>())))> >     final { typedef decltype(instanceof<typeA>().operator >(instanceof<typeB>()))     type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<left_shift,         false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() << instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() << instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<left_shift,         true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator <<(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator <<(instanceof<typeB>()))    type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<lesser,             false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() < instanceof<typeB>()))> >               final { typedef decltype(instanceof<typeA>() < instanceof<typeB>())               type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<lesser,             true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator <(instanceof<typeB>())))> >     final { typedef decltype(instanceof<typeA>().operator <(instanceof<typeB>()))     type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<modulo,             false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() % instanceof<typeB>()))> >               final { typedef decltype(instanceof<typeA>() % instanceof<typeB>())               type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<modulo,             true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator %(instanceof<typeB>())))> >     final { typedef decltype(instanceof<typeA>().operator %(instanceof<typeB>()))     type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<multiply,           false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() * instanceof<typeB>()))> >               final { typedef decltype(instanceof<typeA>() * instanceof<typeB>())               type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<multiply,           true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator *(instanceof<typeB>())))> >     final { typedef decltype(instanceof<typeA>().operator *(instanceof<typeB>()))     type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<right_shift,        false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() >> instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() >> instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<right_shift,        true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator >>(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator >>(instanceof<typeB>()))    type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<subscript,          false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>()[instanceof<typeB>()]))> >                final { typedef decltype(instanceof<typeA>()[instanceof<typeB>()])                type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<subscript,          true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator [](instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator [](instanceof<typeB>()))    type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<subtract,           false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() - instanceof<typeB>()))> >               final { typedef decltype(instanceof<typeA>() - instanceof<typeB>())               type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<subtract,           true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator -(instanceof<typeB>())))> >     final { typedef decltype(instanceof<typeA>().operator -(instanceof<typeB>()))     type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<unequals,           false, pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>() != instanceof<typeB>()))> >              final { typedef decltype(instanceof<typeA>() != instanceof<typeB>())              type; static bool const value = true; };
  template <typename typeA, typename typeB>    struct assess_operation<unequals,           true,  pack<typeA, typeB>,    pack<decltype(static_cast<void>(instanceof<typeA>().operator !=(instanceof<typeB>())))> >    final { typedef decltype(instanceof<typeA>().operator !=(instanceof<typeB>()))    type; static bool const value = true; };
}

// ...
template <
  typename base,
  typename accessor_t = void, typename std::conditional<std::is_void<accessor_t>::value, base& (*)(base&) noexcept,                 accessor_t>::type accessor = static_cast<typename std::conditional<std::is_void<accessor_t>::value, base& (*)(base&) noexcept,                 accessor_t>::type>(NULL),
  typename mutator_t  = void, typename std::conditional<std::is_void<mutator_t> ::value, void  (*)(base&, operation, ...) noexcept, mutator_t> ::type mutator  = static_cast<typename std::conditional<std::is_void<mutator_t> ::value, void  (*)(base&, operation, ...) noexcept, mutator_t> ::type>(NULL)
> class property final {
  template <typename subbase, bool = std::is_reference<base>::value> struct value_t                final { friend class property<base, accessor_t, accessor, mutator_t, mutator>; private: mutable subbase value; template <typename... types> constexpr inline value_t(types&&... arguments) noexcept : value{std::forward<types>(arguments)...} {} };
  template <typename subbase>                                        struct value_t<subbase, true> final { friend class property<base, accessor_t, accessor, mutator_t, mutator>; private: subbase value;         template <typename type>     constexpr inline value_t(type&& reference)     noexcept : value(std::forward<type>(reference))     {} };

  private:
    value_t<base> value;

    // [accessor] ...
    template <typename subaccessor_t, typename std::conditional<std::is_void<subaccessor_t>::value, base& (*)(base&) noexcept, subaccessor_t>::type function> constexpr inline static typename std::enable_if<false == std::is_void<subaccessor_t>::value, decltype((*function)(instanceof<base&>()))>::type call_accessor(base& value) noexcept(noexcept((*function)(value))) { return (*function)(value); }
    template <typename subaccessor_t, typename std::conditional<std::is_void<subaccessor_t>::value, base& (*)(base&) noexcept, subaccessor_t>::type>          constexpr inline static typename std::enable_if<false != std::is_void<subaccessor_t>::value, base&>                                     ::type call_accessor(base& value) noexcept                               { return value; }

    // [mutator] ...
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type function, typename... types>                constexpr inline static typename std::enable_if<false == std::is_void<submutator_t>::value, typename std::enable_if<false != std::is_void<decltype((*function)(instanceof<subbase&>(), suboperation, std::declval<types>()...))>::value, int>::type>                                                                                  ::type call_mutator(subbase& value, types&&... arguments) noexcept(noexcept((*function)(instanceof<subbase&>(), suboperation, std::forward<types>(arguments)...))) { return static_cast<void>((*function)(value, suboperation, std::forward<types>(arguments)...)), 0; }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type function, typename... types>                constexpr inline static typename std::enable_if<false == std::is_void<submutator_t>::value, typename std::enable_if<false == std::is_void<decltype((*function)(instanceof<subbase&>(), suboperation, std::declval<types>()...))>::value, decltype((*function)(instanceof<subbase&>(), suboperation, std::declval<types>()...))>::type>::type call_mutator(subbase& value, types&&... arguments) noexcept(noexcept((*function)(instanceof<subbase&>(), suboperation, std::forward<types>(arguments)...))) { return (*function)(value, suboperation, std::forward<types>(arguments)...); }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename type, typename... types> constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == assign,             decltype(instanceof<subbase&>() =  std::declval<type>())> ::type call_mutator(subbase& value, type&& argument, types&&...) noexcept(noexcept(value =  std::forward<type>(argument)))  { return (value =  std::forward<type>(argument)); }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename type, typename... types> constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == assign_add,         decltype(instanceof<subbase&>() +=  std::declval<type>())>::type call_mutator(subbase& value, type&& argument, types&&...) noexcept(noexcept(value +=  std::forward<type>(argument))) { return (value +=  std::forward<type>(argument)); }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename type, typename... types> constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == assign_bitwise_and, decltype(instanceof<subbase&>() &=  std::declval<type>())>::type call_mutator(subbase& value, type&& argument, types&&...) noexcept(noexcept(value &=  std::forward<type>(argument))) { return (value &=  std::forward<type>(argument)); }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename type, typename... types> constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == assign_bitwise_or,  decltype(instanceof<subbase&>() |=  std::declval<type>())>::type call_mutator(subbase& value, type&& argument, types&&...) noexcept(noexcept(value |=  std::forward<type>(argument))) { return (value |=  std::forward<type>(argument)); }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename type, typename... types> constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == assign_bitwise_xor, decltype(instanceof<subbase&>() ^=  std::declval<type>())>::type call_mutator(subbase& value, type&& argument, types&&...) noexcept(noexcept(value ^=  std::forward<type>(argument))) { return (value ^=  std::forward<type>(argument)); }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename type, typename... types> constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == assign_divide,      decltype(instanceof<subbase&>() /=  std::declval<type>())>::type call_mutator(subbase& value, type&& argument, types&&...) noexcept(noexcept(value /=  std::forward<type>(argument))) { return (value /=  std::forward<type>(argument)); }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename type, typename... types> constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == assign_left_shift,  decltype(instanceof<subbase&>() <<= std::declval<type>())>::type call_mutator(subbase& value, type&& argument, types&&...) noexcept(noexcept(value <<= std::forward<type>(argument))) { return (value <<= std::forward<type>(argument)); }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename type, typename... types> constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == assign_modulo,      decltype(instanceof<subbase&>() %=  std::declval<type>())>::type call_mutator(subbase& value, type&& argument, types&&...) noexcept(noexcept(value %=  std::forward<type>(argument))) { return (value %=  std::forward<type>(argument)); }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename type, typename... types> constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == assign_multiply,    decltype(instanceof<subbase&>() *=  std::declval<type>())>::type call_mutator(subbase& value, type&& argument, types&&...) noexcept(noexcept(value *=  std::forward<type>(argument))) { return (value *=  std::forward<type>(argument)); }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename type, typename... types> constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == assign_right_shift, decltype(instanceof<subbase&>() >>= std::declval<type>())>::type call_mutator(subbase& value, type&& argument, types&&...) noexcept(noexcept(value >>= std::forward<type>(argument))) { return (value >>= std::forward<type>(argument)); }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename type, typename... types> constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == assign_subtract,    decltype(instanceof<subbase&>() -=  std::declval<type>())>::type call_mutator(subbase& value, type&& argument, types&&...) noexcept(noexcept(value -=  std::forward<type>(argument))) { return (value -=  std::forward<type>(argument)); }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename... types>                constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == post_decrement,     decltype(instanceof<subbase&>()--)>                       ::type call_mutator(subbase& value, types&&...)                  noexcept(noexcept(value--))                                { return value--; }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename... types>                constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == post_increment,     decltype(instanceof<subbase&>()++)>                       ::type call_mutator(subbase& value, types&&...)                  noexcept(noexcept(value++))                                { return value++; }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename... types>                constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == pre_decrement,      decltype(--instanceof<subbase&>())>                       ::type call_mutator(subbase& value, types&&...)                  noexcept(noexcept(--value))                                { return --value; }
    template <enum operation suboperation, typename subbase, typename submutator_t, typename std::conditional<std::is_void<submutator_t>::value, void (*)(base&, operation, ...) noexcept, submutator_t>::type,          typename... types>                constexpr inline static typename std::enable_if<false != std::is_void<submutator_t>::value && suboperation == pre_increment,      decltype(++instanceof<subbase&>())>                       ::type call_mutator(subbase& value, types&&...)                  noexcept(noexcept(++value))                                { return ++value; }

    // [operate] ... ->> required for unary operator overloads
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<address,        false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&>  >::value, typename assess_operation<address,        false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&>  >::type, halt>::type operate_address(subbase const volatile& value)         noexcept { return &call_accessor<accessor_t, accessor>((subbase&)  value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<address,        false,                                                                                                     pack<subbase&&> >::value, typename assess_operation<address,        false,                                                                                                     pack<subbase&&> >::type, halt>::type operate_address(subbase const volatile&& value)        noexcept { return &call_accessor<accessor_t, accessor>((subbase&&) value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<complement,     false == std::is_integral<typename std::remove_reference<subbase>::type>::value,                           pack<subbase&&> >::value, typename assess_operation<complement,     false == std::is_integral<typename std::remove_reference<subbase>::type>::value,                           pack<subbase&&> >::type, halt>::type operate_complement(subbase const volatile&& value)     noexcept { return ~call_accessor<accessor_t, accessor>((subbase&&) value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<complement,     false == std::is_integral<typename std::remove_reference<subbase>::type>::value,                           pack<subbase&>  >::value, typename assess_operation<complement,     false == std::is_integral<typename std::remove_reference<subbase>::type>::value,                           pack<subbase&>  >::type, halt>::type operate_complement(subbase const volatile& value)      noexcept { return ~call_accessor<accessor_t, accessor>((subbase&)  value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<dereference,    false == std::is_pointer<typename std::decay<typename std::remove_reference<subbase>::type>::type>::value, pack<subbase&&> >::value, typename assess_operation<dereference,    false == std::is_pointer<typename std::decay<typename std::remove_reference<subbase>::type>::type>::value, pack<subbase&&> >::type, halt>::type operate_dereference(subbase&& value)                   noexcept { return *call_accessor<accessor_t, accessor>((subbase&&) value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<dereference,    false == std::is_pointer<typename std::decay<typename std::remove_reference<subbase>::type>::type>::value, pack<subbase&>  >::value, typename assess_operation<dereference,    false == std::is_pointer<typename std::decay<typename std::remove_reference<subbase>::type>::type>::value, pack<subbase&>  >::type, halt>::type operate_dereference(subbase const& value)              noexcept { return *call_accessor<accessor_t, accessor>((subbase&)  value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<minus,          false == std::is_arithmetic<typename std::remove_reference<subbase>::type>::value,                         pack<subbase&&> >::value, typename assess_operation<minus,          false == std::is_arithmetic<typename std::remove_reference<subbase>::type>::value,                         pack<subbase&&> >::type, halt>::type operate_minus(subbase const volatile&& value)          noexcept { return -call_accessor<accessor_t, accessor>((subbase&&) value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<minus,          false == std::is_arithmetic<typename std::remove_reference<subbase>::type>::value,                         pack<subbase&>  >::value, typename assess_operation<minus,          false == std::is_arithmetic<typename std::remove_reference<subbase>::type>::value,                         pack<subbase&>  >::type, halt>::type operate_minus(subbase const volatile& value)           noexcept { return -call_accessor<accessor_t, accessor>((subbase&)  value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<negate,         false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&&> >::value, typename assess_operation<negate,         false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&&> >::type, halt>::type operate_negate(subbase const volatile&& value)         noexcept { return !call_accessor<accessor_t, accessor>((subbase&&) value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<negate,         false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&>  >::value, typename assess_operation<negate,         false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&>  >::type, halt>::type operate_negate(subbase const volatile& value)          noexcept { return !call_accessor<accessor_t, accessor>((subbase&)  value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<plus,           false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&&> >::value, typename assess_operation<plus,           false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&&> >::type, halt>::type operate_plus(subbase const volatile&& value)           noexcept { return +call_accessor<accessor_t, accessor>((subbase&&) value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<plus,           false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&>  >::value, typename assess_operation<plus,           false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&>  >::type, halt>::type operate_plus(subbase const volatile& value)            noexcept { return +call_accessor<accessor_t, accessor>((subbase&)  value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<post_decrement, false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&>  >::value, typename assess_operation<post_decrement, false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&>  >::type, halt>::type operate_post_decrement(subbase const volatile& value)  noexcept { return call_mutator<post_decrement, subbase, mutator_t, mutator>((subbase&)  value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<post_decrement, true,                                                                                                      pack<subbase&&> >::value, typename assess_operation<post_decrement, true,                                                                                                      pack<subbase&&> >::type, halt>::type operate_post_decrement(subbase const volatile&& value) noexcept { return call_mutator<post_decrement, subbase, mutator_t, mutator>((subbase&&) value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<post_increment, false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&>  >::value, typename assess_operation<post_increment, false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&>  >::type, halt>::type operate_post_increment(subbase const volatile& value)  noexcept { return call_mutator<post_increment, subbase, mutator_t, mutator>((subbase&)  value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<post_increment, true,                                                                                                      pack<subbase&&> >::value, typename assess_operation<post_increment, true,                                                                                                      pack<subbase&&> >::type, halt>::type operate_post_increment(subbase const volatile&& value) noexcept { return call_mutator<post_increment, subbase, mutator_t, mutator>((subbase&&) value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<pre_decrement,  false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&>  >::value, typename assess_operation<pre_decrement,  false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&>  >::type, halt>::type operate_pre_decrement(subbase const volatile& value)   noexcept { return call_mutator<pre_decrement,  subbase, mutator_t, mutator>((subbase&)  value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<pre_decrement,  true,                                                                                                      pack<subbase&&> >::value, typename assess_operation<pre_decrement,  true,                                                                                                      pack<subbase&&> >::type, halt>::type operate_pre_decrement(subbase const volatile&& value)  noexcept { return call_mutator<pre_decrement,  subbase, mutator_t, mutator>((subbase&&) value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<pre_increment,  false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&>  >::value, typename assess_operation<pre_increment,  false == std::is_scalar<typename std::remove_reference<subbase>::type>::value,                             pack<subbase&>  >::type, halt>::type operate_pre_increment(subbase const volatile& value)   noexcept { return call_mutator<pre_increment,  subbase, mutator_t, mutator>((subbase&)  value); }
    template <typename subbase> constexpr inline static typename std::conditional<assess_operation<pre_increment,  true,                                                                                                      pack<subbase&&> >::value, typename assess_operation<pre_increment,  true,                                                                                                      pack<subbase&&> >::type, halt>::type operate_pre_increment(subbase const volatile&& value)  noexcept { return call_mutator<pre_increment,  subbase, mutator_t, mutator>((base&&) value); }

  public:
    template <typename... types>
    constexpr inline property(types&&... arguments) noexcept :
      value(std::forward<types>(arguments)...)
    {}

    // ...
    constexpr static base& access(base& value) noexcept {
      return value;
    }

    static base& mutate(base& value, unsigned const operation, ...) noexcept {
      // ... ->> not recommended for non-trivial `base` types
      switch (operation) {
        case assign_add        : { std::va_list arguments; va_start(arguments, operation); value +=  va_arg(arguments, base); va_end(arguments); } break;
        case assign_divide     : { std::va_list arguments; va_start(arguments, operation); value /=  va_arg(arguments, base); va_end(arguments); } break;
        case assign_left_shift : { std::va_list arguments; va_start(arguments, operation); value <<= va_arg(arguments, base); va_end(arguments); } break;
        case assign_modulo     : { std::va_list arguments; va_start(arguments, operation); value %=  va_arg(arguments, base); va_end(arguments); } break;
        case assign_multiply   : { std::va_list arguments; va_start(arguments, operation); value *=  va_arg(arguments, base); va_end(arguments); } break;
        case assign_right_shift: { std::va_list arguments; va_start(arguments, operation); value >>= va_arg(arguments, base); va_end(arguments); } break;
        case assign_subtract   : { std::va_list arguments; va_start(arguments, operation); value -=  va_arg(arguments, base); va_end(arguments); } break;
        case post_decrement    : value--; break;
        case post_increment    : value++; break;
        case pre_decrement     : --value; break;
        case pre_increment     : ++value; break;
      }

      return value;
    }

    // ...
    template <typename type>     constexpr typename std::enable_if<assess_operation<add,            false == std::is_scalar   <typename std::remove_reference<base>::type>::value,                                      pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) +  std::declval<type>())>  ::type operator + (type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) +  std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<bitwise_and,    false == std::is_integral  <typename std::remove_reference<base>::type>::value,                                     pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) &  std::declval<type>())>  ::type operator & (type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) &  std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<bitwise_or,     false == std::is_integral  <typename std::remove_reference<base>::type>::value,                                     pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) |  std::declval<type>())>  ::type operator | (type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) |  std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<bitwise_xor,    false == std::is_integral  <typename std::remove_reference<base>::type>::value,                                     pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) ^  std::declval<type>())>  ::type operator ^ (type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) ^  std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<boolean_and,    false == std::is_scalar   <typename std::remove_reference<base>::type>::value,                                      pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) && std::declval<type>())>  ::type operator &&(type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) && std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<boolean_or,     false == std::is_scalar   <typename std::remove_reference<base>::type>::value,                                      pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) || std::declval<type>())>  ::type operator ||(type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) || std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<comma,          false == std::is_scalar   <typename std::remove_reference<base>::type>::value,                                      pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()),  std::declval<type>())>   ::type operator , (type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)),  std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<divide,         false == std::is_arithmetic<typename std::remove_reference<base>::type>::value,                                     pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) /  std::declval<type>())>  ::type operator / (type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) /  std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<equals,         false == std::is_scalar   <typename std::remove_reference<base>::type>::value,                                      pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) == std::declval<type>())>  ::type operator ==(type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) == std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<equals_greater, false == std::is_scalar   <typename std::remove_reference<base>::type>::value,                                      pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) >= std::declval<type>())>  ::type operator >=(type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) >= std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<equals_lesser,  false == std::is_scalar   <typename std::remove_reference<base>::type>::value,                                      pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) <= std::declval<type>())>  ::type operator <=(type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) <= std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<greater,        false == std::is_scalar   <typename std::remove_reference<base>::type>::value,                                      pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) >  std::declval<type>())>  ::type operator > (type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) >  std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<left_shift,     false == std::is_integral  <typename std::remove_reference<base>::type>::value,                                     pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) << std::declval<type>())>  ::type operator <<(type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) << std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<lesser,         false == std::is_scalar   <typename std::remove_reference<base>::type>::value,                                      pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) <  std::declval<type>())>  ::type operator < (type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) <  std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<modulo,         false == std::is_integral  <typename std::remove_reference<base>::type>::value,                                     pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) %  std::declval<type>())>  ::type operator % (type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) %  std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<multiply,       false == std::is_arithmetic<typename std::remove_reference<base>::type>::value,                                     pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) *  std::declval<type>())>  ::type operator * (type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) *  std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<right_shift,    false == std::is_integral  <typename std::remove_reference<base>::type>::value,                                     pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) >> std::declval<type>())>  ::type operator >>(type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) >> std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<subscript,      false == std::is_pointer  <typename std::decay<typename std::remove_reference<base>::type>::type>::value,           pack<base&&, type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>())[std::declval<type>()])>    ::type operator [](type&& object)      &&             noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value))[std::forward<type>(object)]; }
    template <typename type>     constexpr typename std::enable_if<assess_operation<subscript,      false == std::is_pointer  <typename std::decay<typename std::remove_reference<base>::type>::type>::value,           pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>())[std::declval<type>()])>    ::type operator [](type&& object)      const&         noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value))[std::forward<type>(object)]; }
    template <typename type>     constexpr typename std::enable_if<assess_operation<subtract,       false == std::is_arithmetic<typename std::remove_reference<base>::type>::value,                                     pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) -  std::declval<type>())>  ::type operator - (type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) -  std::forward<type>(object); }
    template <typename type>     constexpr typename std::enable_if<assess_operation<unequals,       false == std::is_scalar   <typename std::remove_reference<base>::type>::value,                                      pack<base&,  type> >    ::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>()) != std::declval<type>())>  ::type operator !=(type&& object)      const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value)) != std::forward<type>(object); }
    template <typename... types> constexpr typename std::enable_if<assess_operation<call,           false == std::is_function  <typename std::remove_pointer<typename std::remove_reference<base>::type>::type>::value, pack<base&,  types...> >::value, decltype(call_accessor<accessor_t, accessor>(instanceof<base&>())(std::declval<types>()...))>::type operator ()(types&&... objects) const volatile noexcept { return call_accessor<accessor_t, accessor>((base&) (this -> value.value))(std::forward<types>(objects)...); }

    template <typename type> inline decltype(call_mutator<assign, base, mutator_t, mutator, type>(instanceof<base&>(), std::declval<type>())) operator =(type&& object) noexcept { return call_mutator<assign, base, mutator_t, mutator, type>((base&) (this -> value.value), std::forward<type>(object)); }
    template <typename type> constexpr typename std::enable_if<assess_operation<assign_add,         false == std::is_scalar   <typename std::remove_reference<base>::type>::value, pack<base&, type> > ::value, decltype(call_mutator<assign_add,         base, mutator_t, mutator, type>(instanceof<base&>(), std::declval<type>()))>::type operator += (type&& object) const volatile& noexcept { return call_mutator<assign_add,         base, mutator_t, mutator, type>((base&) (this -> value.value), std::forward<type>(object)); }
    template <typename type> constexpr typename std::enable_if<assess_operation<assign_bitwise_and, false == std::is_integral  <typename std::remove_reference<base>::type>::value, pack<base&, type> >::value, decltype(call_mutator<assign_bitwise_and, base, mutator_t, mutator, type>(instanceof<base&>(), std::declval<type>()))>::type operator &= (type&& object) const volatile& noexcept { return call_mutator<assign_bitwise_and, base, mutator_t, mutator, type>((base&) (this -> value.value), std::forward<type>(object)); }
    template <typename type> constexpr typename std::enable_if<assess_operation<assign_bitwise_or,  false == std::is_integral  <typename std::remove_reference<base>::type>::value, pack<base&, type> >::value, decltype(call_mutator<assign_bitwise_or,  base, mutator_t, mutator, type>(instanceof<base&>(), std::declval<type>()))>::type operator |= (type&& object) const volatile& noexcept { return call_mutator<assign_bitwise_or,  base, mutator_t, mutator, type>((base&) (this -> value.value), std::forward<type>(object)); }
    template <typename type> constexpr typename std::enable_if<assess_operation<assign_bitwise_xor, false == std::is_integral  <typename std::remove_reference<base>::type>::value, pack<base&, type> >::value, decltype(call_mutator<assign_bitwise_xor, base, mutator_t, mutator, type>(instanceof<base&>(), std::declval<type>()))>::type operator ^= (type&& object) const volatile& noexcept { return call_mutator<assign_bitwise_xor, base, mutator_t, mutator, type>((base&) (this -> value.value), std::forward<type>(object)); }
    template <typename type> constexpr typename std::enable_if<assess_operation<assign_divide,      false == std::is_arithmetic<typename std::remove_reference<base>::type>::value, pack<base&, type> >::value, decltype(call_mutator<assign_divide,      base, mutator_t, mutator, type>(instanceof<base&>(), std::declval<type>()))>::type operator /= (type&& object) const volatile& noexcept { return call_mutator<assign_divide,      base, mutator_t, mutator, type>((base&) (this -> value.value), std::forward<type>(object)); }
    template <typename type> constexpr typename std::enable_if<assess_operation<assign_left_shift,  false == std::is_integral  <typename std::remove_reference<base>::type>::value, pack<base&, type> >::value, decltype(call_mutator<assign_left_shift,  base, mutator_t, mutator, type>(instanceof<base&>(), std::declval<type>()))>::type operator <<=(type&& object) const volatile& noexcept { return call_mutator<assign_left_shift,  base, mutator_t, mutator, type>((base&) (this -> value.value), std::forward<type>(object)); }
    template <typename type> constexpr typename std::enable_if<assess_operation<assign_modulo,      false == std::is_integral  <typename std::remove_reference<base>::type>::value, pack<base&, type> >::value, decltype(call_mutator<assign_modulo,      base, mutator_t, mutator, type>(instanceof<base&>(), std::declval<type>()))>::type operator %= (type&& object) const volatile& noexcept { return call_mutator<assign_modulo,      base, mutator_t, mutator, type>((base&) (this -> value.value), std::forward<type>(object)); }
    template <typename type> constexpr typename std::enable_if<assess_operation<assign_multiply,    false == std::is_arithmetic<typename std::remove_reference<base>::type>::value, pack<base&, type> >::value, decltype(call_mutator<assign_multiply,    base, mutator_t, mutator, type>(instanceof<base&>(), std::declval<type>()))>::type operator *= (type&& object) const volatile& noexcept { return call_mutator<assign_multiply,    base, mutator_t, mutator, type>((base&) (this -> value.value), std::forward<type>(object)); }
    template <typename type> constexpr typename std::enable_if<assess_operation<assign_right_shift, false == std::is_integral  <typename std::remove_reference<base>::type>::value, pack<base&, type> >::value, decltype(call_mutator<assign_right_shift, base, mutator_t, mutator, type>(instanceof<base&>(), std::declval<type>()))>::type operator >>=(type&& object) const volatile& noexcept { return call_mutator<assign_right_shift, base, mutator_t, mutator, type>((base&) (this -> value.value), std::forward<type>(object)); }
    template <typename type> constexpr typename std::enable_if<assess_operation<assign_subtract,    false == std::is_arithmetic<typename std::remove_reference<base>::type>::value, pack<base&, type> >::value, decltype(call_mutator<assign_subtract,    base, mutator_t, mutator, type>(instanceof<base&>(), std::declval<type>()))>::type operator -= (type&& object) const volatile& noexcept { return call_mutator<assign_subtract,    base, mutator_t, mutator, type>((base&) (this -> value.value), std::forward<type>(object)); }

    constexpr inline decltype(operate_address<base>(instanceof<base&>()))         operator &()           const volatile&  noexcept { return operate_address<base>(this -> value.value); }
    constexpr inline decltype(operate_address<base>(instanceof<base&&>()))        operator &()           const volatile&& noexcept { return operate_address<base>(this -> value.value); }
    constexpr inline decltype(operate_complement<base>(instanceof<base&&>()))     operator ~()           const volatile&& noexcept { return operate_complement<base>(this -> value.value); }
    constexpr inline decltype(operate_complement<base>(instanceof<base&>()))      operator ~()           const volatile&  noexcept { return operate_complement<base>(this -> value.value); }
    constexpr inline decltype(operate_dereference<base>(instanceof<base&&>()))    operator *()           &&               noexcept { return operate_dereference<base>(this -> value.value); }
    constexpr inline decltype(operate_dereference<base>(instanceof<base&>()))     operator *()           const&           noexcept { return operate_dereference<base>(this -> value.value); }
    constexpr inline decltype(operate_minus<base>(instanceof<base&&>()))          operator -()           const volatile&& noexcept { return operate_minus<base>(this -> value.value); }
    constexpr inline decltype(operate_minus<base>(instanceof<base&>()))           operator -()           const volatile&  noexcept { return operate_minus<base>(this -> value.value); }
    constexpr inline decltype(operate_negate<base>(instanceof<base&&>()))         operator !()           const volatile&& noexcept { return operate_negate<base>(this -> value.value); }
    constexpr inline decltype(operate_negate<base>(instanceof<base&>()))          operator !()           const volatile&  noexcept { return operate_negate<base>(this -> value.value); }
    constexpr inline decltype(operate_plus<base>(instanceof<base&&>()))           operator +()           const volatile&& noexcept { return operate_plus<base>(this -> value.value); }
    constexpr inline decltype(operate_plus<base>(instanceof<base&>()))            operator +()           const volatile&  noexcept { return operate_plus<base>(this -> value.value); }
    constexpr inline decltype(operate_post_decrement<base>(instanceof<base&>()))  operator --(int const) const volatile&  noexcept { return operate_post_decrement<base>(this -> value.value); }
    constexpr inline decltype(operate_post_decrement<base>(instanceof<base&&>())) operator --(int const) const volatile&& noexcept { return operate_post_decrement<base>(this -> value.value); }
    constexpr inline decltype(operate_post_increment<base>(instanceof<base&>()))  operator ++(int const) const volatile&  noexcept { return operate_post_increment<base>(this -> value.value); }
    constexpr inline decltype(operate_post_increment<base>(instanceof<base&&>())) operator ++(int const) const volatile&& noexcept { return operate_post_increment<base>(this -> value.value); }
    constexpr inline decltype(operate_pre_decrement<base>(instanceof<base&>()))   operator --()          const volatile&  noexcept { return operate_pre_decrement<base>(this -> value.value); }
    constexpr inline decltype(operate_pre_decrement<base>(instanceof<base&&>()))  operator --()          const volatile&& noexcept { return operate_pre_decrement<base>(this -> value.value); }
    constexpr inline decltype(operate_pre_increment<base>(instanceof<base&>()))   operator ++()          const volatile&  noexcept { return operate_pre_increment<base>(this -> value.value); }
    constexpr inline decltype(operate_pre_increment<base>(instanceof<base&&>()))  operator ++()          const volatile&& noexcept { return operate_pre_increment<base>(this -> value.value); }

    constexpr operator base&() noexcept { return this -> value.value; }

    template <typename type> constexpr operator typename std::enable_if<assess_operation<cast, false, pack<base&&, type> >::value, type>::type() const volatile&& noexcept { return static_cast<type>(this -> value.value); }
    template <typename type> constexpr operator typename std::enable_if<assess_operation<cast, false, pack<base&,  type> >::value, type>::type() const volatile&  noexcept { return static_cast<type>(this -> value.value); }
};

/* ... */
constexpr static int  array[3] = {1, 2, 3};
constexpr static int  function() noexcept { return 42; }
constexpr static int  object   = 42;
constexpr static int *pointer  = const_cast<int*>(array);

// ...
static auto get_array   (int (&object)[3]) noexcept -> int (&)[3] { std::putchar('@'); return object; }
static auto get_function(int (&object)())  noexcept -> int (&)()  { std::putchar('@'); return object; }
static auto get_object  (int&  object)     noexcept -> int&       { std::putchar('@'); return object; }
static auto get_pointer (int*& object)     noexcept -> int*&      { std::putchar('@'); return object; }

static auto set_array   (int (&object)[3], ...)                                noexcept -> int (&)[3] { std::putchar('#'); return object; }
static auto set_function(int (&object)(),  ...)                                noexcept -> int (&)()  { std::putchar('#'); return object; }
static auto set_object  (int&  object, operation const type, int  const value) noexcept -> int&       { if (type == assign_add)    object += value; else object = value;     std::putchar('#'); return object; }
static auto set_pointer (int*& object, operation const type, ...)              noexcept -> int*&      { if (type == pre_increment) ++object;        else object = ::pointer; std::putchar('#'); return object; }

/* Main */
int main(int, char*[]) /* noexcept */ {
  struct {
    property<int [3]>   array;     // --> property<int [3],   void, NULL, void, NULL>
    property<int (&)()> function;  // --> property<int (&)(), void, NULL, void, NULL>
    property<int>       object;    // --> property<int,       void, NULL, void, NULL>
    property<int*>      pointer;   // --> property<int*,      void, NULL, void, NULL>
  } alias = {{1, 2, 3}, ::function, ::object, ::pointer};

  struct {
    property<int [3],   int (&(*)(int (&)[3]) noexcept)[3], &get_array>    array;
    property<int (&)(), int (&(*)(int (&)())  noexcept)(),  &get_function> function;
    property<int,       int&  (*)(int&)       noexcept,     &get_object>   object;
    property<int*,      int*& (*)(int*&)      noexcept,     &get_pointer>  pointer;
  } accessor = {{1, 2, 3}, ::function, ::object, ::pointer};

  struct {
    property<int [3],   void, nullptr, int (&(*)(int (&)[3], ...)       noexcept)[3], &set_array>    array;
    property<int (&)(), void, nullptr, int (&(*)(int (&)(),  ...)       noexcept)(),  &set_function> function;
    property<int,       void, nullptr, int&  (*)(int&,  operation, int) noexcept,     &set_object>   object;
    property<int*,      void, nullptr, int*& (*)(int*&, operation, ...) noexcept,     &set_pointer>  pointer;
  } mutator = {{1, 2, 3}, ::function, ::object, ::pointer};

  struct {
    property<int [3],   int (&(*)(int (&)[3]) noexcept)[3], &get_array,    int (&(*)(int (&)[3], ...)       noexcept)[3], &set_array>    array;
    property<int (&)(), int (&(*)(int (&)())  noexcept)(),  &get_function, int (&(*)(int (&)(),  ...)       noexcept)(),  &set_function> function;
    property<int,       int&  (*)(int&)       noexcept,     &get_object,   int&  (*)(int&,  operation, int) noexcept,     &set_object>   object;
    property<int*,      int*& (*)(int*&)      noexcept,     &get_pointer,  int*& (*)(int*&, operation, ...) noexcept,     &set_pointer>  pointer;
  } property = {{1, 2, 3}, ::function, ::object, ::pointer};

  // ...
  std::printf("%1.7s", "[...]" "\r\n");
  std::printf("%1.15s", "  " "[int [3]]  :" " "); std::printf("{%i, %i, %i}" "\r\n", *alias.array, alias.array[1], alias.array[2]);
  std::printf("%1.15s", "  " "[int (&)()]:" " "); std::printf("%i"           "\r\n", alias.function());
  std::printf("%1.15s", "  " "[int]      :" " "); std::printf("%i"           "\r\n", +alias.object);
  std::printf("%1.15s", "  " "[int*]     :" " "); std::printf("%i"           "\r\n", *alias.pointer);

  std::printf("%1.2s", "\r\n");

  std::printf("%1.21s", "[getter (accessor)]" "\r\n");
  std::printf("%1.15s", "  " "[int [3]]  :" " "); std::printf("{%i, %i, %i}" "\r\n", *accessor.array, accessor.array[1], accessor.array[2]);
  std::printf("%1.15s", "  " "[int (&)()]:" " "); std::printf("%i"           "\r\n", accessor.function());
  std::printf("%1.15s", "  " "[int]      :" " "); std::printf("%i"           "\r\n", +accessor.object);
  std::printf("%1.15s", "  " "[int*]     :" " "); std::printf("%i"           "\r\n", *accessor.pointer);

  std::printf("%1.2s", "\r\n");

  std::printf("%1.20s", "[setter (mutator)]" "\r\n");
  std::printf("%1.15s", "  " "[int [3]]  :" " "); std::printf("{%i, %i, %i}" "\r\n", *mutator.array, mutator.array[1], mutator.array[2]);
  std::printf("%1.15s", "  " "[int (&)()]:" " "); std::printf("%i"           "\r\n", mutator.function());
  std::printf("%1.15s", "  " "[int]      :" " "); std::printf("%i, %i"       "\r\n", mutator.object += 27, mutator.object = 42);
  std::printf("%1.15s", "  " "[int*]     :" " "); std::printf("%i, %i"       "\r\n", *++mutator.pointer, *(mutator.pointer = nullptr));

  std::printf("%1.2s", "\r\n");

  std::printf("%1.38s", "[getter/ setter (accessor/ mutator)]" "\r\n");
  std::printf("%1.15s", "  " "[int [3]]  :" " "); std::printf("{%i, %i, %i}" "\r\n", *property.array, property.array[1], property.array[2]);
  std::printf("%1.15s", "  " "[int (&)()]:" " "); std::printf("%i"           "\r\n", property.function());
  std::printf("%1.15s", "  " "[int]      :" " "); std::printf("%i, %i, %i"   "\r\n", +property.object, property.object += 27, property.object = 42);
  std::printf("%1.15s", "  " "[int*]     :" " "); std::printf("%i, %i, %i"   "\r\n", *property.pointer, *++property.pointer, *(property.pointer = nullptr));
}
